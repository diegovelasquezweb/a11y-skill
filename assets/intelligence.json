{
  "rules": {
    "accessible-auth-minimum": {
      "fix": {
        "description": "Authentication must not require solving a cognitive test (CAPTCHA, puzzle, memorization) without providing an accessible alternative (WCAG 3.3.8).",
        "code": "<!-- Option 1: Offer an audio CAPTCHA alternative -->\n<div class=\"captcha-group\">\n  <img src=\"captcha.png\" alt=\"Enter the characters shown\">\n  <a href=\"/audio-captcha\">Use audio CAPTCHA instead</a>\n</div>\n\n<!-- Option 2: Use passkeys (no cognitive test required) -->\n<button type=\"button\" onclick=\"authenticateWithPasskey()\">\n  Sign in with passkey\n</button>"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "When using NextAuth.js, prefer magic link (email provider) or passkey authentication — these eliminate cognitive tests entirely. If CAPTCHA is required, use hCaptcha with accessibility mode enabled, or Google reCAPTCHA v3 (which requires no user interaction).",
        "vue": "In Nuxt, @nuxtjs/auth-next supports email magic links and OAuth providers — both are more accessible than CAPTCHA-based flows. For CAPTCHA, hCaptcha offers an accessible challenge alternative.",
        "angular": "In Angular apps using Auth0 or Firebase Auth, enable passwordless (magic link) or passkey authentication. If CAPTCHA is required, integrate hCaptcha with its accessibility challenge option, which provides audio and visual alternatives."
      },
      "fix_difficulty_notes": "Automated tools can detect the presence of a CAPTCHA but cannot verify whether an accessible alternative is functional. Treat findings as a prompt for manual review. The WCAG 3.3.8 exception allows cognitive tests if an accessible alternative (audio CAPTCHA, passkey, magic link, email OTP) is offered alongside.",
      "manual_test": {
        "description": "Attempt to complete authentication using only a screen reader and no visual CAPTCHA solving.",
        "steps": [
          "Navigate to the login page with VoiceOver active.",
          "If a CAPTCHA is present, verify an audio alternative is offered and functional.",
          "Attempt login using passkey or magic link — no cognitive puzzle should be required."
        ]
      }
    },
    "accesskeys": {
      "fix": {
        "description": "Ensure every accesskey attribute value is unique across the page. Duplicate accesskey values create unpredictable keyboard shortcuts — only one element will receive activation, and which one varies by browser.",
        "code": "<!-- Each accesskey must be unique: -->\n<button accesskey=\"s\">Save</button>\n<button accesskey=\"d\">Delete</button>\n<a href=\"/help\" accesskey=\"h\">Help</a>\n\n<!-- Avoid duplicates: -->\n<!-- <button accesskey=\"s\">Save</button> -->\n<!-- <button accesskey=\"s\">Submit</button> — CONFLICT -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, accessKey is a camelCase JSX prop: <button accessKey='s'>. Track assigned keys in a constants file to prevent duplicates across components. Consider avoiding accesskey entirely — it conflicts with browser and screen reader shortcuts on most platforms.",
        "vue": "In Vue, use accesskey as a plain HTML attribute: <button accesskey='s'>. Maintain a centralized mapping of assigned keys to avoid collisions when multiple components declare accesskeys independently.",
        "angular": "In Angular, bind with [attr.accesskey]='key' or use the plain accesskey attribute. Centralize key assignments in a service or constants file to prevent conflicts between lazy-loaded feature modules."
      },
      "fix_difficulty_notes": "The simplest fix is to remove duplicate accesskey values and assign unique keys. However, accesskey has fundamental usability problems: key combinations vary by OS and browser (Alt+key on Windows, Ctrl+Opt+key on macOS), and they frequently conflict with assistive technology shortcuts. Many accessibility experts recommend avoiding accesskey altogether in favor of skip links and landmark navigation.",
      "manual_test": {
        "description": "Activate each accesskey and verify the correct element receives focus or activation.",
        "steps": [
          "In DevTools Console, run: document.querySelectorAll('[accesskey]') and note all accesskey values.",
          "Verify no two elements share the same accesskey value.",
          "Press the OS-specific accesskey combination (Alt+key on Windows, Ctrl+Opt+key on macOS) for each key and confirm the intended element is activated."
        ]
      }
    },
    "area-alt": {
      "fix": {
        "description": "Every <area> element inside an image map must have alternative text via the alt attribute. Without it, screen readers announce the raw href or nothing at all, making the clickable region invisible to AT users.",
        "code": "<img src=\"floor-plan.png\" alt=\"Office floor plan\" usemap=\"#office-map\">\n<map name=\"office-map\">\n  <area shape=\"rect\" coords=\"0,0,100,100\" href=\"/room-a\" alt=\"Conference Room A\">\n  <area shape=\"circle\" coords=\"200,200,50\" href=\"/room-b\" alt=\"Break Room B\">\n  <area shape=\"poly\" coords=\"300,0,400,100,350,200\" href=\"/room-c\" alt=\"Open Workspace C\">\n</map>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Image maps are rarely used in React apps. If you must use one, pass alt as a prop on each <area> element. Consider replacing the image map with individual clickable components positioned via CSS Grid — this is more maintainable and accessible.",
        "vue": "In Vue, bind alt directly on <area> elements inside <map>. Prefer replacing image maps with positioned <button> or <a> elements overlaid on an image via CSS — image maps are fragile on responsive layouts.",
        "angular": "In Angular, use [attr.alt]='areaLabel' on each <area> element. Image maps do not resize with responsive layouts — consider replacing with an SVG-based interactive graphic using role='img' and embedded links."
      },
      "fix_difficulty_notes": "Image maps are a legacy HTML pattern that does not scale well to responsive layouts — coordinates are pixel-based and break on different viewport sizes. The best long-term fix is to replace the image map with an SVG graphic containing <a> elements, or positioned HTML elements over a background image. If you must keep the image map, ensure every <area> has a descriptive alt attribute.",
      "manual_test": {
        "description": "Navigate the image map with a screen reader and verify each area is announced with its alternative text.",
        "steps": [
          "Tab through the image map — each <area> should receive focus and the screen reader must announce its alt text.",
          "Verify the alt text describes the destination or function, not just 'link' or the URL.",
          "Resize the viewport to confirm clickable regions still align with the visual targets (if the image map is kept)."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The parent <img> of the image map also needs alt text — fix both together."
        },
        {
          "id": "server-side-image-map",
          "reason": "If replacing with a client-side image map, ensure every <area> has alt text."
        }
      ]
    },
    "aria-allowed-attr": {
      "fix": {
        "description": "Remove or replace ARIA attributes that are not supported by the element's role. Each ARIA role defines a specific set of allowed states and properties — using unsupported attributes causes unpredictable screen reader behavior.",
        "code": "<!-- aria-checked is NOT allowed on role='textbox' -->\n<!-- Before: -->\n<div role=\"textbox\" aria-checked=\"true\" contenteditable=\"true\">Text</div>\n<!-- After: remove the unsupported attribute -->\n<div role=\"textbox\" contenteditable=\"true\">Text</div>\n\n<!-- aria-expanded IS allowed on role='button' -->\n<button aria-expanded=\"false\" aria-controls=\"menu-list\">Menu</button>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use eslint-plugin-jsx-a11y with the role-supports-aria-props rule to catch unsupported ARIA attributes at build time. When spreading props onto elements (e.g., {...rest}), unsupported ARIA attributes from parent components can leak through — filter them explicitly.",
        "vue": "In Vue, ARIA attributes pass through to the DOM without validation. Use eslint-plugin-vuejs-accessibility to flag unsupported role/attribute combinations in templates. When using v-bind='$attrs', unwanted ARIA attributes from parent components can propagate.",
        "angular": "In Angular, no built-in validation catches unsupported ARIA attribute/role combinations. Enable @angular-eslint rules for ARIA validation. When using @HostBinding for ARIA attributes, verify the host element's role supports each bound attribute."
      },
      "fix_difficulty_notes": "The fix is straightforward — remove the unsupported attribute or switch to a role that supports it. The WAI-ARIA spec (https://www.w3.org/TR/wai-aria/#role_definitions) lists 'Supported States and Properties' for each role. The most common violation: aria-expanded on an element whose role does not support it (e.g., role='textbox'). If the attribute conveys meaningful state, the role is likely wrong — not the attribute.",
      "manual_test": {
        "description": "Verify the element's ARIA attributes are all recognized by a screen reader after removing unsupported ones.",
        "steps": [
          "Inspect the flagged element in DevTools — note its role and all aria-* attributes.",
          "Cross-reference the role's allowed attributes in the WAI-ARIA spec.",
          "After removing unsupported attributes, test with a screen reader to confirm no state information is lost."
        ]
      },
      "related_rules": [
        {
          "id": "aria-prohibited-attr",
          "reason": "Both rules enforce correct ARIA attribute usage per role — fix them together to avoid repeated passes."
        },
        {
          "id": "aria-required-attr",
          "reason": "After removing unsupported attributes, verify the required attributes for the role are still present."
        },
        {
          "id": "aria-roles",
          "reason": "An invalid role makes all attribute checks unreliable — fix the role first."
        },
        {
          "id": "aria-conditional-attr",
          "reason": "Both rules validate ARIA attribute usage per role — fix them together."
        }
      ]
    },
    "aria-allowed-role": {
      "fix": {
        "description": "Ensure the role attribute value is appropriate for the element. Certain HTML elements have restrictions on which ARIA roles can be applied — for example, <input type='text'> cannot have role='button'.",
        "code": "<!-- Invalid: role='button' on a text input -->\n<!-- <input type=\"text\" role=\"button\"> -->\n\n<!-- Valid: use a <button> for button semantics -->\n<button type=\"button\">Click me</button>\n\n<!-- Valid: role='search' on a <form> is allowed -->\n<form role=\"search\">\n  <label for=\"q\">Search</label>\n  <input type=\"search\" id=\"q\">\n</form>\n\n<!-- Valid: role='presentation' on a layout <table> -->\n<table role=\"presentation\">\n  <tr><td>Layout content</td></tr>\n</table>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, component abstractions may apply roles dynamically via props spread. Audit the rendered DOM to confirm the role is valid for the host element. Libraries like Radix UI choose host elements that match the ARIA role — prefer them over manually assigning roles to arbitrary elements.",
        "vue": "In Vue, dynamic :role bindings may produce invalid pairings at runtime. Ensure computed role values match the host element type. Use browser DevTools to inspect the rendered element and confirm the role is allowed.",
        "angular": "In Angular, avoid [attr.role] bindings that assign roles incompatible with the host element. Angular CDK components select the correct host element for the given role — use them instead of manually overriding roles on arbitrary elements."
      },
      "fix_difficulty_notes": "The ARIA in HTML specification (https://www.w3.org/TR/html-aria/) defines which roles are allowed on each HTML element. The most common violation is adding a role that conflicts with the element's implicit semantics — for example, role='heading' on a <button>. The fix is usually to change the element to one that naturally supports the desired role, rather than forcing a role onto an incompatible element.",
      "manual_test": {
        "description": "Verify the element is announced with the correct role by assistive technology.",
        "steps": [
          "Navigate to the flagged element with VoiceOver or NVDA and note the announced role.",
          "If the role announcement is unexpected or missing, inspect the element in DevTools to confirm the role-element pairing.",
          "Consult the ARIA in HTML spec to verify the role is allowed on that element type."
        ]
      },
      "related_rules": [
        {
          "id": "aria-roles",
          "reason": "aria-roles validates the role value itself; aria-allowed-role validates whether that role is appropriate for the host element."
        },
        {
          "id": "aria-required-attr",
          "reason": "After ensuring the role is allowed, verify all required ARIA attributes for that role are present."
        }
      ]
    },
    "aria-braille-equivalent": {
      "fix": {
        "description": "Elements with aria-braillelabel must also have a visible label (aria-label, aria-labelledby, or visible text content), and elements with aria-brailleroledescription must also have aria-roledescription. Braille attributes are supplements, not replacements.",
        "code": "<!-- Before: braille label without a non-braille equivalent -->\n<button aria-braillelabel=\"Sv\">Save</button>\n<!-- This is actually valid because the button has visible text 'Save' -->\n\n<!-- Invalid: aria-brailleroledescription without aria-roledescription -->\n<div role=\"region\" aria-brailleroledescription=\"rgn\">...</div>\n<!-- After: add the non-braille equivalent -->\n<div role=\"region\" aria-roledescription=\"content region\" aria-brailleroledescription=\"rgn\">...</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Braille ARIA attributes (ariaBraillelabel, ariaBrailleroledescription) are niche — only use them when you have confirmed braille display users need abbreviated labels. Always ensure the non-braille equivalent (aria-label or aria-roledescription) is set first.",
        "vue": "In Vue, use aria-braillelabel and aria-brailleroledescription as standard HTML attributes. They are only useful for braille display optimization — do not add them unless you have a specific braille user need and the non-braille equivalent is already in place.",
        "angular": "In Angular, bind [attr.aria-braillelabel] and [attr.aria-brailleroledescription] only when a non-braille equivalent is already present. These attributes are specialized for braille display users and are rarely needed in typical applications."
      },
      "fix_difficulty_notes": "This rule is rarely triggered because aria-braillelabel and aria-brailleroledescription are specialized attributes used almost exclusively by applications targeting braille display users. The fix is simple: ensure a non-braille accessible name or role description exists alongside the braille variant. If you did not intentionally add braille attributes, they may have been introduced by a third-party library — check your dependencies.",
      "manual_test": {
        "description": "Verify the element has both a braille and non-braille accessible name or role description.",
        "steps": [
          "Inspect the flagged element in DevTools and confirm aria-braillelabel has a corresponding aria-label, aria-labelledby, or visible text.",
          "If aria-brailleroledescription is present, confirm aria-roledescription is also set.",
          "Test with a screen reader to verify the non-braille label is announced correctly."
        ]
      }
    },
    "aria-command-name": {
      "fix": {
        "description": "Every element with role='button', role='link', or role='menuitem' must have an accessible name. Provide one via visible text content, aria-label, or aria-labelledby.",
        "code": "<!-- ARIA button with visible text -->\n<div role=\"button\" tabindex=\"0\">Save changes</div>\n\n<!-- ARIA link with aria-label (icon-only) -->\n<span role=\"link\" tabindex=\"0\" aria-label=\"View documentation\">\n  <svg aria-hidden=\"true\">...</svg>\n</span>\n\n<!-- ARIA menuitem with text content -->\n<li role=\"menuitem\">Copy to clipboard</li>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, custom button components using role='button' instead of native <button> must expose an aria-label prop. Prefer native <button> elements — they have implicit roles and built-in keyboard support. For menu items in Radix UI or Headless UI, ensure the MenuItem component receives text content or an aria-label.",
        "vue": "In Vue, custom interactive components with ARIA roles must pass accessible names to the root element. Use native <button> and <a> elements whenever possible — they provide implicit accessible names from text content.",
        "angular": "In Angular, components using role='button' should accept an ariaLabel input and bind it with [attr.aria-label]. Prefer native HTML elements — Angular CDK's CdkButton directive adds keyboard support to native buttons without requiring custom ARIA roles."
      },
      "fix_difficulty_notes": "The most common cause is icon-only buttons or links built with ARIA roles instead of native elements. The simplest fix is to add aria-label. The best fix is to replace the ARIA role with a native element (<button>, <a>) which receives its accessible name from text content automatically. For menu items, the text content of the <li> or <div role='menuitem'> serves as the accessible name.",
      "manual_test": {
        "description": "Tab to each ARIA command element and verify the screen reader announces a meaningful name.",
        "steps": [
          "Tab to the element — the screen reader must announce a name and role (e.g., 'Save changes, button').",
          "If the element is icon-only, confirm aria-label describes the action, not the icon (e.g., 'Close', not 'X icon').",
          "For menu items, open the menu and arrow through items — each must be announced with its name."
        ]
      },
      "related_rules": [
        {
          "id": "button-name",
          "reason": "button-name covers native <button> elements — fix all button naming violations together."
        },
        {
          "id": "link-name",
          "reason": "link-name covers native <a> elements — fix all interactive element naming together."
        }
      ]
    },
    "aria-conditional-attr": {
      "fix": {
        "description": "ARIA attributes must be used consistently with the element's role semantics. For example, aria-checked should not be set on a role='option' element (use aria-selected instead), and aria-expanded must only be true when the controlled content is actually visible.",
        "code": "<!-- Before: aria-selected on role='checkbox' (should be aria-checked) -->\n<div role=\"checkbox\" aria-selected=\"true\" tabindex=\"0\">Accept terms</div>\n<!-- After: use the correct attribute for the role -->\n<div role=\"checkbox\" aria-checked=\"true\" tabindex=\"0\">Accept terms</div>\n\n<!-- Before: aria-checked on role='option' (should be aria-selected) -->\n<li role=\"option\" aria-checked=\"true\">Item 1</li>\n<!-- After: -->\n<li role=\"option\" aria-selected=\"true\">Item 1</li>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, custom selectable list components often misuse aria-checked on role='option' elements — use aria-selected instead. For toggle buttons, use role='switch' with aria-checked, not role='button' with aria-pressed mixed with aria-checked.",
        "vue": "In Vue, custom dropdown or listbox components may apply aria-checked to options — replace with aria-selected. Use the WAI-ARIA authoring practices as a reference for correct attribute/role pairings.",
        "angular": "In Angular CDK, ListKeyManager-based components should use aria-selected on role='option' items. Custom implementations sometimes incorrectly mix aria-checked with listbox roles — consult the ARIA spec for the correct attribute per role."
      },
      "fix_difficulty_notes": "This rule catches mismatches between ARIA attributes and role semantics — the attribute exists in ARIA but is not valid for the specific role. The fix requires consulting the WAI-ARIA spec to find the correct attribute for the element's role. Common mismatches: aria-checked on role='option' (use aria-selected), aria-pressed on role='switch' (use aria-checked), aria-expanded on role='checkbox' (not supported).",
      "manual_test": {
        "description": "Verify the correct state attribute is announced by a screen reader for the element's role.",
        "steps": [
          "Focus the flagged element — the screen reader should announce the state (selected, checked, expanded, etc.).",
          "Interact with the element and verify the state change is announced correctly.",
          "Cross-reference the announced state with the WAI-ARIA spec's 'Supported States and Properties' for the role."
        ]
      },
      "related_rules": [
        {
          "id": "aria-allowed-attr",
          "reason": "Both rules validate ARIA attribute usage per role — fix them together."
        },
        {
          "id": "aria-valid-attr-value",
          "reason": "After fixing the attribute choice, verify the value is a valid token."
        }
      ]
    },
    "aria-deprecated-role": {
      "fix": {
        "description": "Replace deprecated ARIA roles with their modern equivalents. Deprecated roles may be ignored by assistive technologies or produce unexpected behavior.",
        "code": "<!-- Before: deprecated role='directory' -->\n<ul role=\"directory\">...</ul>\n<!-- After: use role='list' or remove the redundant role -->\n<ul>...</ul>\n\n<!-- Before: deprecated role='doc-biblioentry' used outside DPUB context -->\n<li role=\"doc-biblioentry\">...</li>\n<!-- After: use standard roles -->\n<li role=\"listitem\">...</li>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, deprecated roles are passed as string props without any compile-time warning. Add eslint-plugin-jsx-a11y to catch deprecated role values. When upgrading component libraries, check changelogs for ARIA role changes — deprecated roles may have been valid in older ARIA specs.",
        "vue": "In Vue, deprecated roles pass through to the DOM without validation. Use eslint-plugin-vuejs-accessibility to detect deprecated values in templates.",
        "angular": "In Angular, no built-in validation catches deprecated ARIA roles. Enable @angular-eslint ARIA rules to flag deprecated role values at compile time."
      },
      "fix_difficulty_notes": "The most commonly deprecated role is 'directory' (deprecated in ARIA 1.2, replaced by 'list'). Other deprecated roles include certain DPUB-ARIA roles when used outside digital publishing contexts. The fix is usually straightforward: replace the deprecated role with its modern equivalent or remove it if the native HTML element provides the correct semantics implicitly.",
      "manual_test": {
        "description": "Verify the replacement role is correctly announced by a screen reader.",
        "steps": [
          "Navigate to the element with a screen reader — confirm the role is announced (e.g., 'list', 'region').",
          "If removing the role entirely, verify the native HTML element's implicit role provides the correct semantics.",
          "Check the WAI-ARIA changelog for the recommended replacement of the deprecated role."
        ]
      },
      "related_rules": [
        {
          "id": "aria-roles",
          "reason": "Both rules validate role attribute values — fix all role violations together."
        }
      ]
    },
    "aria-dialog-name": {
      "fix": {
        "description": "Ensure every element with role='dialog' or role='alertdialog' has an accessible name via aria-label or aria-labelledby pointing to a visible heading inside the dialog.",
        "code": "<!-- Using aria-labelledby (preferred — references visible heading): -->\n<div role=\"dialog\" aria-labelledby=\"dialog-title\" aria-modal=\"true\">\n  <h2 id=\"dialog-title\">Confirm deletion</h2>\n  <p>Are you sure you want to delete this item?</p>\n  <button>Cancel</button>\n  <button>Delete</button>\n</div>\n\n<!-- Using aria-label (when no visible heading exists): -->\n<div role=\"alertdialog\" aria-label=\"Session expiring\" aria-modal=\"true\">\n  <p>Your session will expire in 2 minutes.</p>\n  <button>Extend session</button>\n</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, modal libraries (Radix Dialog, Headless UI Dialog, React Aria) require a Title or aria-label prop and wire it to aria-labelledby automatically. If building a custom dialog, ensure the aria-labelledby value matches the id of the heading rendered inside the portal.",
        "vue": "In Vue, Headless UI and PrimeVue dialogs accept a title slot that auto-generates the aria-labelledby association. For custom dialogs using Teleport, verify the aria-labelledby id resolves correctly in the teleported DOM context.",
        "angular": "Angular CDK Dialog and Angular Material MatDialog accept an aria-label or ariaLabelledBy config option. Always provide one. For custom dialogs, bind [attr.aria-labelledby]='titleId' on the role='dialog' element."
      },
      "fix_difficulty_notes": "The preferred approach is aria-labelledby pointing to a visible heading inside the dialog — this keeps the accessible name synchronized with what sighted users see. Use aria-label only when the dialog has no visible title. For alertdialog, also add aria-describedby pointing to the message body so screen readers announce both the title and the alert content.",
      "manual_test": {
        "description": "Open the dialog with a screen reader active and verify the dialog title is announced on focus.",
        "steps": [
          "Trigger the dialog open action — the screen reader must announce the dialog role and its name (e.g., 'Confirm deletion, dialog').",
          "If no name is announced, the dialog lacks aria-label or aria-labelledby.",
          "For alertdialog, verify the alert message is also announced via aria-describedby."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "Dialogs with aria-modal='true' require proper focus trapping — fix naming and modal attributes together."
        }
      ]
    },
    "aria-hidden-body": {
      "fix": {
        "description": "Remove aria-hidden='true' from the <body> element. Setting aria-hidden on the document body hides the entire page from assistive technologies, making it completely inaccessible.",
        "code": "<!-- Before: entire page hidden from AT -->\n<body aria-hidden=\"true\">\n  ...\n</body>\n\n<!-- After: remove aria-hidden from body -->\n<body>\n  ...\n</body>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "This typically occurs when a modal library applies aria-hidden='true' to the body (or the React root) and fails to remove it when the modal closes. Libraries like React Modal (react-modal) manage this automatically via the appElement prop — ensure it is set correctly. If using a custom modal, clean up aria-hidden in the modal's unmount/close lifecycle.",
        "vue": "In Vue, this can happen when a dialog plugin sets aria-hidden='true' on document.body during open and fails to remove it on close (e.g., due to an error during the close transition). Always use a finally block or watch handler to guarantee cleanup.",
        "angular": "In Angular, Angular CDK Dialog and Material Dialog manage aria-hidden on sibling elements, not on <body> itself. If you see aria-hidden on <body>, a third-party library or custom modal implementation is likely the cause — trace it via DOM mutation breakpoints in DevTools."
      },
      "fix_difficulty_notes": "This is almost always a bug, not an intentional design choice. The most common cause: a modal dialog sets aria-hidden='true' on the body or app root during open, and the cleanup code fails to run (due to an error, race condition, or missing unmount handler). The fix is to ensure the modal's close/destroy logic always removes aria-hidden from the body. Use the inert attribute (now widely supported) as a modern alternative to aria-hidden for hiding background content behind modals.",
      "manual_test": {
        "description": "Verify aria-hidden='true' is never present on <body> during normal page interaction.",
        "steps": [
          "Open DevTools and inspect the <body> element — aria-hidden should not be 'true'.",
          "Open and close all modals/dialogs on the page, then re-inspect <body> — aria-hidden must be removed after close.",
          "Activate a screen reader and confirm the page content is fully announced."
        ]
      },
      "related_rules": [
        {
          "id": "aria-hidden-focus",
          "reason": "Both involve aria-hidden misuse — if aria-hidden is on the body, all focusable elements are affected."
        }
      ]
    },
    "aria-hidden-focus": {
      "fix": {
        "description": "Remove aria-hidden=\"true\" from elements that can receive focus, or exclude them from the tab order.",
        "code": "<!-- Option 1: Remove aria-hidden -->\n<button>Visible button</button>\n<!-- Option 2: Keep hidden but remove from tab order -->\n<span aria-hidden=\"true\" tabindex=\"-1\">Decorative text</span>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React portals (modals, dialogs, tooltips), aria-hidden='true' is commonly applied to the app root during open state. Ensure portals render outside the aria-hidden subtree (e.g., appended to <body>). Libraries like Radix UI handle this correctly via the inert attribute and portal rendering.",
        "vue": "In Vue with Teleport, the teleported content renders outside the component's DOM subtree — verify the Teleport target element (e.g., #teleport-target or body) is not inside an aria-hidden container.",
        "angular": "Angular CDK Overlay (used by Material dialogs and menus) renders at the body level, outside aria-hidden scopes. Verify that aria-hidden is applied to the correct host element — not to a container that includes the CDK overlay outlet."
      },
      "fix_difficulty_notes": "Setting aria-hidden='true' on a parent hides all its descendants from AT but does not remove their keyboard focusability. Interactive children (buttons, links, inputs) inside an aria-hidden container will still receive Tab focus, creating 'ghost focus'. Apply tabindex='-1' to each interactive descendant, or restructure so no focusable elements exist inside the aria-hidden container.",
      "manual_test": {
        "description": "Tab into the flagged element and verify a screen reader either announces it or skips it cleanly.",
        "steps": [
          "Tab to the element — if focus reaches it while aria-hidden=\"true\" is set, the fix is needed.",
          "After fix: Tab through the area again — the element should either be announced (aria-hidden removed) or completely skipped (tabindex=-1 added).",
          "With VoiceOver or NVDA active, confirm no 'ghost' announcement occurs."
        ]
      },
      "related_rules": [
        {
          "id": "scrollable-region-focusable",
          "reason": "Both affect keyboard focus — audit all focusability violations together to avoid conflicts."
        },
        {
          "id": "aria-hidden-body",
          "reason": "Both involve aria-hidden misuse — if aria-hidden is on the body, all focusable elements are affected."
        }
      ]
    },
    "aria-input-field-name": {
      "fix": {
        "description": "Add an accessible name to ARIA input fields (role='textbox', role='searchbox', role='spinbutton', role='slider', role='combobox') via aria-label or aria-labelledby.",
        "code": "<!-- ARIA textbox with aria-labelledby: -->\n<span id=\"search-label\">Search</span>\n<div role=\"textbox\" contenteditable=\"true\"\n  aria-labelledby=\"search-label\"\n  aria-multiline=\"false\">\n</div>\n\n<!-- Prefer native input (simpler, better AT support): -->\n<label for=\"search\">Search</label>\n<input type=\"search\" id=\"search\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Rich text editors (Draft.js, Slate, Quill) use contenteditable divs with role='textbox'. Ensure the editor component exposes an aria-label prop and applies it to the root contenteditable element. For standard inputs, always use <label htmlFor='id'>.",
        "vue": "WYSIWYG editor components (Tiptap, Quill) wrap role='textbox' elements. Pass aria-label via the component's label prop. For standard inputs, use <label :for='id'>.",
        "angular": "Angular CDK or ProseMirror-based editors use contenteditable with ARIA roles. Bind [attr.aria-label]='editorLabel' on the root element. For standard inputs, use mat-label or <label [for]='id'>."
      },
      "fix_difficulty_notes": "The best fix is almost always to replace the ARIA input with a native HTML input — native elements have implicit roles, built-in keyboard support, and do not require manual ARIA attribute management. Use ARIA input roles only when a native equivalent is technically impossible (e.g., a rich text editor with contenteditable).",
      "manual_test": {
        "description": "Tab to the ARIA input and verify the screen reader announces both the label and its role.",
        "steps": [
          "Tab to the element — the AT must announce the label and role (e.g., 'Search, text field').",
          "Type into the field — typed characters must be echoed by the screen reader.",
          "For custom editors, verify aria-multiline is set correctly ('true' for multiline, 'false' for single-line)."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "If a native input can replace the ARIA input, the standard label association pattern resolves both."
        },
        {
          "id": "aria-toggle-field-name",
          "reason": "Fix all ARIA field naming violations together — they share the same accessible name patterns."
        }
      ]
    },
    "aria-meter-name": {
      "fix": {
        "description": "Every element with role='meter' must have an accessible name via aria-label, aria-labelledby, or the title attribute. Without a name, screen readers announce the value but not what is being measured.",
        "code": "<!-- Using aria-label -->\n<div role=\"meter\" aria-valuenow=\"75\" aria-valuemin=\"0\" aria-valuemax=\"100\"\n  aria-label=\"Battery level\">\n  75%\n</div>\n\n<!-- Using aria-labelledby -->\n<span id=\"disk-label\">Disk usage</span>\n<div role=\"meter\" aria-valuenow=\"42\" aria-valuemin=\"0\" aria-valuemax=\"100\"\n  aria-labelledby=\"disk-label\">\n  42%\n</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, custom meter components should accept an aria-label or label prop and apply it to the element with role='meter'. Prefer the native <meter> element when possible — it has implicit semantics and is styled via ::-webkit-meter-bar pseudo-elements.",
        "vue": "In Vue, pass aria-label or aria-labelledby to the root element of custom meter components. The native <meter> element works in Vue templates and provides built-in AT support without ARIA attributes.",
        "angular": "In Angular, bind [attr.aria-label]='meterLabel' on custom meter components. Angular Material does not include a meter component — if using MatProgressBar as a meter, ensure role='meter' is set alongside the accessible name."
      },
      "fix_difficulty_notes": "The native <meter> element is the preferred approach — it provides implicit semantics, does not require role='meter', and has built-in accessible value announcements. Use role='meter' only when the native element cannot be styled to match design requirements. When using role='meter', all three value attributes (aria-valuenow, aria-valuemin, aria-valuemax) are required alongside the accessible name.",
      "manual_test": {
        "description": "Focus the meter element with a screen reader and verify both the label and current value are announced.",
        "steps": [
          "Navigate to the meter with a screen reader — it must announce the label and value (e.g., 'Battery level, 75 percent').",
          "Verify aria-valuenow updates dynamically if the value changes in real time.",
          "If using the native <meter> element, confirm it is announced as a meter with its label."
        ]
      },
      "related_rules": [
        {
          "id": "aria-progressbar-name",
          "reason": "Meters and progress bars share the same accessible name requirements — fix both together."
        }
      ]
    },
    "aria-progressbar-name": {
      "fix": {
        "description": "Every element with role='progressbar' must have an accessible name via aria-label, aria-labelledby, or the title attribute. Without a name, screen readers announce the progress value but not what process it represents.",
        "code": "<!-- Using aria-label -->\n<div role=\"progressbar\" aria-valuenow=\"60\" aria-valuemin=\"0\" aria-valuemax=\"100\"\n  aria-label=\"File upload progress\">\n  60%\n</div>\n\n<!-- Using aria-labelledby -->\n<span id=\"download-label\">Downloading update</span>\n<progress id=\"download\" max=\"100\" value=\"30\" aria-labelledby=\"download-label\">\n  30%\n</progress>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, use the native <progress> element when possible — it has implicit role='progressbar'. For custom progress bars (e.g., animated SVG rings), ensure the wrapper has role='progressbar', aria-valuenow, and aria-label. Libraries like Radix UI Progress expose these props automatically.",
        "vue": "In Vue, the native <progress> element works in templates and provides built-in AT support. For custom progress components (e.g., Vuetify's v-progress-linear), pass the label prop or aria-label to ensure the component renders an accessible name.",
        "angular": "Angular Material's MatProgressBar (mat-progress-bar) applies role='progressbar' automatically but does not set an accessible name by default. Add [attr.aria-label]='progressLabel' to the <mat-progress-bar> element."
      },
      "fix_difficulty_notes": "The native <progress> element is the simplest solution — it has an implicit progressbar role and built-in AT value announcements. For indeterminate progress bars (no known completion percentage), omit aria-valuenow and set aria-valuemin and aria-valuemax — the screen reader will announce 'busy' or 'loading'. Custom animated progress indicators (CSS-only or SVG) are the hardest to fix — they require explicit ARIA attributes on a wrapping element.",
      "manual_test": {
        "description": "Navigate to the progress bar with a screen reader and verify the label and current value are announced.",
        "steps": [
          "Focus or navigate to the progress bar — the screen reader must announce its name and value (e.g., 'File upload progress, 60 percent').",
          "If the progress updates dynamically, confirm the screen reader announces changes (via aria-live or native behavior).",
          "For indeterminate progress bars, verify the screen reader announces a loading/busy state."
        ]
      },
      "related_rules": [
        {
          "id": "aria-meter-name",
          "reason": "Meters and progress bars share the same accessible name requirements — fix both together."
        }
      ]
    },
    "aria-prohibited-attr": {
      "fix": {
        "description": "Remove ARIA attributes that are prohibited for the element's role. Each ARIA role has a defined set of allowed attributes — attributes outside that set are ignored or cause incorrect AT behavior.",
        "code": "<!-- aria-label is prohibited on role='presentation' and role='none' -->\n<!-- Before: -->\n<div role=\"none\" aria-label=\"Section wrapper\">...</div>\n<!-- After: -->\n<div>...</div>\n\n<!-- aria-checked is prohibited on role='button' -->\n<!-- Before: -->\n<button role=\"button\" aria-checked=\"true\">Toggle</button>\n<!-- After (use role='switch' for toggle state): -->\n<button role=\"switch\" aria-checked=\"true\">Toggle</button>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, ARIA attributes are passed as JSX props — there is no compile-time check for prohibited combinations. Use eslint-plugin-jsx-a11y, which includes the role-supports-aria-props rule to catch these at build time.",
        "vue": "In Vue, ARIA attributes are standard HTML attributes — no framework-level check exists. Use eslint-plugin-vue with vue/no-aria-hidden-on-focusable or similar lint rules.",
        "angular": "In Angular, no built-in check prevents prohibited ARIA combinations. The Angular CDK a11y lint rules (via @angular-eslint) flag some cases — enable them in .eslintrc."
      },
      "fix_difficulty_notes": "The most common case is aria-label on role='none' or role='presentation' — the role explicitly removes the element from the accessibility tree, so any ARIA attribute on it has no effect (and axe flags it). Also common: adding aria-expanded or aria-checked to a plain <button> role instead of using role='switch' or role='menuitemcheckbox'. Consult https://www.w3.org/TR/wai-aria/#role_definitions for the 'Inherited States and Properties' list per role.",
      "manual_test": {
        "description": "Verify ARIA attributes on the flagged element are permitted by its role.",
        "steps": [
          "Inspect the flagged element in DevTools — note its role (explicit or implicit) and all aria-* attributes.",
          "Look up the role in the WAI-ARIA spec (https://www.w3.org/TR/wai-aria/#role_definitions) and find its 'Supported States and Properties' list.",
          "Remove any attribute not listed. If the attribute is semantically needed, switch to a role that supports it."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "Often co-located — fix the role first, then verify required attributes are present and prohibited ones are removed."
        },
        {
          "id": "aria-valid-attr-value",
          "reason": "After fixing prohibited attrs, check that remaining ARIA attribute values are valid tokens."
        },
        {
          "id": "aria-roles",
          "reason": "Often co-located — fix the role first, then verify required attributes are present and prohibited ones are removed."
        },
        {
          "id": "aria-allowed-attr",
          "reason": "Both rules enforce correct ARIA attribute usage per role — fix them together to avoid repeated passes."
        },
        {
          "id": "presentation-role-conflict",
          "reason": "Both rules address ARIA attributes that should not be present on the element — fix together."
        }
      ]
    },
    "aria-required-attr": {
      "fix": {
        "description": "Add the required ARIA attribute(s) for the element's role. See the WAI-ARIA spec for required attributes per role.",
        "code": "<!-- combobox requires: aria-expanded + aria-controls -->\n<div role=\"combobox\" aria-expanded=\"false\" aria-controls=\"listbox-id\" aria-haspopup=\"listbox\">\n  <input type=\"text\" aria-autocomplete=\"list\">\n</div>\n<ul role=\"listbox\" id=\"listbox-id\">...</ul>\n\n<!-- scrollbar requires: aria-controls + aria-valuenow + aria-valuemin + aria-valuemax -->\n<div role=\"scrollbar\" aria-controls=\"scrollable-region\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"100\"></div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Headless component libraries (Radix UI, Headless UI, Ark UI) handle required ARIA attributes internally — do not duplicate or override them. If building a custom ARIA widget from scratch, consult the WAI-ARIA spec for each role's required attributes before binding props.",
        "vue": "Floating Vue, Headless UI for Vue, and Vuetify manage ARIA attributes internally. Only add ARIA attributes when building custom widgets. Binding incorrect or unsupported attributes can introduce new violations rather than fixing existing ones.",
        "angular": "Angular CDK's a11y module (FocusTrap, ListKeyManager, ActiveDescendantKeyManager) manages required ARIA attributes for composite widgets. Use these utilities before building custom ARIA widgets from scratch."
      },
      "fix_difficulty_notes": "Required attributes vary per role — consult https://www.w3.org/TR/wai-aria/#role_definitions. The most frequent mistake: using role='combobox' without aria-expanded, or role='slider' without aria-valuenow/aria-valuemin/aria-valuemax. When in doubt, prefer native HTML elements (e.g., <select> instead of role='listbox') which carry implicit semantics.",
      "manual_test": {
        "description": "Verify the ARIA widget is fully operable by a screen reader after adding the required attributes.",
        "steps": [
          "Locate the flagged element in DevTools and read its role attribute.",
          "Cross-reference the WAI-ARIA spec (https://www.w3.org/TR/wai-aria/) for required attributes of that role.",
          "Tab to the element with a screen reader active — confirm all state information (expanded, selected, etc.) is announced."
        ]
      },
      "related_rules": [
        {
          "id": "aria-roles",
          "reason": "An invalid role is often the root cause of missing required attributes — fix the role first."
        },
        {
          "id": "aria-valid-attr-value",
          "reason": "After adding required attributes, verify their values are valid."
        },
        {
          "id": "aria-prohibited-attr",
          "reason": "After adding required attributes, verify no prohibited attributes remain for the fixed role."
        },
        {
          "id": "aria-toggle-field-name",
          "reason": "role=\"switch\" requires aria-checked — fix accessible name and required attributes together."
        },
        {
          "id": "aria-allowed-attr",
          "reason": "After removing unsupported attributes, verify the required attributes for the role are still present."
        },
        {
          "id": "aria-allowed-role",
          "reason": "After ensuring the role is allowed, verify all required ARIA attributes for that role are present."
        },
        {
          "id": "aria-dialog-name",
          "reason": "Dialogs with aria-modal='true' require proper focus trapping — fix naming and modal attributes together."
        }
      ]
    },
    "aria-required-children": {
      "fix": {
        "description": "Elements with certain ARIA roles must contain specific child roles. For example, role='list' requires children with role='listitem', and role='tablist' requires children with role='tab'.",
        "code": "<!-- role='list' requires role='listitem' children -->\n<div role=\"list\">\n  <div role=\"listitem\">Item 1</div>\n  <div role=\"listitem\">Item 2</div>\n</div>\n\n<!-- role='tablist' requires role='tab' children -->\n<div role=\"tablist\" aria-label=\"Settings\">\n  <button role=\"tab\" aria-selected=\"true\" aria-controls=\"panel-1\">General</button>\n  <button role=\"tab\" aria-selected=\"false\" aria-controls=\"panel-2\">Advanced</button>\n</div>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, wrapper elements between the parent and child roles (e.g., a <div> between role='list' and role='listitem') break the required parent-child relationship. Use role='presentation' or role='none' on intermediate wrappers to make them semantically transparent. In tabbed interfaces, ensure role='tab' elements are direct children of role='tablist'.",
        "vue": "In Vue, component wrapper elements can introduce extra DOM nodes between required role relationships. Use Vue 3 Fragments or <template> to avoid wrapper elements, or apply role='none' to intermediate wrappers.",
        "angular": "In Angular, host elements of child components create extra DOM layers. Use the host property in @Component to set role='none' on the host element, or use attribute selectors on the host to eliminate extra wrappers."
      },
      "fix_difficulty_notes": "The most common cause in component frameworks is an intermediate wrapper element between the parent and child roles. The wrapper breaks the ARIA relationship because the child role is no longer a direct descendant of the parent role in the accessibility tree. Solutions: (1) apply role='none' or role='presentation' to the wrapper, (2) restructure to eliminate the wrapper, or (3) use owned children via aria-owns (last resort). Reference: https://www.w3.org/TR/wai-aria/#mustContain.",
      "manual_test": {
        "description": "Verify the parent-child ARIA relationship is intact by navigating with a screen reader.",
        "steps": [
          "Navigate into the composite widget (list, tablist, menu, tree) with a screen reader.",
          "Arrow through the children — each must be announced with its correct role (e.g., 'tab 1 of 3').",
          "If children are not announced or the count is wrong, intermediate wrapper elements may be breaking the relationship."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-parent",
          "reason": "Required children and required parent are complementary checks — fix both together to ensure complete ARIA relationships."
        },
        {
          "id": "aria-treeitem-name",
          "reason": "Tree structures require correct nesting of treeitem within tree and group roles — fix hierarchy and naming together."
        }
      ]
    },
    "aria-required-parent": {
      "fix": {
        "description": "Elements with certain ARIA roles must be nested inside a parent with a specific role. For example, role='listitem' must be inside role='list', and role='tab' must be inside role='tablist'.",
        "code": "<!-- role='listitem' must be inside role='list' -->\n<div role=\"list\">\n  <div role=\"listitem\">Item 1</div>\n  <div role=\"listitem\">Item 2</div>\n</div>\n\n<!-- role='tab' must be inside role='tablist' -->\n<div role=\"tablist\" aria-label=\"Account settings\">\n  <button role=\"tab\" aria-selected=\"true\">Profile</button>\n  <button role=\"tab\" aria-selected=\"false\">Security</button>\n</div>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, rendering role='listitem' elements via a component that does not render inside a role='list' parent is a common source. Ensure the parent component applies role='list' to its container. For Portalled content (e.g., menu items in a dropdown), the portal must render inside the role='menu' container, not at the body level.",
        "vue": "In Vue, Teleport can break required parent-child ARIA relationships by moving child content to a different DOM location. If teleporting role='menuitem' elements, ensure the Teleport target is inside the role='menu' parent.",
        "angular": "In Angular, CDK Overlay renders content at the body level — menu items in an overlay may lose their role='menu' parent. Use cdkConnectedOverlayOrigin or restructure so the overlay container has the required parent role."
      },
      "fix_difficulty_notes": "The fix is to ensure the DOM hierarchy matches the required ARIA role hierarchy. In SPAs, this is complicated by portals, overlays, and dynamic rendering that can detach child roles from their required parents. If restructuring the DOM is not feasible, aria-owns on the parent can establish the relationship regardless of DOM position — but this is a last resort and has inconsistent screen reader support.",
      "manual_test": {
        "description": "Verify the child element is announced within the context of its parent widget by a screen reader.",
        "steps": [
          "Navigate to the child element (e.g., a tab, listitem, or menuitem) with a screen reader.",
          "Confirm it is announced as part of its parent (e.g., 'tab, 1 of 3' or 'list item').",
          "If the child is announced without parent context, the required parent role is missing or the DOM hierarchy is broken."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-children",
          "reason": "Required parent and required children are complementary checks — fix both together to ensure complete ARIA relationships."
        },
        {
          "id": "aria-treeitem-name",
          "reason": "Each treeitem must be a child of a tree or group role — fix parent role requirements alongside naming."
        }
      ]
    },
    "aria-roledescription": {
      "fix": {
        "description": "The aria-roledescription attribute must only be used on elements that have an explicit or implicit ARIA role. It cannot be applied to elements with no role, or to elements with role='generic' (the implicit role of <div> and <span>).",
        "code": "<!-- Before: aria-roledescription on a generic div -->\n<div aria-roledescription=\"slide\">Slide content</div>\n<!-- After: add an appropriate role -->\n<div role=\"group\" aria-roledescription=\"slide\" aria-label=\"Slide 1 of 5\">\n  Slide content\n</div>\n\n<!-- Valid: aria-roledescription on an element with an implicit role -->\n<button aria-roledescription=\"toggle switch\">Dark mode</button>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, carousel or slider components often add aria-roledescription='slide' to plain <div> children. Add role='group' or role='region' to the div first, then apply aria-roledescription. Libraries like Embla Carousel may need a custom render function to inject the role.",
        "vue": "In Vue, ensure the element receiving aria-roledescription has an explicit role. Swiper.js and similar carousel libraries may apply aria-roledescription to wrapper <div> elements without adding a semantic role — override via slot props or custom wrappers.",
        "angular": "In Angular, bind [attr.aria-roledescription] only on elements that already have a role. If using a carousel CDK, ensure the slide container has role='group' or role='region' before applying the roledescription."
      },
      "fix_difficulty_notes": "aria-roledescription customizes the role announcement for screen readers (e.g., 'slide' instead of 'group'). It only works on elements that have a role in the accessibility tree. Elements with no role or role='generic' (implicit for <div>/<span>) are ignored by AT, so the roledescription has no effect. The fix: add an appropriate semantic role to the element before applying aria-roledescription.",
      "manual_test": {
        "description": "Navigate to the element with a screen reader and verify the custom role description is announced.",
        "steps": [
          "Focus or navigate to the element — the screen reader should announce the custom role description (e.g., 'slide' instead of 'group').",
          "If the custom description is not announced, the element likely lacks a semantic role.",
          "Verify the custom description is meaningful and not confusing (e.g., do not override 'button' with 'clicker')."
        ]
      }
    },
    "aria-roles": {
      "fix": {
        "description": "Replace invalid ARIA role values with valid roles from the WAI-ARIA specification, or remove the role attribute if it is not needed.",
        "code": "<!-- Invalid roles: -->\n<!-- role=\"text\" — not a valid ARIA role -->\n<!-- role=\"container\" — not a valid ARIA role -->\n<!-- role=\"button\" on a <button> — redundant, not a violation but unnecessary -->\n\n<!-- Valid replacements: -->\n<div role=\"region\" aria-labelledby=\"section-heading\">...</div>\n<span role=\"status\" aria-live=\"polite\">Saved successfully</span>\n<div role=\"alert\">Error: field is required</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, ARIA roles are passed as the role prop. Use eslint-plugin-jsx-a11y (aria-role rule) to catch invalid role values at build time — there is no runtime validation.",
        "vue": "In Vue, invalid role values are passed through to the DOM without validation. Use eslint-plugin-vuejs-accessibility to catch invalid role attributes in templates.",
        "angular": "In Angular, @angular-eslint includes aria-role lint rules. Enable them in .eslintrc to validate role attribute values at compile time."
      },
      "fix_difficulty_notes": "Common invalid roles: 'text' (not valid — use role='paragraph' or remove the role), 'input' (not valid — use native <input>), 'container' (not valid — use role='group'). Also watch for typos: 'dialouge' instead of 'dialog'. Adding a role that matches the element's implicit role (e.g., role='button' on <button>) is not a violation but is unnecessary — remove it for cleaner markup.",
      "manual_test": {
        "description": "Verify the corrected role is announced correctly by a screen reader.",
        "steps": [
          "Navigate to the element with VoiceOver or NVDA — the role must be announced (e.g., 'button', 'alert', 'region').",
          "If no role is announced or 'group' is announced unexpectedly, the role attribute may be invalid.",
          "Cross-reference the role value against https://www.w3.org/TR/wai-aria/#role_definitions."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "After fixing an invalid role, verify the replacement role has all required ARIA attributes."
        },
        {
          "id": "aria-prohibited-attr",
          "reason": "After fixing the role, verify no ARIA attributes are prohibited for the new role."
        },
        {
          "id": "aria-valid-attr-value",
          "reason": "After fixing the role, verify no ARIA attributes are prohibited for the new role."
        },
        {
          "id": "aria-allowed-attr",
          "reason": "An invalid role makes all attribute checks unreliable — fix the role first."
        },
        {
          "id": "aria-allowed-role",
          "reason": "aria-roles validates the role value itself; aria-allowed-role validates whether that role is appropriate for the host element."
        },
        {
          "id": "aria-deprecated-role",
          "reason": "Both rules validate role attribute values — fix all role violations together."
        }
      ]
    },
    "aria-text": {
      "fix": {
        "description": "Ensure role='text' is used only on elements with no focusable descendants. role='text' tells assistive technology to treat the element's content as a single text string — if focusable children exist inside, they become unreachable.",
        "code": "<!-- Valid: role='text' with no focusable descendants -->\n<p role=\"text\">\n  On sale: <span class=\"price\">$9.99</span>\n</p>\n\n<!-- Invalid: role='text' with a focusable link inside -->\n<!-- <p role=\"text\">Visit <a href=\"/store\">our store</a></p> -->\n\n<!-- Fix: remove role='text' when interactive children exist -->\n<p>Visit <a href=\"/store\">our store</a></p>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, role='text' is occasionally used on price or status components to prevent screen readers from splitting text across child spans. Ensure no <a>, <button>, or <input> elements exist inside the subtree. If interactive children are needed, remove role='text' and let the default content model apply.",
        "vue": "In Vue, avoid using role='text' on wrapper components that accept slots — slot content may include interactive elements injected by consuming components. Validate the slot content at the template level or remove role='text' entirely.",
        "angular": "In Angular, avoid role='text' on components with ng-content projections. Projected content may include interactive elements from parent templates, breaking the role='text' contract."
      },
      "fix_difficulty_notes": "role='text' is a convenience for preventing AT from splitting visually contiguous text into separate announcements (e.g., prices with styled currency symbols). It is not a WCAG requirement — if removing it causes no usability regression, removal is the safest fix. If role='text' is needed, audit all descendants to ensure none are focusable (no links, buttons, inputs, or elements with tabindex >= 0).",
      "manual_test": {
        "description": "Navigate the element with a screen reader and verify all content is accessible, including any interactive descendants.",
        "steps": [
          "With VoiceOver active, navigate to the element — confirm the entire text is read as a single phrase.",
          "Tab through the area — if any focusable child is unreachable, role='text' is hiding it.",
          "If interactive children exist, remove role='text' and verify each child is independently focusable and announced."
        ]
      }
    },
    "aria-toggle-field-name": {
      "fix": {
        "description": "Add an accessible name to toggle input fields (checkbox, radio, switch) via a <label>, aria-label, or aria-labelledby.",
        "code": "<!-- Checkbox with associated label: -->\n<label for=\"subscribe\">\n  <input type=\"checkbox\" id=\"subscribe\"> Subscribe to newsletter\n</label>\n\n<!-- Custom ARIA switch with aria-label: -->\n<button role=\"switch\" aria-checked=\"false\" aria-label=\"Enable dark mode\">\n  <span class=\"toggle-knob\" aria-hidden=\"true\"></span>\n</button>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, custom toggle components must spread aria-label and aria-checked to the underlying element. For native checkboxes, use htmlFor on <label>. For switches: <button role='switch' aria-checked={isOn} aria-label='Enable notifications'>.",
        "vue": "In Vue, custom toggle components must pass aria-label and aria-checked to the root element. For native checkboxes, use <label :for='id'> with matching :id on the <input>.",
        "angular": "In Angular, use <label [for]='checkboxId'> for native checkboxes. For custom switches, bind [attr.aria-label]='label' and [attr.aria-checked]='isChecked' on the role='switch' element."
      },
      "fix_difficulty_notes": "Custom toggle switches built with role='switch' require both aria-label AND aria-checked. Missing either triggers a violation. For checkbox inputs, a label must be associated via for/id or by wrapping — visually adjacent text without a <label> element is not sufficient for AT.",
      "manual_test": {
        "description": "Tab to each toggle and verify the screen reader announces both its name and current state.",
        "steps": [
          "Tab to the checkbox or toggle — the AT must announce the label and state (e.g., 'Subscribe to newsletter, unchecked').",
          "Toggle the control — the state change must be announced ('checked' / 'unchecked').",
          "For custom switches, confirm aria-checked is updated programmatically when the toggle state changes."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "The same label association pattern resolves both label and aria-toggle-field-name violations."
        },
        {
          "id": "aria-required-attr",
          "reason": "role='switch' requires aria-checked — fix the accessible name and required attributes together."
        },
        {
          "id": "aria-input-field-name",
          "reason": "Fix all ARIA field naming violations together — they share the same accessible name patterns."
        }
      ]
    },
    "aria-tooltip-name": {
      "fix": {
        "description": "Every element with role='tooltip' must have an accessible name via text content, aria-label, or aria-labelledby. Without a name, the tooltip is invisible to screen reader users.",
        "code": "<!-- Tooltip with text content (accessible name from content) -->\n<span role=\"tooltip\" id=\"password-hint\">\n  Password must be at least 8 characters\n</span>\n<input type=\"password\" aria-describedby=\"password-hint\">\n\n<!-- Tooltip with aria-label (for icon-based tooltips) -->\n<div role=\"tooltip\" aria-label=\"Copy to clipboard shortcut: Ctrl+C\">\n  <kbd>Ctrl</kbd>+<kbd>C</kbd>\n</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, tooltip libraries (Radix Tooltip, Floating UI, React Tooltip) manage role='tooltip' and accessible names internally. If building a custom tooltip, ensure the tooltip element has text content or aria-label, and the trigger element references it via aria-describedby.",
        "vue": "In Vue, Floating Vue (v-tooltip) and Headless UI manage tooltip semantics. For custom tooltips, bind role='tooltip' and ensure text content or :aria-label is present on the tooltip element.",
        "angular": "In Angular, Angular CDK Overlay with MatTooltip handles role='tooltip' and accessible naming. For custom tooltips, ensure the overlay element has role='tooltip' and contains text content or [attr.aria-label]."
      },
      "fix_difficulty_notes": "Tooltips should contain plain text that describes or supplements the trigger element. Complex interactive content inside a tooltip is an anti-pattern — use a dialog or popover instead. The tooltip's accessible name comes from its text content; aria-label is only needed when the tooltip contains non-text content (icons, formatted markup).",
      "manual_test": {
        "description": "Trigger the tooltip and verify a screen reader announces its content.",
        "steps": [
          "Focus the trigger element — the tooltip must appear and the screen reader should announce its content via aria-describedby.",
          "Verify the tooltip content matches the visual text shown.",
          "Press Escape — the tooltip must close and the screen reader should stop announcing it."
        ]
      }
    },
    "aria-treeitem-name": {
      "fix": {
        "description": "Ensure every element with role='treeitem' has an accessible name via its text content, aria-label, or aria-labelledby.",
        "code": "<!-- Treeitem with visible text content (preferred): -->\n<ul role=\"tree\" aria-label=\"File browser\">\n  <li role=\"treeitem\" aria-expanded=\"false\">\n    Documents\n    <ul role=\"group\">\n      <li role=\"treeitem\">Resume.pdf</li>\n      <li role=\"treeitem\">Cover letter.docx</li>\n    </ul>\n  </li>\n</ul>\n\n<!-- Treeitem with aria-label (when icon-only): -->\n<li role=\"treeitem\" aria-label=\"Inbox (3 unread)\">\n  <svg aria-hidden=\"true\">...</svg>\n</li>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, tree components (React Aria TreeView, MUI TreeView, Ant Design Tree) manage treeitem names from a data prop. Ensure the label or name field is never empty. For custom tree implementations, pass aria-label to icon-only tree items.",
        "vue": "In Vue, PrimeVue Tree and Vuetify Treeview derive treeitem names from the data model label field. Verify that all tree data nodes have a non-empty label. For custom trees, add aria-label to icon-only items.",
        "angular": "In Angular, Angular Material Tree (mat-tree-node) does not automatically set an accessible name — the template must include visible text or an aria-label. Use [attr.aria-label]='node.name' on mat-tree-node elements."
      },
      "fix_difficulty_notes": "Tree views are complex ARIA widgets requiring correct role hierarchy (tree > treeitem > group > treeitem), aria-expanded on parent nodes, and an accessible name on every treeitem. The most common violation is icon-only tree nodes (file browser icons, folder icons) missing aria-label. Add aria-label to every treeitem that lacks visible text content.",
      "manual_test": {
        "description": "Navigate the tree with a screen reader and verify every node is announced with a meaningful name.",
        "steps": [
          "With VoiceOver, navigate the tree using arrow keys — each treeitem must be announced by name.",
          "If a treeitem is announced only by role ('tree item') with no name, it needs aria-label or visible text.",
          "Expand/collapse parent nodes and confirm aria-expanded state changes are announced."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-children",
          "reason": "Tree structures require correct nesting of treeitem within tree and group roles — fix hierarchy and naming together."
        },
        {
          "id": "aria-required-parent",
          "reason": "Each treeitem must be a child of a tree or group role — fix parent role requirements alongside naming."
        }
      ]
    },
    "aria-valid-attr": {
      "fix": {
        "description": "All attributes beginning with aria- must be valid ARIA attribute names. Misspelled or invented aria-* attributes are ignored by assistive technologies.",
        "code": "<!-- Before: misspelled or invalid ARIA attributes -->\n<button aria-labelled=\"Save\">Save</button>  <!-- should be aria-label -->\n<div aria-role=\"alert\">Error</div>  <!-- aria-role is not valid; use role=\"alert\" -->\n\n<!-- After: corrected attributes -->\n<button aria-label=\"Save\">Save</button>\n<div role=\"alert\">Error</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "React does not validate aria-* attribute names at compile time — misspelled attributes pass through to the DOM silently. Use eslint-plugin-jsx-a11y which includes the aria-props rule to catch invalid attribute names. Common typos: aria-labelled (should be aria-label), aria-role (should be role).",
        "vue": "Vue does not validate aria-* attributes. Use eslint-plugin-vuejs-accessibility to catch misspelled ARIA attributes in templates. The most common mistake is aria-labelled instead of aria-label or aria-labelledby.",
        "angular": "Angular does not validate aria-* attributes at compile time. Enable @angular-eslint ARIA rules to detect invalid attribute names. TypeScript does not type-check HTML attribute strings, so aria-* typos pass through uncaught."
      },
      "fix_difficulty_notes": "This rule catches typos and invented attribute names. The fix is almost always correcting a misspelled attribute. Common mistakes: aria-labelled (should be aria-label or aria-labelledby), aria-role (not an ARIA attribute — use the role HTML attribute), aria-description (valid in ARIA 1.3 but not yet widely supported — use aria-describedby with a referenced element instead). Consult https://www.w3.org/TR/wai-aria/#state_prop_def for the complete list of valid aria-* attributes.",
      "manual_test": {
        "description": "Inspect the flagged element and verify all aria-* attributes are correctly spelled valid ARIA attributes.",
        "steps": [
          "Open DevTools and inspect the flagged element — identify any aria-* attribute not in the WAI-ARIA specification.",
          "Correct the attribute name (e.g., aria-labelled to aria-label) and verify with axe DevTools.",
          "Test with a screen reader to confirm the corrected attribute is now recognized and announced."
        ]
      },
      "related_rules": [
        {
          "id": "aria-valid-attr-value",
          "reason": "After fixing the attribute name, verify the value is also valid."
        }
      ]
    },
    "aria-valid-attr-value": {
      "fix": {
        "description": "Set a valid value for the ARIA attribute. Consult the WAI-ARIA spec for the list of allowed values.",
        "code": "<!-- Common invalid → valid corrections: -->\n\n<!-- aria-live: must be 'off' | 'polite' | 'assertive' -->\n<div aria-live=\"polite\">...</div>  <!-- not aria-live=\"yes\" -->\n\n<!-- aria-expanded: must be 'true' | 'false' -->\n<button aria-expanded=\"false\">Menu</button>  <!-- not aria-expanded=\"0\" -->\n\n<!-- aria-haspopup: must be 'true' | 'false' | 'menu' | 'listbox' | 'tree' | 'grid' | 'dialog' -->\n<button aria-haspopup=\"menu\">Options</button>  <!-- not aria-haspopup=\"dropdown\" -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "React coerces aria-expanded={isOpen} to the string 'true'/'false' correctly. Do not use aria-expanded={isOpen ? '1' : '0'} or other non-token values. Use aria-expanded={undefined} to omit the attribute entirely when the role does not require it.",
        "vue": "Use :aria-expanded='isOpen' — Vue renders boolean true/false as the strings 'true'/'false'. Do not use :aria-expanded='isOpen ? 1 : 0'. To omit the attribute, bind to null: :aria-expanded='null'.",
        "angular": "Use [attr.aria-expanded]='isOpen' binding — Angular renders the boolean as the correct string. Setting [attr.aria-expanded]='null' removes the attribute entirely when not applicable."
      },
      "fix_difficulty_notes": "The most common mistake is using incorrect types for boolean attributes: aria-expanded='0' or aria-expanded='yes' instead of 'true'/'false'. In template engines, ensure dynamic state is coerced to the string 'true' or 'false', not a JavaScript boolean. React spreads boolean props correctly — aria-expanded={isOpen} renders 'true'/'false' — but aria-expanded={isOpen ? 1 : 0} does not.",
      "manual_test": {
        "description": "Confirm the corrected attribute value is recognised by a screen reader.",
        "steps": [
          "Locate the element in DevTools — note the invalid attribute value flagged by axe.",
          "Update the value to a valid token per the WAI-ARIA spec.",
          "Interact with the element using VoiceOver or NVDA and confirm the state is announced correctly (e.g., 'expanded', 'collapsed')."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "Required attributes must be present before their values can be validated — fix both together."
        },
        {
          "id": "aria-roles",
          "reason": "An invalid role produces invalid attribute values — fix the role before the attribute values."
        },
        {
          "id": "aria-prohibited-attr",
          "reason": "After removing prohibited attrs, verify remaining attribute values are valid tokens."
        },
        {
          "id": "aria-conditional-attr",
          "reason": "After fixing the attribute choice, verify the value is a valid token."
        },
        {
          "id": "aria-valid-attr",
          "reason": "After fixing the attribute name, verify the value is also valid."
        }
      ]
    },
    "audio-caption": {
      "fix": {
        "description": "Add a <track kind='captions'> element inside every <audio> element, or provide a text transcript linked adjacent to the player.",
        "code": "<audio controls>\n  <source src=\"podcast.mp3\" type=\"audio/mpeg\">\n  <track kind=\"captions\" src=\"podcast.vtt\" srclang=\"en\" label=\"English captions\" default>\n</audio>\n\n<!-- Alternative: linked transcript -->\n<audio controls src=\"podcast.mp3\"></audio>\n<p><a href=\"podcast-transcript.html\">Read the full transcript</a></p>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, pass <track> as a child of the <audio> JSX element. React requires a key prop on <track> when rendered in a list. Use the default prop (boolean) to set the default caption track.",
        "vue": "In Vue, nest <track> inside <audio> in the template. For dynamic caption src, bind :src='captionsSrc'. The default boolean attribute is passed as a plain HTML attribute without binding.",
        "angular": "In Angular, the native <audio> element with nested <track> works in component templates. For dynamic caption URLs, use [attr.src]='captionsSrc' on the <track> element."
      },
      "fix_difficulty_notes": "Captions must be synchronized with the audio — a plain text page is a transcript, not captions. VTT (WebVTT) is the standard format for <track> elements and is supported in all modern browsers. Generating captions retroactively is effort-intensive; tools like Whisper (OpenAI), Adobe Premiere, or Rev.com can auto-generate VTT files that require human review before publishing.",
      "manual_test": {
        "description": "Play the audio content and verify captions or transcript accurately reflect all spoken content.",
        "steps": [
          "Play the audio with captions enabled — confirm every spoken word is captioned, including speaker identification if multiple speakers are present.",
          "If a transcript is provided instead of captions, verify it covers 100% of spoken content in readable order.",
          "Check that captions are synchronized — they must appear at the correct time, not delayed or early."
        ]
      },
      "related_rules": [
        {
          "id": "video-caption",
          "reason": "Both require media captions — fix all media accessibility violations together."
        }
      ]
    },
    "autocomplete-valid": {
      "fix": {
        "description": "Add a valid autocomplete token to form inputs to assist users with autofill.",
        "code": "<input type=\"email\" name=\"email\" autocomplete=\"email\">\n<input type=\"text\" name=\"name\" autocomplete=\"name\">\n<input type=\"tel\" name=\"phone\" autocomplete=\"tel\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Pass autocomplete as a string prop in JSX: <input autoComplete='email' />. Note: React uses camelCase autoComplete, which renders as the autocomplete HTML attribute. React Hook Form does not intercept it — set it directly on the input element.",
        "vue": "Use autocomplete='email' as a plain HTML attribute in Vue templates. Vee-Validate passes the autocomplete attribute through to the native input via v-bind on the field component.",
        "angular": "Use the autocomplete attribute in Angular Reactive Forms or Template-driven forms — Angular does not strip or override it. For Angular Material inputs, add autocomplete='email' to the <input> element inside <mat-form-field>."
      },
      "fix_difficulty_notes": "Acceptable autocomplete tokens are strictly defined by the HTML Living Standard. Custom or invented values (e.g., autocomplete='my-app-email') are invalid even if they help password managers. Use only the tokens listed at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute. Verify you are applying the token to the right field type — autocomplete='email' on a phone number field is invalid.",
      "manual_test": {
        "description": "Verify autofill populates the correct field type in a real browser.",
        "steps": [
          "Open the form in Chrome or Safari with autofill data saved.",
          "Trigger autofill (e.g., click the field or use Cmd+Shift+A in Chrome) — confirm the field receives the right data type.",
          "Check DevTools: the autocomplete attribute value must be a valid token from the WCAG 1.3.5 list."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "Properly labeled inputs should also have correct autocomplete tokens — fix label association and autocomplete together."
        }
      ]
    },
    "avoid-inline-spacing": {
      "fix": {
        "description": "Text spacing set via inline style attributes (letter-spacing, word-spacing, line-height) must be overridable by user stylesheets. Hard-coded inline styles with !important prevent users with low vision from adjusting text spacing (WCAG 1.4.12).",
        "code": "<!-- Before: inline spacing that cannot be overridden -->\n<p style=\"letter-spacing: 0.1em !important; line-height: 1.2 !important;\">Text content</p>\n\n<!-- After: move spacing to a stylesheet class (overridable by user CSS) -->\n<p class=\"body-text\">Text content</p>\n<!-- In CSS: -->\n<!-- .body-text { letter-spacing: 0.1em; line-height: 1.5; } -->"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, inline styles via the style prop (e.g., style={{ letterSpacing: '0.1em' }}) render as inline style attributes. Move these to CSS classes or CSS Modules. CSS-in-JS solutions (styled-components, Emotion) generate stylesheet rules that are overridable — they are preferable to inline styles for spacing properties.",
        "vue": "In Vue, :style bindings render as inline styles and have the same issue. Move letter-spacing, word-spacing, and line-height to <style scoped> classes. Scoped styles generate class-based selectors that user stylesheets can override.",
        "angular": "In Angular, [ngStyle] and [style.*] bindings render as inline styles. Move spacing properties to component stylesheets. Angular's ViewEncapsulation.Emulated generates scoped class selectors that are overridable by user CSS."
      },
      "fix_difficulty_notes": "Inline styles with !important on spacing properties are the primary trigger. Inline styles without !important are technically overridable but still flagged by axe as a risk. The safest fix: move all text spacing (letter-spacing, word-spacing, line-height) to stylesheet classes. CMS-generated content and WYSIWYG editors are common sources of inline spacing styles — sanitize the output to remove inline spacing declarations.",
      "manual_test": {
        "description": "Apply a custom user stylesheet that overrides text spacing and verify the content reflows correctly.",
        "steps": [
          "Install a text spacing bookmarklet or browser extension (e.g., the WCAG 1.4.12 text spacing bookmarklet).",
          "Activate it — all text should reflow with increased spacing without content being clipped or overlapping.",
          "If text is clipped, hidden, or overlaps after applying custom spacing, the inline styles are preventing the override."
        ]
      }
    },
    "blink": {
      "fix": {
        "description": "Remove all <blink> elements from the page. The <blink> element is deprecated in HTML and causes content to flash, which is inaccessible to users with cognitive disabilities and can trigger seizures in users with photosensitive epilepsy.",
        "code": "<!-- Before: blinking text -->\n<blink>Important announcement!</blink>\n\n<!-- After: use CSS animation with user preference respect -->\n<p class=\"announcement\">Important announcement!</p>\n<!-- In CSS: -->\n<!-- .announcement { animation: fade 2s ease-in-out; } -->\n<!-- @media (prefers-reduced-motion: reduce) { .announcement { animation: none; } } -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "The <blink> element is not a valid JSX element — React will render it as an unknown HTML tag. If encountered in legacy code, replace it with a styled <span> or <p>. If animation is needed, use CSS with prefers-reduced-motion support.",
        "vue": "In Vue, <blink> renders as an unknown HTML element. Replace with a standard element and CSS animation that respects prefers-reduced-motion.",
        "angular": "In Angular, <blink> is treated as an unknown element. Replace it with a standard element. If attention-grabbing styling is needed, use Angular animations with a prefers-reduced-motion media query check."
      },
      "fix_difficulty_notes": "This is extremely easy to fix — simply replace <blink> with a standard HTML element. The <blink> element is obsolete in the HTML spec and is not supported by any modern browser. If you encounter it, it is in legacy code that needs updating. No modern browser renders the blink effect, but the element is still flagged because it indicates outdated, inaccessible intent.",
      "manual_test": {
        "description": "Verify no content on the page blinks or flashes uncontrollably.",
        "steps": [
          "Search the page source for <blink> elements — there should be none.",
          "Visually inspect the page for any blinking content, including CSS animations that mimic blinking.",
          "If animations exist, enable 'Reduce motion' in OS settings and verify they stop."
        ]
      },
      "related_rules": [
        {
          "id": "marquee",
          "reason": "Both <blink> and <marquee> are deprecated elements that cause inaccessible animations — remove both together."
        }
      ]
    },
    "button-name": {
      "fix": {
        "description": "Give every button an accessible name via visible text or aria-label.",
        "code": "<!-- Via visible text: -->\n<button>Submit form</button>\n<!-- Icon button via aria-label: -->\n<button aria-label=\"Close dialog\"><svg aria-hidden=\"true\">...</svg></button>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use aria-label prop: <button aria-label=\"Close dialog\">. Prefer visible text children whenever possible.",
        "vue": "Use :aria-label or aria-label attribute — standard HTML semantics apply.",
        "angular": "Use [attr.aria-label] binding or the CDK a11y AccessibilityModule for managed focus."
      },
      "fix_difficulty_notes": "Using aria-label on a button with visible text creates a label mismatch — voice control users speak the visible text, not the aria-label. If visible text exists, keep it and remove aria-label. Only use aria-label for icon-only buttons with no visible text.",
      "manual_test": {
        "description": "Test button names using a screen reader or Inspect tools.",
        "steps": [
          "Tab to the button.",
          "Listen to the announced name; ensure it matches the button's action."
        ]
      },
      "related_rules": [
        {
          "id": "input-button-name",
          "reason": "The same accessible name requirement applies to <input type='button'/'submit'/'reset'> — fix all button naming violations together."
        },
        {
          "id": "link-name",
          "reason": "The same accessible name requirement applies to links — fix all interactive element naming together."
        },
        {
          "id": "aria-command-name",
          "reason": "button-name covers native <button> elements — fix all button naming violations together."
        }
      ]
    },
    "bypass": {
      "fix": {
        "description": "Add a skip link at the very top of each page so keyboard users can bypass repetitive navigation.",
        "code": "<a class=\"skip-link\" href=\"#main-content\">Skip to main content</a>\n<nav><!-- navigation --></nav>\n<main id=\"main-content\">\n  <!-- page content -->\n</main>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js, add the skip link as the first element in the root layout (app/layout.tsx), before the <header> or navigation components. Style it with CSS to appear only on :focus. The target #main-content must reference the <main id='main-content'> in the same layout.",
        "vue": "In Nuxt, add the skip link at the very top of layouts/default.vue, before the <header> component. The target #main-content must be on the <main> element wrapping <slot />.",
        "angular": "Add the skip link as the first element inside app.component.html, before <app-header> or navigation. The target #main-content must match the id on the <main> element rendered inside the page — typically adjacent to <router-outlet>."
      },
      "fix_difficulty_notes": "The skip link must be visible on focus — hiding it with display:none or visibility:hidden prevents keyboard users from seeing or activating it. The correct pattern is to position it off-screen by default (position:absolute; left:-9999px) and bring it on-screen on :focus (left:0; top:0). The target anchor (#main-content) must be a real element — if it's missing or the href is broken, the skip link appears to work but focus doesn't actually move.",
      "manual_test": {
        "description": "Verify the skip link is functional, not just present in the DOM.",
        "steps": [
          "Press Tab on page load — the first focusable element should be the skip link.",
          "Press Enter on the skip link — keyboard focus must move to the main content area.",
          "Confirm the skip link is visible when focused (not permanently hidden with display:none)."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "The skip link target (#main-content) must point to the <main> landmark."
        },
        {
          "id": "landmark-unique",
          "reason": "Unique landmark labels enhance skip navigation — users can jump directly to a specific landmark."
        },
        {
          "id": "skip-link",
          "reason": "Skip links are the primary mechanism for satisfying the bypass blocks requirement (WCAG 2.4.1)."
        }
      ]
    },
    "color-contrast": {
      "fix": {
        "description": "Increase the contrast ratio between text and its background. Minimum 4.5:1 for normal text, 3:1 for large text (≥18pt or ≥14pt bold).",
        "code": "/* Adjust the foreground or background color until contrast ≥4.5:1 */\n/* Use CSS custom properties to keep the fix systematic: */\n.element {\n  color: var(--color-text-primary); /* verify ≥4.5:1 against background */\n  background-color: var(--color-surface); /* e.g. #fff or #1e293b */\n}\n/* Tip: Check contrast at https://webaim.org/resources/contrastchecker/ */"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "In Tailwind (including shadcn/ui), verify that HSL CSS custom properties resolve to accessible values in both light and dark themes. CSS-in-JS libraries (styled-components, Emotion) compute colors at runtime — axe audits the computed value, not the source variable.",
        "vue": "In Vue with Tailwind or CSS Modules, verify contrast in the computed styles, not just the source CSS variables. Use DevTools color picker to confirm the rendered ratio.",
        "angular": "In Angular Material, override theme colors via mat.define-theme() using contrast-checked color pairs. Avoid raw CSS overrides that bypass the Angular Material theming system's built-in contrast checks."
      },
      "fix_difficulty_notes": "False positives are common on text rendered over gradient backgrounds, images, or when color is set dynamically via JavaScript or CSS variables resolved at runtime. axe-core samples a single point of the background — text on gradients may appear to fail even when contrast is sufficient. Verify each flagged instance visually using the browser DevTools color picker or https://webaim.org/resources/contrastchecker/ before fixing.",
      "manual_test": {
        "description": "Verify contrast in interactive states — axe only scans the static DOM.",
        "steps": [
          "Hover over links and buttons — check that text contrast remains ≥4.5:1 in the hover state.",
          "Focus interactive elements with Tab — verify the focused state maintains sufficient contrast.",
          "Check text rendered over images or gradients using the DevTools color picker."
        ]
      }
    },
    "consistent-help": {
      "fix": {
        "description": "Help mechanisms (support link, chat, contact info, self-help tool) must appear in the same relative order on every page where they appear (WCAG 3.2.6).",
        "code": "<!-- Place help in a consistent location across all pages (e.g., persistent header or footer): -->\n<header>\n  <nav aria-label=\"Support\">\n    <a href=\"/help\">Help centre</a>\n    <a href=\"/contact\">Contact support</a>\n  </nav>\n</header>"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "Place help mechanisms in the root layout component (e.g., app/layout.tsx in Next.js App Router, or App.jsx). Never put them in individual page components — they will appear/disappear per route, breaking consistency. In Next.js Pages Router, use _app.js.",
        "vue": "Add help mechanisms to the root layout (App.vue or layouts/default.vue in Nuxt). Avoid placing them in page-level components. In Nuxt, layouts/default.vue is the canonical location to guarantee consistent rendering across all routes.",
        "shopify": "Place help links in layout/theme.liquid or a persistent snippet included in every section. Never add them only to specific section templates — they will be absent on pages that don't render that section.",
        "wordpress": "Add help mechanisms to header.php or footer.php in the active theme. Avoid widget areas that may not appear on all page templates (e.g., some templates skip the sidebar)."
      },
      "fix_difficulty_notes": "Automated tools can only scan one page at a time and cannot compare help mechanism position across pages. axe findings for this rule are heuristic — they identify potential consistency issues but cannot confirm a violation without cross-page comparison. Manually verify across at least 3 page templates.",
      "manual_test": {
        "description": "Navigate between at least 3 different pages and verify help links appear in the same position.",
        "steps": [
          "Identify all help mechanisms on the homepage (e.g., chat widget, help link in footer).",
          "Visit 2 more pages and confirm the help mechanisms appear in the same order and position.",
          "If any page hides or repositions the help mechanism, it violates WCAG 3.2.6."
        ]
      }
    },
    "css-orientation-lock": {
      "fix": {
        "description": "Content must not be locked to a specific display orientation (portrait or landscape) unless a particular orientation is essential. Users with motor disabilities may mount their device in a fixed orientation (WCAG 1.3.4).",
        "code": "<!-- Avoid orientation-locking CSS like: -->\n<!-- @media (orientation: portrait) { body { transform: rotate(90deg); } } -->\n\n<!-- Instead, ensure content adapts to both orientations: -->\n<style>\n  .layout {\n    display: grid;\n    grid-template-columns: 1fr;\n  }\n  @media (orientation: landscape) {\n    .layout {\n      grid-template-columns: 1fr 1fr;\n    }\n  }\n</style>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React Native or PWAs, avoid using the Screen Orientation API to lock orientation programmatically (screen.orientation.lock('portrait')). In web.manifest, do not set 'orientation': 'portrait' unless the app genuinely requires it (e.g., a camera viewfinder). In Next.js or Remix, check the manifest.json if present.",
        "vue": "In Vue PWAs (e.g., with @vite-pwa/nuxt), check the manifest for orientation locking. Do not use CSS transforms to force rotation on orientation change — this locks the visual layout even though the device is in a different orientation.",
        "angular": "In Angular PWAs, check angular.json or manifest.webmanifest for the 'orientation' field. Remove it or set it to 'any'. Avoid using @media (orientation: portrait) with transforms that force landscape rendering."
      },
      "fix_difficulty_notes": "Orientation locking can come from three sources: (1) CSS @media (orientation) rules with transforms, (2) the web app manifest 'orientation' field, (3) JavaScript Screen Orientation API calls. The WCAG exception applies when a specific orientation is 'essential' — e.g., a piano keyboard app, a bank check scanning interface. Most web content does not qualify for this exception. axe detects CSS-based locking; manifest and JavaScript-based locking require manual checks.",
      "manual_test": {
        "description": "Rotate the device or viewport between portrait and landscape and verify content adapts.",
        "steps": [
          "Open the page on a mobile device or in responsive mode with DevTools.",
          "Rotate between portrait and landscape — content must not be clipped, hidden, or forcibly rotated.",
          "If the content appears rotated 90 degrees from the device orientation, it is locked and violates WCAG 1.3.4."
        ]
      }
    },
    "definition-list": {
      "fix": {
        "description": "Ensure <dl> elements contain only properly-ordered <dt> and <dd> elements (or wrapping <div> elements per HTML5). No other elements should be direct children of <dl>.",
        "code": "<!-- Correct structure -->\n<dl>\n  <dt>Term 1</dt>\n  <dd>Definition 1</dd>\n  <dt>Term 2</dt>\n  <dd>Definition 2</dd>\n</dl>\n\n<!-- Also valid: wrapping in <div> (HTML5) -->\n<dl>\n  <div>\n    <dt>Term 1</dt>\n    <dd>Definition 1</dd>\n  </div>\n  <div>\n    <dt>Term 2</dt>\n    <dd>Definition 2</dd>\n  </div>\n</dl>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, rendering a list of definition items via .map() may introduce wrapper <div> elements at the wrong level. Ensure the <div> wraps a <dt>/<dd> pair, not individual items. Use React.Fragment (<></>) only when the fragment renders as a child of <dl> directly — fragments do not produce DOM nodes.",
        "vue": "In Vue, v-for on <dl> children must produce <dt>/<dd> pairs or wrapping <div> elements. Use <template v-for> to loop without introducing extra wrapper elements at the wrong nesting level.",
        "angular": "In Angular, *ngFor on definition list items must produce valid <dt>/<dd> children. Use <ng-container> to loop without adding extra DOM elements between <dl> and its children."
      },
      "fix_difficulty_notes": "The most common violation: a <span>, <p>, or other element placed as a direct child of <dl>. Only <dt>, <dd>, and <div> (as a grouping wrapper) are valid direct children. In component frameworks, extra wrapper elements from component hosts can break the structure — use role='none' or host element elimination to fix.",
      "manual_test": {
        "description": "Verify the definition list is correctly structured and announced by a screen reader.",
        "steps": [
          "Navigate the <dl> with a screen reader — each <dt> should be announced as a 'term' and each <dd> as a 'definition'.",
          "Inspect the <dl> in DevTools — verify only <dt>, <dd>, and <div> are direct children.",
          "If extra elements are present, the screen reader may not associate terms with their definitions."
        ]
      },
      "related_rules": [
        {
          "id": "dlitem",
          "reason": "definition-list validates the parent; dlitem validates the children — fix both together."
        },
        {
          "id": "list",
          "reason": "Both validate list structures — audit all list semantics violations together."
        }
      ]
    },
    "dlitem": {
      "fix": {
        "description": "Ensure <dt> and <dd> elements are contained within a <dl> element. These elements have no semantic meaning outside of a definition list.",
        "code": "<!-- Before: orphaned dt/dd -->\n<dt>Name</dt>\n<dd>Jane Doe</dd>\n\n<!-- After: wrapped in dl -->\n<dl>\n  <dt>Name</dt>\n  <dd>Jane Doe</dd>\n</dl>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, a component rendering <dt> and <dd> elements must be placed inside a parent component rendering <dl>. If the component is reused outside a <dl> context, the dt/dd elements will be orphaned. Add a runtime check or documentation noting the required parent.",
        "vue": "In Vue, components rendering <dt>/<dd> must be used inside a <dl> wrapper. Vue does not validate HTML nesting — the orphaned dt/dd will render without error but fail accessibility audits.",
        "angular": "In Angular, components rendering <dt>/<dd> must be placed inside a <dl>. Angular host elements between <dl> and <dt>/<dd> break the relationship — use attribute selectors or role='none' on the host."
      },
      "fix_difficulty_notes": "The fix is straightforward: wrap orphaned <dt>/<dd> elements in a <dl>. In component frameworks, the issue often occurs when a definition list item component is rendered without its parent definition list component. Ensure the component API enforces the parent-child relationship.",
      "manual_test": {
        "description": "Verify all <dt> and <dd> elements are inside a <dl> parent.",
        "steps": [
          "Open DevTools and search for <dt> and <dd> elements — each must have a <dl> ancestor.",
          "Navigate the definition list with a screen reader — terms and definitions should be paired correctly.",
          "If <dt>/<dd> appear outside a <dl>, they will not be announced with their semantic roles."
        ]
      },
      "related_rules": [
        {
          "id": "definition-list",
          "reason": "dlitem validates children placement; definition-list validates parent structure — fix both together."
        }
      ]
    },
    "document-title": {
      "fix": {
        "description": "Add a descriptive, unique <title> element to every page.",
        "code": "<title>Product Details — My Store</title>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use document.title in a useEffect, or react-helmet for declarative title management. In Next.js, use <title> inside <Head> from 'next/head' — it is server-side rendered.",
        "vue": "Update document.title in vue-router's afterEach navigation guard, or use vue-meta / @vueuse/head for declarative management.",
        "angular": "Inject the Title service from @angular/platform-browser and call this.title.setTitle() inside route guards or component ngOnInit."
      },
      "fix_difficulty_notes": "In SPAs, the <title> is often set only on initial load. After client-side route changes, the title must be updated programmatically — the browser tab title stays stale otherwise. Each page title should follow the pattern 'Page Name — Site Name' so users understand context without reading page content.",
      "manual_test": {
        "description": "Verify the title is unique per page and describes the current content.",
        "steps": [
          "Navigate to at least 3 different pages and check the browser tab title each time.",
          "Confirm each title is different and reflects the specific page (not just the site name).",
          "For SPAs, confirm the title updates dynamically after route changes."
        ]
      }
    },
    "dragging-movements": {
      "fix": {
        "description": "All drag-and-drop functionality must have a single-pointer alternative (e.g., click-to-select then click-to-drop, or arrow buttons) for users who cannot perform drag gestures (WCAG 2.5.7).",
        "code": "<!-- Provide non-drag alternative with arrow buttons: -->\n<ul role=\"listbox\" aria-label=\"Sortable items\">\n  <li role=\"option\" tabindex=\"0\">\n    Item 1\n    <button aria-label=\"Move item up\">↑</button>\n    <button aria-label=\"Move item down\">↓</button>\n  </li>\n</ul>"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "Libraries like @dnd-kit/core provide keyboard-accessible drag-and-drop out of the box. react-beautiful-dnd also supports keyboard dragging. If using a custom drag implementation with mousedown/mousemove events, add keyboard event handlers (Arrow keys for movement, Space/Enter to confirm drop) as an accessible alternative.",
        "vue": "Vue Draggable (vuedraggable) and @vueuse/gesture may not include keyboard alternatives by default. Supplement drag interactions with arrow key handlers and explicit 'move up/down' buttons visible to all users.",
        "angular": "Angular CDK DragDrop (CdkDrag) does not provide keyboard drag-and-drop by default. Add a secondary keyboard interface (e.g., Up/Down arrow buttons) as the accessible alternative alongside the drag functionality."
      },
      "fix_difficulty_notes": "axe detects drag interactions heuristically based on event listeners — it may flag elements that listen to drag events but do not actually require dragging for their core function. Verify that the flagged element genuinely has drag-only functionality before implementing an alternative. WCAG 2.5.7 includes an exception when the dragging motion is 'essential' (e.g., a signature pad or freehand drawing tool).",
      "manual_test": {
        "description": "Verify the non-drag alternative completes the same task end-to-end.",
        "steps": [
          "Identify all drag interactions (sortable lists, file uploads, kanban boards).",
          "Complete the full task using only keyboard or single clicks — no drag gesture.",
          "Confirm the result is identical to what the drag interaction would produce."
        ]
      }
    },
    "duplicate-id": {
      "fix": {
        "description": "All id attributes must be unique within the page. Search for duplicate values and rename them.",
        "code": "<!-- Before: duplicate ids -->\n<nav id=\"main-nav\">...</nav>\n<footer id=\"main-nav\">...</footer>\n\n<!-- After: unique ids -->\n<nav id=\"primary-nav\">...</nav>\n<footer id=\"footer-nav\">...</footer>\n\n<!-- Update any referencing aria-labelledby / aria-controls / href=\"#\" accordingly -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use the useId() hook (React 18+) to generate unique IDs per component instance: const id = useId(); return <label htmlFor={id}>.",
        "vue": "Bind a unique key to IDs: <label :for=\"`field-${uid}`\"> where uid is a prop or generated value (e.g., Math.random().toString(36)).",
        "angular": "Inject a counter service or use the CDK's uniqueId utility to generate stable, unique IDs per component instance."
      },
      "fix_difficulty_notes": "In component-based frameworks, duplicate IDs typically occur when the same component renders multiple times on the same page. Use framework-native ID generation: useId() in React 18+, a unique :id binding per instance in Vue, or a service-based ID generator in Angular.",
      "manual_test": {
        "description": "Verify no duplicate id values exist, especially across dynamically rendered components.",
        "steps": [
          "Open DevTools Console and run: document.querySelectorAll('[id]') — look for repeated values.",
          "Paste: [...document.querySelectorAll('[id]')].filter((el, i, arr) => arr.findIndex(e => e.id === el.id) !== i) — non-empty result = duplicates.",
          "Check SPAs after route changes — ids may be duplicated when components re-render."
        ]
      },
      "related_rules": [
        {
          "id": "duplicate-id-aria",
          "reason": "Duplicate IDs break both element references and ARIA relationships — fix all ID uniqueness violations together."
        }
      ]
    },
    "duplicate-id-aria": {
      "fix": {
        "description": "Ensure all IDs referenced by ARIA attributes (aria-labelledby, aria-describedby, aria-controls, aria-owns) are unique. Duplicate IDs cause screen readers to reference the wrong element.",
        "code": "<!-- Before: duplicate IDs break aria-labelledby -->\n<span id=\"label\">Username</span>\n<input aria-labelledby=\"label\" type=\"text\">\n<!-- ...later on same page... -->\n<span id=\"label\">Email</span>  <!-- duplicate! -->\n\n<!-- After: unique IDs -->\n<span id=\"username-label\">Username</span>\n<input aria-labelledby=\"username-label\" type=\"text\">\n<span id=\"email-label\">Email</span>\n<input aria-labelledby=\"email-label\" type=\"email\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use React 18's useId() hook to generate unique IDs per component instance: const id = useId(); return <><span id={id}>Label</span><input aria-labelledby={id} /></>. Never hardcode IDs in components that render more than once.",
        "vue": "In Vue, generate a unique ID per instance using a composable: const id = `field-${Math.random().toString(36).slice(2)}`; or use the useId() utility from VueUse. Bind with :id='id' and :aria-labelledby='id'.",
        "angular": "In Angular, inject a counter service or use a module-level incrementing variable to generate stable unique IDs: private static idCounter = 0; readonly fieldId = `field-${++FieldComponent.idCounter}`;. Bind with [attr.id]='fieldId'."
      },
      "fix_difficulty_notes": "Unlike duplicate-id (which flags all duplicate IDs), this rule specifically targets IDs that are referenced by ARIA attributes — making it higher severity because the duplicate directly breaks an accessibility relationship. In component-based apps, this almost always occurs when the same component renders multiple times with a hardcoded ID in its template. Use framework ID generation utilities to ensure uniqueness per instance.",
      "manual_test": {
        "description": "Verify that ARIA-referenced IDs resolve to the correct element on the page.",
        "steps": [
          "In DevTools Console, run: document.querySelectorAll('[aria-labelledby],[aria-describedby],[aria-controls],[aria-owns]') and for each, verify the referenced ID is unique.",
          "With a screen reader, focus the flagged input or widget — the announced label must match the visible label text.",
          "If the component renders multiple times on the page (e.g., in a list), check that each instance references a different ID."
        ]
      },
      "related_rules": [
        {
          "id": "duplicate-id",
          "reason": "Duplicate IDs break both element references and ARIA relationships — fix all ID uniqueness violations together."
        }
      ]
    },
    "empty-heading": {
      "fix": {
        "description": "Add meaningful text content to the heading element, or remove it if it serves no structural purpose.",
        "code": "<!-- Before: empty heading -->\n<h2></h2>\n\n<!-- After: heading with content -->\n<h2>Section title</h2>\n\n<!-- Or remove entirely if structural-only -->\n<!-- Use CSS pseudo-content for decorative dividers instead -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, a heading with dynamic content like <h2>{title}</h2> renders an empty heading if title is undefined, null, or an empty string. Guard with: {title && <h2>{title}</h2>} or provide a fallback string.",
        "vue": "In Vue, <h2>{{ title }}</h2> renders an empty heading if title is falsy. Use a v-if guard: <h2 v-if='title'>{{ title }}</h2> or a computed fallback.",
        "angular": "In Angular, <h2>{{ title }}</h2> renders empty if title is undefined. Use *ngIf='title' on the heading element, or provide a default value in the component."
      },
      "fix_difficulty_notes": "Empty headings commonly occur in CMS-driven layouts where a heading tag is part of a section template but the author left the field blank. In component libraries, empty headings can also result from a conditional slot that renders nothing. Check both the template and the content source — the fix may be in the CMS content, not the code.",
      "manual_test": {
        "description": "Verify every heading has meaningful content that describes its section.",
        "steps": [
          "Open DevTools and run: document.querySelectorAll('h1,h2,h3,h4,h5,h6') — check each for empty innerText.",
          "Navigate the page with a screen reader using the heading shortcut (H in NVDA/JAWS) — empty headings will be announced as 'heading level X' with no label.",
          "Confirm each heading text accurately describes the content that follows it."
        ]
      },
      "related_rules": [
        {
          "id": "heading-order",
          "reason": "Empty headings disrupt the heading hierarchy — resolve them together."
        }
      ]
    },
    "empty-table-header": {
      "fix": {
        "description": "Ensure all <th> elements contain discernible text. Empty table headers provide no context for the column or row data they describe, making tables unintelligible to screen reader users.",
        "code": "<!-- Before: empty table header -->\n<table>\n  <tr>\n    <th></th>\n    <th>Q1</th>\n    <th>Q2</th>\n  </tr>\n  <tr>\n    <td>Revenue</td>\n    <td>$100k</td>\n    <td>$120k</td>\n  </tr>\n</table>\n\n<!-- After: add descriptive text or use <td> for non-header cells -->\n<table>\n  <tr>\n    <th>Metric</th>\n    <th>Q1</th>\n    <th>Q2</th>\n  </tr>\n  <tr>\n    <th scope=\"row\">Revenue</th>\n    <td>$100k</td>\n    <td>$120k</td>\n  </tr>\n</table>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React table components, ensure the header row maps over column definitions that always include a non-empty label. If a column is for checkboxes or actions, add a visually hidden label: <th><span className='sr-only'>Select</span></th>.",
        "vue": "In Vue, data table components (PrimeVue DataTable, Vuetify v-data-table) auto-generate headers from column definitions. Verify the header/text field is defined for every column, including selection or action columns.",
        "angular": "In Angular Material mat-table, mat-header-cell content is template-driven. Add visible or visually hidden text to every <th mat-header-cell> — do not leave any header cell empty."
      },
      "fix_difficulty_notes": "The most common case is a checkbox column or an actions column with an empty <th>. The fix is to add a visually hidden label (e.g., 'Select all' for checkboxes, 'Actions' for action columns) so screen readers can announce the column purpose. If the <th> genuinely has no header role, change it to a <td> instead.",
      "manual_test": {
        "description": "Navigate the table with a screen reader and verify every column and row header is announced.",
        "steps": [
          "In NVDA, use Ctrl+Alt+Arrow keys to navigate table cells — each cell must announce its column header.",
          "If a column header is silent (no announcement before the cell value), the <th> is empty.",
          "Inspect the table in DevTools and confirm no <th> element has empty or whitespace-only text content."
        ]
      },
      "related_rules": [
        {
          "id": "th-has-data-cells",
          "reason": "Headers without text and headers without associated data cells are related structural issues — fix together."
        },
        {
          "id": "td-headers-attr",
          "reason": "The headers attribute references <th> elements by id — empty headers make these references meaningless."
        },
        {
          "id": "scope-attr-valid",
          "reason": "Scope on an empty <th> is meaningless — ensure headers have text content before adding scope."
        }
      ]
    },
    "focus-appearance": {
      "fix": {
        "description": "The focus indicator must cover a minimum area (perimeter × 2 CSS px) and maintain a 3:1 contrast ratio between focused and unfocused states (WCAG 2.4.11).",
        "code": ":focus-visible {\n  outline: 3px solid #005FCC;\n  outline-offset: 2px;\n  /* Ensure contrast ratio ≥ 3:1 vs adjacent background */\n}\n\n/* Remove browser default only when providing a custom style */\n:focus:not(:focus-visible) {\n  outline: none;\n}"
      },
      "false_positive_risk": "high",
      "fix_difficulty_notes": "outline:none does not necessarily mean no focus indicator — a visible box-shadow, background-color change, or border change can fully satisfy WCAG 2.4.11. axe may flag outline:none even when a compliant custom indicator is present. Verify visually that a focus indicator exists before applying a fix. When suppressing the outline, always provide a replacement via box-shadow or border.",
      "manual_test": {
        "description": "Tab through every interactive element and verify the focus indicator is visible and distinct.",
        "steps": [
          "Press Tab repeatedly and confirm every button, link, and input shows a visible focus ring.",
          "Check that the focus indicator contrasts at least 3:1 against the adjacent unfocused background.",
          "Verify the outline is not clipped by overflow:hidden on a parent container."
        ]
      }
    },
    "focus-order-semantics": {
      "fix": {
        "description": "Ensure elements in the focus order have an appropriate role for interactive content. Non-interactive elements (e.g., <div>, <span>, <p>) with tabindex='0' should use a semantic interactive element or an appropriate ARIA role.",
        "code": "<!-- Before: non-interactive element in the focus order -->\n<div tabindex=\"0\">Click to expand</div>\n\n<!-- After: use a semantic element -->\n<button type=\"button\">Click to expand</button>\n\n<!-- Or add an appropriate ARIA role if a native element is not viable -->\n<div role=\"button\" tabindex=\"0\" aria-expanded=\"false\">\n  Click to expand\n</div>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, custom interactive components often use <div tabIndex={0} onClick={handler}> — replace with <button> or add role='button' with onKeyDown handling for Enter and Space. Libraries like React Aria's useButton hook handle this automatically.",
        "vue": "In Vue, replace <div tabindex='0' @click='handler'> with <button @click='handler'>. If a custom element is required, add role='button' and handle keydown events for Enter (13) and Space (32).",
        "angular": "In Angular, replace <div tabindex='0' (click)='handler()'> with <button (click)='handler()'>. Angular CDK's CdkAriaLive and A11yModule provide utilities for making custom elements properly interactive."
      },
      "fix_difficulty_notes": "Adding tabindex='0' to a non-interactive element makes it focusable but does not make it operable — keyboard users cannot activate it with Enter or Space unless explicit keydown handlers are added. The simplest fix is to use a native interactive element (<button>, <a>, <input>). If a custom element is required, add the correct ARIA role plus full keyboard event handling.",
      "manual_test": {
        "description": "Tab to the element and verify it is both focusable and operable, with an appropriate role announced by AT.",
        "steps": [
          "Tab to the flagged element — it must receive visible focus.",
          "Press Enter and Space — the element must respond to at least one of these keys.",
          "With a screen reader active, verify the element is announced with an interactive role (button, link, etc.), not just 'text' or 'group'."
        ]
      },
      "related_rules": [
        {
          "id": "tabindex",
          "reason": "Both rules address focus order issues — fix tabindex values and semantic roles together."
        },
        {
          "id": "scrollable-region-focusable",
          "reason": "Scrollable regions may need tabindex='0' for keyboard access but also need an appropriate role."
        }
      ]
    },
    "form-field-multiple-labels": {
      "fix": {
        "description": "Each form field must have exactly one associated <label>. Remove duplicate labels.",
        "code": "<!-- One label per input: -->\n<label for=\"name\">Full name</label>\n<input id=\"name\" type=\"text\" name=\"name\">"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, multiple labeling sources are introduced accidentally when a component applies both htmlFor on a <label> and aria-label on the input itself. Choose exactly one labeling strategy per input — prefer a visible <label htmlFor='id'> and remove aria-label.",
        "vue": "In Vue form component wrappers, ensure the component does not add internal aria-labels that conflict with a parent <label>. A common issue is a UI kit that adds aria-label='Input field' to every input by default — override this with an empty string or use the component's label prop instead.",
        "angular": "In Angular Material, mat-label inside mat-form-field serves as the accessible label. Do not also add aria-label directly to the input — both will be announced, triggering this violation."
      },
      "fix_difficulty_notes": "aria-labelledby can legitimately reference multiple IDs to concatenate a compound label (e.g., aria-labelledby='label1 label2'). axe may flag this pattern. Review whether both sources are intentional — if so, it is valid and the finding is a false positive. Remove one reference only if the concatenated announcement is redundant.",
      "manual_test": {
        "description": "Confirm a screen reader announces exactly one label when focused on the input.",
        "steps": [
          "Tab to the flagged input with VoiceOver or NVDA active.",
          "Listen to the announcement — it should state one name, not two concatenated labels.",
          "In DevTools Accessibility panel, check the 'Name' field — it should contain a single, clean label."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "Multiple labels on an input conflict with the single-label association requirement — fix both together."
        },
        {
          "id": "label-content-name-mismatch",
          "reason": "Multiple labels often cause the accessible name to diverge from visible text."
        },
        {
          "id": "label-title-only",
          "reason": "When adding a visible label, verify you are not creating a duplicate label association."
        }
      ]
    },
    "frame-focusable-content": {
      "fix": {
        "description": "Do not set tabindex='-1' on <iframe> or <frame> elements that contain focusable content. This prevents keyboard users from accessing the content inside the frame.",
        "code": "<!-- Before: iframe with focusable content blocked -->\n<iframe src=\"form.html\" tabindex=\"-1\" title=\"Registration form\"></iframe>\n\n<!-- After: remove tabindex=-1 so keyboard users can access the content -->\n<iframe src=\"form.html\" title=\"Registration form\"></iframe>\n\n<!-- If the iframe is decorative with no interactive content, tabindex=-1 is acceptable -->\n<iframe src=\"animation.html\" tabindex=\"-1\" title=\"Decorative animation\" aria-hidden=\"true\"></iframe>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, third-party embed components (e.g., YouTube, maps, payment forms) sometimes add tabindex='-1' to the iframe. Override by removing the tabindex prop or setting it to 0. If the embed library does not expose a tabindex prop, wrap the iframe and use a ref to remove the attribute after mount.",
        "vue": "In Vue, check embedded iframe components for tabindex='-1'. Use a mounted hook to remove tabindex from the iframe element if the component does not expose it as a prop.",
        "angular": "In Angular, check [tabindex] bindings on iframe elements. If using a third-party embed directive, override the tabindex via a host binding or AfterViewInit lifecycle hook."
      },
      "fix_difficulty_notes": "tabindex='-1' on an iframe removes it from the sequential tab order but also prevents keyboard users from tabbing into the iframe's content. If the iframe contains any interactive content (forms, links, buttons), removing tabindex='-1' is the correct fix. If the iframe is purely decorative or contains no interactive content, tabindex='-1' combined with aria-hidden='true' is acceptable.",
      "manual_test": {
        "description": "Tab into the iframe and verify keyboard users can reach all interactive content inside it.",
        "steps": [
          "Press Tab repeatedly — focus must enter the iframe and reach any interactive elements inside it (buttons, links, inputs).",
          "If focus skips over the iframe entirely, tabindex='-1' is likely preventing access.",
          "After removing tabindex='-1', verify you can tab through all content inside the iframe."
        ]
      },
      "related_rules": [
        {
          "id": "frame-title",
          "reason": "Iframes must be both keyboard-accessible and labeled — fix both together."
        }
      ]
    },
    "frame-tested": {
      "fix": {
        "description": "Ensure <iframe> and <frame> elements contain the axe-core script for complete accessibility testing. This is a testing infrastructure rule — it informs you that content inside frames was not analyzed because axe-core was not injected into them.",
        "code": "<!-- This is not an HTML fix — it is a testing configuration issue. -->\n<!-- Ensure your axe-core test runner is configured to test iframes: -->\n\n<!-- axe-core configuration: -->\n<!-- axe.run({ iframes: true }) -->\n\n<!-- For cross-origin iframes, axe-core cannot inject automatically. -->\n<!-- Load axe-core inside the iframe's own page: -->\n<iframe src=\"https://third-party.com/widget\" title=\"Chat widget\"></iframe>\n<!-- Inside the iframe page, include: -->\n<!-- <script src=\"axe-core/axe.min.js\"></script> -->"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "In React apps using @axe-core/react, iframe testing is limited to same-origin frames. For cross-origin iframes (payment forms, chat widgets, embedded maps), document them as out-of-scope and ensure the third-party provider meets WCAG compliance independently.",
        "vue": "In Vue apps using vue-axe or axe-core/puppeteer, enable the iframes option in axe configuration. Cross-origin iframes cannot be tested — request a VPAT or accessibility statement from the third-party provider.",
        "angular": "In Angular apps using axe-core with Protractor or Cypress, configure runOnly with iframes: true for same-origin frames. Cross-origin iframes require separate testing arrangements with the frame content provider."
      },
      "fix_difficulty_notes": "This rule is informational — it means axe-core could not analyze content inside an iframe. Same-origin iframes can be tested by enabling the iframes option in axe configuration. Cross-origin iframes (third-party widgets, payment forms) cannot be injected with axe-core — they must be tested separately by the content provider. Do not treat this as an accessibility violation; treat it as a gap in test coverage.",
      "manual_test": {
        "description": "Manually test the iframe content for accessibility if axe-core could not analyze it automatically.",
        "steps": [
          "Open the iframe URL directly in a new browser tab.",
          "Run axe-core or another accessibility scanner on the iframe content in isolation.",
          "Tab through the iframe content from within the parent page and verify all interactive elements are reachable and operable."
        ]
      },
      "related_rules": [
        {
          "id": "frame-title",
          "reason": "Every iframe needs a title attribute regardless of whether its content can be tested — fix frame titles alongside test coverage gaps."
        }
      ]
    },
    "frame-title": {
      "fix": {
        "description": "Add a descriptive title attribute to every <iframe>.",
        "code": "<iframe\n  title=\"Embedded map showing our store location\"\n  src=\"https://maps.example.com/embed\"\n></iframe>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "When embedding iframes (Google Maps, YouTube, Stripe), add the title prop directly: <iframe title='Google Maps — store location' src='...' />. Third-party React wrapper components that embed iframes should expose a title prop passthrough.",
        "vue": "Use the title attribute directly: <iframe title='Payment form' :src='url' />. For third-party Vue components that embed iframes internally, check the component's props API for a title or label prop.",
        "angular": "Use [title]='iframeTitle' binding for dynamic titles, or title='Embedded video' for static ones. For hidden tracking iframes generated by third-party scripts, set title='' programmatically to suppress screen reader announcement."
      },
      "fix_difficulty_notes": "Hidden or off-screen iframes used for third-party scripts (analytics, chat SDKs, A/B testing) should use title='' (empty) to suppress screen reader announcement — not a descriptive title. Only visible, interactive iframes that users would encounter need a meaningful title.",
      "manual_test": {
        "description": "Tab into the iframe area and verify the screen reader announces its title.",
        "steps": [
          "Tab to the iframe — the screen reader must announce 'frame' and the title content.",
          "Confirm the title describes the frame's purpose (e.g., 'Google Maps — Store Location'), not a generic label ('iframe').",
          "For hidden or off-screen iframes (e.g., third-party scripts), add title=\"\" to suppress SR announcement."
        ]
      },
      "related_rules": [
        {
          "id": "frame-focusable-content",
          "reason": "Iframes must be both keyboard-accessible and labeled — fix both together."
        },
        {
          "id": "frame-tested",
          "reason": "Every iframe needs a title attribute regardless of whether its content can be tested — fix frame titles alongside test coverage gaps."
        },
        {
          "id": "frame-title-unique",
          "reason": "frame-title checks for the presence of a title; frame-title-unique checks for uniqueness — fix both together."
        }
      ]
    },
    "frame-title-unique": {
      "fix": {
        "description": "Every <iframe> and <frame> must have a unique title attribute that distinguishes it from other frames on the same page. Duplicate titles confuse screen reader users navigating between frames.",
        "code": "<!-- Before: duplicate iframe titles -->\n<iframe src=\"ad1.html\" title=\"Advertisement\"></iframe>\n<iframe src=\"ad2.html\" title=\"Advertisement\"></iframe>\n\n<!-- After: unique titles -->\n<iframe src=\"ad1.html\" title=\"Advertisement: Summer sale banner\"></iframe>\n<iframe src=\"ad2.html\" title=\"Advertisement: Free shipping promo\"></iframe>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, when rendering multiple iframes via .map(), include a unique identifier in the title prop (e.g., title={`Widget ${index + 1}`} or title={widget.name}). Avoid generic titles like 'iframe' or 'widget' repeated across instances.",
        "vue": "In Vue, bind :title with unique descriptive text for each iframe rendered via v-for. Use the item's name or purpose in the title, not just a generic label.",
        "angular": "In Angular, use [title]='uniqueFrameTitle' with a descriptive string per iframe instance. When rendering multiple iframes via *ngFor, include the item's identifier in the title."
      },
      "fix_difficulty_notes": "The title must describe the purpose or content of the frame, not just its type. 'Advertisement' is valid for one ad iframe but becomes ambiguous when multiple ad iframes exist. Append a distinguishing qualifier (e.g., the ad campaign name, position, or content summary). For dynamically generated iframes (e.g., ad slots), the title should reflect the loaded content when possible.",
      "manual_test": {
        "description": "Navigate between iframes with a screen reader and verify each is announced with a unique, descriptive title.",
        "steps": [
          "Use the screen reader's frame navigation shortcut (e.g., 'M' in NVDA) to list all frames on the page.",
          "Verify each frame has a unique title that distinguishes it from others.",
          "If two frames have the same title, the screen reader user cannot distinguish between them."
        ]
      },
      "related_rules": [
        {
          "id": "frame-title",
          "reason": "frame-title checks for the presence of a title; frame-title-unique checks for uniqueness — fix both together."
        }
      ]
    },
    "heading-order": {
      "fix": {
        "description": "Fix the heading hierarchy — no levels may be skipped.",
        "code": "<h1>Page title</h1>\n<h2>Section heading</h2>\n<h3>Subsection heading</h3>\n<!-- Invalid: jumping from h1 to h3 -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In component libraries (shadcn/ui, Radix), heading levels are often hardcoded (e.g., CardTitle always renders as h3). Use the 'as' prop to override the level based on context: <CardTitle as='h2'> when the component appears as a top-level section heading.",
        "vue": "In Vue UI kits (Vuetify, Nuxt UI), check if heading components support a 'tag' prop to override the rendered element. Use semantic levels based on document structure, not visual size.",
        "angular": "In Angular Material, headings inside mat-card and mat-expansion-panel are often rendered as <div> or <span>. Add the appropriate heading element explicitly inside the component template rather than relying on implicit heading structure."
      },
      "fix_difficulty_notes": "Never use heading elements purely for visual sizing (e.g., using <h4> because it renders smaller). Use CSS classes for font size. The heading level must reflect document structure, not visual hierarchy. Resolve page-has-heading-one first — a missing h1 often causes cascading heading-order violations.",
      "manual_test": {
        "description": "Verify headings describe their sections meaningfully, not just maintain numeric order.",
        "steps": [
          "Read only the heading text in sequence — do they form a logical outline of the page?",
          "Check that no heading is used purely for visual sizing (e.g. an h3 that is not a subsection of the h2 above it).",
          "Use the browser Accessibility Tree or a headings extension to review the full outline."
        ]
      },
      "related_rules": [
        {
          "id": "page-has-heading-one",
          "reason": "Fixing the h1 establishes the root of the hierarchy — resolve it first."
        },
        {
          "id": "empty-heading",
          "reason": "Empty headings disrupt the heading hierarchy — resolve them together."
        },
        {
          "id": "p-as-heading",
          "reason": "After converting p-as-heading to real headings, verify they fit the existing heading hierarchy."
        }
      ]
    },
    "hidden-content": {
      "fix": {
        "description": "Inform users about hidden content that was not evaluated by the accessibility scanner. Content hidden via display:none, visibility:hidden, or the hidden attribute is excluded from the accessibility tree and from automated testing — it may contain violations that surface only when revealed.",
        "code": "<!-- Hidden content that axe cannot evaluate: -->\n<div id=\"modal\" hidden>\n  <h2>Login</h2>\n  <form>...</form>\n</div>\n\n<!-- When revealed, it must be accessible: -->\n<div id=\"modal\" role=\"dialog\" aria-labelledby=\"modal-title\" aria-modal=\"true\">\n  <h2 id=\"modal-title\">Login</h2>\n  <form>\n    <label for=\"email\">Email</label>\n    <input type=\"email\" id=\"email\" autocomplete=\"email\">\n  </form>\n</div>"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "In React, conditionally rendered content ({showModal && <Modal />}) is not in the DOM until rendered — axe cannot test it. Test each UI state separately: run axe after opening modals, expanding accordions, and triggering dropdowns.",
        "vue": "In Vue, v-if removes content from the DOM entirely, so axe cannot evaluate it. Use v-show for content that should be testable in all states, or run separate axe scans with each visibility state toggled on.",
        "angular": "In Angular, *ngIf removes content from the DOM. Run axe-core scans after triggering each UI state (dialog open, dropdown expanded, tab panel visible) to ensure hidden content is covered."
      },
      "fix_difficulty_notes": "This rule is informational, not a violation. It alerts you that some page content was hidden during the scan and therefore not tested. The fix is not to change the hidden content itself, but to ensure your test suite evaluates every visibility state. Run accessibility scans on all interactive states: modals open, accordions expanded, menus visible, toast notifications active.",
      "manual_test": {
        "description": "Identify all hidden content on the page and manually test it in its visible state.",
        "steps": [
          "In DevTools, search for elements with display:none, visibility:hidden, or the hidden attribute.",
          "Trigger each hidden element to become visible (open modal, expand accordion, etc.).",
          "Run an accessibility scan in each visible state to catch violations that were previously hidden."
        ]
      }
    },
    "html-has-lang": {
      "fix": {
        "description": "Add a lang attribute to the <html> element so screen readers pronounce content correctly.",
        "code": "<html lang=\"en\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js App Router, set lang in the root layout: export default function RootLayout() { return <html lang='en'>...</html>; } in app/layout.tsx. For i18n, derive the lang from the locale route segment.",
        "vue": "In Nuxt, set lang in nuxt.config.ts: app: { head: { htmlAttrs: { lang: 'en' } } }. For multilingual Nuxt apps, @nuxtjs/i18n sets the lang attribute per locale automatically.",
        "angular": "In Angular, set lang in index.html: <html lang='en'>. With Angular Universal (SSR), inject LOCALE_ID and set document.documentElement.lang in a server-side app initializer to support locale-specific rendering."
      },
      "fix_difficulty_notes": "The lang attribute must be on the <html> element itself, not on a meta tag or the <body>. In framework app templates, the <html> tag is typically in an index.html or document template file outside of component scope — not in a React/Vue/Angular component. For multilingual SPAs, update document.documentElement.lang programmatically on each route change to reflect the current content language.",
      "manual_test": {
        "description": "Confirm a screen reader switches to the correct language voice when reading the page.",
        "steps": [
          "Enable VoiceOver or NVDA with multiple language voices installed.",
          "Navigate to the page — the screen reader must use the declared language voice.",
          "If content is bilingual, verify elements with lang overrides on child elements are also announced in the correct language."
        ]
      },
      "related_rules": [
        {
          "id": "html-lang-valid",
          "reason": "Adding a lang attribute must use a valid BCP 47 language tag — fix both together."
        },
        {
          "id": "valid-lang",
          "reason": "Child elements with lang attributes must also use valid tags — audit all lang values at once."
        },
        {
          "id": "html-xml-lang-mismatch",
          "reason": "The lang attribute must be present before validating its agreement with xml:lang."
        }
      ]
    },
    "html-lang-valid": {
      "fix": {
        "description": "Use a valid BCP 47 language tag on the <html> element.",
        "code": "<!-- English -->\n<html lang=\"en\">\n<!-- French Canadian -->\n<html lang=\"fr-CA\">\n<!-- Brazilian Portuguese -->\n<html lang=\"pt-BR\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Same fix location as html-has-lang — set lang in app/layout.tsx: <html lang='en-US'>. Ensure the value is a valid BCP 47 tag, not a locale string from your i18n library (e.g., 'en_US' with underscore is invalid).",
        "vue": "Same as html-has-lang — set in nuxt.config.ts htmlAttrs or in the HTML template. Verify the value against the BCP 47 registry before deploying.",
        "angular": "Same as html-has-lang — set in index.html or via Angular Universal's locale injection. Confirm the value uses hyphen separators (en-US), not underscore (en_US)."
      },
      "fix_difficulty_notes": "Common mistakes: using underscore separator ('en_US') instead of hyphen ('en-US'), or spelling out the full language name ('english') instead of the BCP 47 subtag ('en'). Verify against https://www.iana.org/assignments/language-subtag-registry/.",
      "manual_test": {
        "description": "Verify the lang value is a recognised BCP 47 tag.",
        "steps": [
          "Inspect the <html> element in DevTools — read the lang attribute.",
          "Cross-check against the IANA Language Subtag Registry (https://www.iana.org/assignments/language-subtag-registry/).",
          "Common mistakes: 'en_US' (underscore) instead of 'en-US' (hyphen), or 'english' (full word) instead of 'en'."
        ]
      },
      "related_rules": [
        {
          "id": "html-has-lang",
          "reason": "html-has-lang and html-lang-valid are often co-located — fix the lang attribute once to resolve both."
        },
        {
          "id": "valid-lang",
          "reason": "The same BCP 47 validity requirement applies to lang attributes on child elements."
        },
        {
          "id": "html-xml-lang-mismatch",
          "reason": "Both lang and xml:lang must contain valid BCP 47 language tags."
        }
      ]
    },
    "html-xml-lang-mismatch": {
      "fix": {
        "description": "When both lang and xml:lang attributes are present on the <html> element, they must specify the same base language. A mismatch confuses assistive technologies about the page language.",
        "code": "<!-- Before: mismatched language attributes -->\n<html lang=\"en\" xml:lang=\"fr\">\n\n<!-- After: matching language attributes -->\n<html lang=\"en\" xml:lang=\"en\">\n\n<!-- Best: remove xml:lang unless serving XHTML -->\n<html lang=\"en\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js, the lang attribute is set in next.config.js (i18n.defaultLocale) or in the root layout. xml:lang is only needed for XHTML — remove it in standard HTML5. If both exist, ensure they match the same locale.",
        "vue": "In Nuxt, set the lang attribute in nuxt.config.ts (app.head.htmlAttrs.lang). Do not add xml:lang unless serving XHTML content type. If both are present, ensure they agree on the base language.",
        "angular": "In Angular, set the lang attribute in index.html on the <html> element. Remove xml:lang unless the app is served as application/xhtml+xml. If both are needed, ensure they specify the same language."
      },
      "fix_difficulty_notes": "The simplest fix is to remove xml:lang — it is only required for XHTML served with an XML content type. Modern HTML5 documents should use only the lang attribute. If your CMS or framework generates both attributes, ensure the template or configuration sets them to the same value. The 'base language' comparison ignores subtags (e.g., 'en-US' and 'en-GB' have the same base language 'en').",
      "manual_test": {
        "description": "Inspect the <html> element and verify the lang and xml:lang attributes agree.",
        "steps": [
          "Open DevTools and inspect the <html> element — check both lang and xml:lang values.",
          "If both are present, verify they specify the same base language (e.g., both start with 'en' or both start with 'fr').",
          "Ideally, remove xml:lang entirely unless the page is served as XHTML."
        ]
      },
      "related_rules": [
        {
          "id": "html-has-lang",
          "reason": "The lang attribute must be present before validating its agreement with xml:lang."
        },
        {
          "id": "html-lang-valid",
          "reason": "Both lang and xml:lang must contain valid BCP 47 language tags."
        }
      ]
    },
    "identical-links-same-purpose": {
      "fix": {
        "description": "Ensure links with identical visible text lead to the same destination, or differentiate them with unique text or aria-label to clarify their distinct purposes.",
        "code": "<!-- Before: two 'Read more' links with different destinations -->\n<a href=\"/article-1\">Read more</a>\n<a href=\"/article-2\">Read more</a>\n\n<!-- After: descriptive link text -->\n<a href=\"/article-1\">Read more about accessibility</a>\n<a href=\"/article-2\">Read more about inclusive design</a>\n\n<!-- Or: extend with aria-label (preserves visual design) -->\n<a href=\"/article-1\" aria-label=\"Read more about accessibility\">Read more</a>\n<a href=\"/article-2\" aria-label=\"Read more about inclusive design\">Read more</a>"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "In React, card components with 'Read more' links should accept a linkLabel prop: <a href={href} aria-label={`Read more about ${title}`}>Read more</a>. This preserves visual design while adding screen reader context.",
        "vue": "In Vue, pass the article or card title into the link: <a :href='url' :aria-label='`Read more about ${title}`'>Read more</a>.",
        "angular": "In Angular, use [attr.aria-label]='\"Read more about \" + card.title' on the link element within the card component."
      },
      "fix_difficulty_notes": "axe uses heuristics to detect this — it flags links with identical text pointing to different URLs. False positives are common when 'Read more' links in a card grid are accompanied by a heading that provides context. WCAG 2.4.4 allows disambiguation through programmatic context (e.g., an aria-labelledby relationship between a card heading and its link). Check whether this is already satisfied before fixing. The simplest fix that avoids template changes is aria-label.",
      "manual_test": {
        "description": "Open the links list in a screen reader and verify each link is distinguishable without surrounding context.",
        "steps": [
          "In JAWS, press Ctrl+Insert+F7 to open the links list — scan for duplicate link text pointing to different URLs.",
          "In VoiceOver, use Ctrl+Opt+U and navigate to Links — duplicate entries indicate this violation.",
          "For each duplicate, verify whether programmatic context (heading, list item, aria-labelledby) makes the purpose clear without reading the link in isolation."
        ]
      }
    },
    "image-alt": {
      "fix": {
        "description": "Add a descriptive alt attribute to every <img>. Use alt=\"\" for decorative images.",
        "code": "<img src=\"photo.jpg\" alt=\"Description of the image\">\n<!-- Decorative image (hidden from AT): -->\n<img src=\"divider.png\" alt=\"\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use the alt prop directly on <img>: <img src={src} alt=\"Description\" />. For decorative images: alt=\"\".",
        "vue": "Use :alt binding or plain alt attribute — standard HTML semantics apply.",
        "angular": "Use [attr.alt] binding or plain alt attribute on <img> elements."
      },
      "fix_difficulty_notes": "axe-core confirms alt presence but cannot evaluate alt quality. An alt='photo.jpg' or alt='image' passes axe but violates 1.1.1. Always verify that alt text is descriptive and conveys the image's purpose. For decorative images, use alt='' (empty, not omitted — omitting alt causes some screen readers to announce the filename).",
      "manual_test": {
        "description": "Verify the alt text is meaningful, not just present.",
        "steps": [
          "Read the alt text in isolation — does it convey the image's purpose without seeing it?",
          "Flag alts that are filenames (e.g. 'hero.jpg'), generic ('image', 'photo'), or identical to adjacent text.",
          "For decorative images, confirm alt=\"\" is used (not omitted entirely)."
        ]
      },
      "related_rules": [
        {
          "id": "input-image-alt",
          "reason": "The same alt text requirement applies to <input type=\"image\"> — fix all alt text violations together."
        },
        {
          "id": "svg-img-alt",
          "reason": "SVGs used as images need equivalent alt text — audit both together."
        },
        {
          "id": "image-redundant-alt",
          "reason": "When adding alt text, avoid duplicating visible adjacent text — fixing one can trigger the other."
        },
        {
          "id": "object-alt",
          "reason": "The same text alternative requirement applies to <object> — audit both together."
        },
        {
          "id": "area-alt",
          "reason": "The parent <img> of the image map also needs alt text — fix both together."
        },
        {
          "id": "role-img-alt",
          "reason": "Both rules require images to have accessible names — fix all image alternatives together."
        }
      ]
    },
    "image-redundant-alt": {
      "fix": {
        "description": "Remove or shorten the alt text when it duplicates adjacent visible text. Use alt='' to mark the image as decorative when adjacent text fully explains it.",
        "code": "<!-- Before: alt duplicates adjacent figcaption -->\n<figure>\n  <img src=\"chart.png\" alt=\"Bar chart showing Q1 2024 sales by region\">\n  <figcaption>Bar chart showing Q1 2024 sales by region</figcaption>\n</figure>\n\n<!-- After: empty alt — caption provides the description -->\n<figure>\n  <img src=\"chart.png\" alt=\"\">\n  <figcaption>Bar chart showing Q1 2024 sales by region</figcaption>\n</figure>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, CMS-driven content often auto-populates alt from the image title, which duplicates the adjacent heading. Use conditional alt: alt={caption ? '' : imageAlt} when a caption is present.",
        "vue": "In Vue, compute the alt conditionally: :alt='caption ? \"\" : imageAlt'. Avoid binding the same string to both alt and a figcaption.",
        "angular": "In Angular, use conditional binding: [attr.alt]='caption ? \"\" : imageAlt' to suppress redundant alt when a visible caption is present."
      },
      "fix_difficulty_notes": "axe flags exact or near-exact matches between alt and adjacent text — but verify the adjacent text is truly sufficient before setting alt=''. For charts, the figcaption may describe the title but not the data values — the image alt may still be needed. In <figure>/<figcaption> pairs, the figcaption typically replaces the alt for descriptive images, but for complex diagrams, consider aria-describedby pointing to a detailed description.",
      "manual_test": {
        "description": "Navigate to each image with a screen reader and verify the alt text adds value beyond adjacent visible text.",
        "steps": [
          "Navigate over each image — the screen reader announces the alt text.",
          "If the same text was already announced as adjacent content (heading, caption, paragraph), the alt is redundant — set alt=''.",
          "Verify that images with alt='' are truly decorative and their full context is communicated by surrounding visible text."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "When adding alt text, avoid duplicating visible adjacent text — fixing one can trigger the other."
        },
        {
          "id": "svg-img-alt",
          "reason": "When adding aria-label to SVGs, avoid duplicating visible adjacent text."
        }
      ]
    },
    "input-button-name": {
      "fix": {
        "description": "Add a value attribute or aria-label to every <input type='button'>, <input type='submit'>, and <input type='reset'>.",
        "code": "<!-- Input buttons use value as accessible name: -->\n<input type=\"submit\" value=\"Submit order\">\n<input type=\"reset\" value=\"Clear form\">\n<input type=\"button\" value=\"Load more results\">\n\n<!-- If value must stay empty for visual reasons, use aria-label: -->\n<input type=\"submit\" value=\"\" aria-label=\"Submit order\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, use the value prop: <input type='submit' value='Submit order' />. For modern React, prefer <button type='submit'>Submit order</button> — it supports child elements (icons, spans) and is more styleable.",
        "vue": "In Vue, use value='Submit order' or :value='submitLabel' for dynamic labels. Prefer <button type='submit'> over <input type='submit'> for greater flexibility.",
        "angular": "In Angular, use [value]='submitLabel' or a static value attribute. Angular Material's mat-button directives work on <button> — prefer <button> for all interactive controls."
      },
      "fix_difficulty_notes": "For <input type='submit'> and <input type='reset'>, browsers provide default labels ('Submit' and 'Reset') when value is omitted — axe may or may not flag these depending on context. Prefer explicit value attributes over browser defaults, as default labels are not consistently translated across locales. Prefer <button type='submit'> over <input type='submit'> for new code — it is more flexible.",
      "manual_test": {
        "description": "Tab to the input button and verify the screen reader announces a meaningful label.",
        "steps": [
          "Tab to the <input type='submit'> or <input type='button'>.",
          "The AT must announce the button label and role (e.g., 'Submit order, button').",
          "If only 'button' is announced with no label, the value attribute is missing or empty."
        ]
      },
      "related_rules": [
        {
          "id": "button-name",
          "reason": "The same accessible name requirement applies to <button> elements — fix all button naming violations together."
        },
        {
          "id": "link-name",
          "reason": "The same accessible name requirement applies to links — fix all interactive element naming together."
        }
      ]
    },
    "input-image-alt": {
      "fix": {
        "description": "Add an alt attribute to every <input type=\"image\"> describing the action it performs.",
        "code": "<input type=\"image\" src=\"submit.png\" alt=\"Submit form\">"
      },
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The alt must describe the button's action, not the image appearance. 'Submit form' is correct; 'Blue arrow pointing right' is not.",
      "manual_test": {
        "description": "Tab to the image input and verify the screen reader announces the action.",
        "steps": [
          "Tab to the <input type=\"image\"> — the screen reader must announce the alt text.",
          "Confirm the alt text describes the action (e.g., 'Submit form'), not the image appearance.",
          "If no screen reader is available, inspect the alt attribute in DevTools."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The same alt text requirement applies to <img> — fix all alt text violations together."
        },
        {
          "id": "svg-img-alt",
          "reason": "SVGs used as images share the same accessible name requirement."
        }
      ]
    },
    "label": {
      "fix": {
        "description": "Associate every form input with a visible <label> element.",
        "code": "<label for=\"email\">Email address</label>\n<input id=\"email\" type=\"email\" name=\"email\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use htmlFor prop (not 'for') on <label>: <label htmlFor=\"email\">Email</label>. The 'for' attribute is reserved in JSX.",
        "vue": "Use the standard for attribute: <label for=\"email\">. Vue renders standard HTML — no special prop needed.",
        "angular": "Use [for]=\"inputId\" binding or wrap the input inside the label element to avoid explicit ID linking."
      },
      "fix_difficulty_notes": "aria-label works technically but voice control users cannot target the field by speaking the label — they need a visible text match. Prefer a visible <label> over aria-label for all inputs. placeholder is not a substitute for a label — it disappears on input and is not reliably announced by screen readers.",
      "manual_test": {
        "description": "Click the label text to ensure focus moves to the input.",
        "steps": [
          "Click the text label.",
          "If the input field doesn't gain focus, the label is not correctly associated (missing 'for' or 'id' match)."
        ]
      },
      "related_rules": [
        {
          "id": "select-name",
          "reason": "The same label association pattern resolves select-name violations."
        },
        {
          "id": "autocomplete-valid",
          "reason": "Properly labeled inputs should also have correct autocomplete tokens — fix label association and autocomplete together."
        },
        {
          "id": "form-field-multiple-labels",
          "reason": "Fixing label association may expose or create multiple-label conflicts — audit both together."
        },
        {
          "id": "label-content-name-mismatch",
          "reason": "The visible label text must match the accessible name — fix label association and name mismatch together."
        },
        {
          "id": "aria-input-field-name",
          "reason": "ARIA input field naming and native label association address the same accessible name gap — fix together."
        },
        {
          "id": "aria-toggle-field-name",
          "reason": "The same label association pattern resolves both label and aria-toggle-field-name violations."
        },
        {
          "id": "label-title-only",
          "reason": "Both rules enforce proper label association — fix label-title-only and label violations together."
        }
      ]
    },
    "label-content-name-mismatch": {
      "fix": {
        "description": "Ensure the element's accessible name contains or starts with the visible label text so voice control users can activate it by speaking what they see.",
        "code": "<!-- Visible label: 'Search products' -->\n<!-- aria-label must contain that text: -->\n<button aria-label=\"Search products\">Search products</button>\n\n<!-- Or remove aria-label and rely on visible text: -->\n<button>Search products</button>\n\n<!-- If icon + text: make aria-label match the visible text -->\n<button aria-label=\"Search products\">\n  <svg aria-hidden=\"true\">...</svg>\n  Search products\n</button>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, avoid aria-label props that differ from the button's child text. For icon buttons, if you add visible text alongside the icon, the aria-label becomes unnecessary — remove it.",
        "vue": "In Vue, check components that accept both a label slot and an aria-label prop — if both are provided with different values, this violation occurs. Prefer deriving the accessible name from the visible slot content.",
        "angular": "In Angular, aria-label bindings on buttons with text content are a common source of this violation. Remove [attr.aria-label] on buttons that have visible text children unless the label extends the text rather than replacing it."
      },
      "fix_difficulty_notes": "The accessible name must contain (not just match) the visible text — it can have additional context. For example, aria-label='Search products in catalog' on a button with visible text 'Search products' is valid. The violation is when aria-label completely replaces the visible label with different text (e.g., visible 'Buy now', aria-label='Add to cart'). The simplest fix is often to remove the aria-label and let the visible text serve as the accessible name.",
      "manual_test": {
        "description": "Test activation by speaking the visible label using Voice Control or Dragon.",
        "steps": [
          "Enable iOS Voice Control or Dragon NaturallySpeaking.",
          "Speak the visible button or link text exactly as it appears on screen.",
          "If the element is not activated, the accessible name does not match the visible label — a mismatch exists.",
          "In DevTools Accessibility panel, compare the 'Name' field against the visible text."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "Fixing label association is the primary step before resolving name mismatch."
        },
        {
          "id": "form-field-multiple-labels",
          "reason": "Multiple labels frequently cause accessible name to differ from visible label text."
        }
      ]
    },
    "label-title-only": {
      "fix": {
        "description": "Ensure every form element has a visible label and is not solely labeled using the title attribute, aria-describedby, or hidden labels. The title attribute is not consistently exposed by all screen readers and is not visible to sighted users.",
        "code": "<!-- Before: labeled only by title (not visible, not reliable) -->\n<input type=\"text\" title=\"Enter your name\">\n\n<!-- After: visible <label> element -->\n<label for=\"name\">Full name</label>\n<input type=\"text\" id=\"name\">\n\n<!-- Also valid: floating label pattern with visible label -->\n<div class=\"form-group\">\n  <input type=\"email\" id=\"email\" placeholder=\" \" required>\n  <label for=\"email\">Email address</label>\n</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, avoid using title as the sole labeling mechanism on inputs. Use <label htmlFor='id'> or aria-label only for visually hidden inputs. For floating labels, ensure the <label> is always rendered — not replaced by placeholder text.",
        "vue": "In Vue, replace title-only labeling with <label :for='id'>. For component libraries (Vuetify, PrimeVue), use the label prop which renders a visible <label> element, not just a title attribute.",
        "angular": "In Angular, use <label [for]='inputId'> or Angular Material's <mat-label> inside <mat-form-field>. The mat-label renders a visible, persistent label. Do not rely on [attr.title] as the sole accessible name."
      },
      "fix_difficulty_notes": "The title attribute provides a tooltip on hover but is not reliably announced by all screen reader and browser combinations. WCAG requires a visible label for form inputs (1.3.1 Info and Relationships, 3.3.2 Labels or Instructions). The fix is to add a <label> element associated via for/id. For cases where a visible label is not desired (icon-only search fields), use aria-label with a visually hidden <label> as a fallback.",
      "manual_test": {
        "description": "Verify every form field has a visible label that is programmatically associated.",
        "steps": [
          "Tab to each form field with a screen reader — the label must be announced.",
          "Visually inspect the form — every field should have a visible label nearby (above or to the left).",
          "In DevTools Accessibility panel, check the 'Name' source — it should be 'label' or 'aria-label', not 'title'."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "Both rules enforce proper label association — fix label-title-only and label violations together."
        },
        {
          "id": "form-field-multiple-labels",
          "reason": "When adding a visible label, verify you are not creating a duplicate label association."
        }
      ]
    },
    "landmark-banner-is-top-level": {
      "fix": {
        "description": "Ensure the banner landmark (<header> or role='banner') is at the top level of the document and not nested inside another landmark such as <main>, <aside>, <nav>, or <section>.",
        "code": "<!-- Correct: banner at the top level -->\n<body>\n  <header>\n    <nav aria-label=\"Primary\">\n      <a href=\"/\">Home</a>\n    </nav>\n  </header>\n  <main>...</main>\n  <footer>...</footer>\n</body>\n\n<!-- Incorrect: banner nested inside main -->\n<!-- <main>\n  <header>Site header</header>\n  <section>Content</section>\n</main> -->"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js, place <header> in the root layout.tsx as a sibling of <main>, not inside it. Page components must not render a top-level <header> — use <section> or <div> for page-specific header areas.",
        "vue": "In Nuxt, place <header> in layouts/default.vue before the <main> wrapping <slot />. Do not nest <header> inside <main> or <aside>.",
        "angular": "In Angular, place <header> in app.component.html before the <main> wrapping <router-outlet>. Feature modules must not render a <header> inside the routed content area."
      },
      "fix_difficulty_notes": "A <header> inside <article> or <section> does not create a banner landmark — it is scoped to that sectioning element. The violation occurs when a <header> intended as the site banner is nested inside <main> or another landmark. Move it to be a direct child of <body>. In SPA frameworks, ensure the layout component places <header> before <main>, not inside it.",
      "manual_test": {
        "description": "Verify the banner landmark is at the top level of the landmark hierarchy.",
        "steps": [
          "In VoiceOver, press Ctrl+Opt+U and open the Landmarks rotor — 'banner' must appear at the top level, not nested under 'main' or 'complementary'.",
          "In DevTools Console: verify the <header> element is a direct child of <body> or equivalent top-level container.",
          "Navigate to the banner with a screen reader and confirm it is announced as a standalone landmark."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "If the banner is duplicated and one copy is nested incorrectly, fix both the nesting and the duplication together."
        },
        {
          "id": "landmark-contentinfo-is-top-level",
          "reason": "The contentinfo (footer) landmark has the same top-level requirement — fix both together."
        },
        {
          "id": "landmark-main-is-top-level",
          "reason": "All primary landmarks (banner, main, contentinfo) must be at the top level — fix as a group."
        },
        {
          "id": "landmark-complementary-is-top-level",
          "reason": "All primary landmarks share the same top-level requirement — fix nesting issues for all landmarks together."
        }
      ]
    },
    "landmark-complementary-is-top-level": {
      "fix": {
        "description": "Ensure the complementary landmark (<aside> or role='complementary') is at the top level of the document and not nested inside another landmark such as <main>, <nav>, or <header>.",
        "code": "<!-- Correct: aside at the top level -->\n<body>\n  <header>...</header>\n  <main>...</main>\n  <aside aria-label=\"Related articles\">\n    <h2>Related articles</h2>\n    <ul>...</ul>\n  </aside>\n  <footer>...</footer>\n</body>\n\n<!-- Incorrect: aside nested inside main -->\n<!-- <main>\n  <article>Content</article>\n  <aside>Sidebar</aside>\n</main> -->"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js App Router, place <aside> in layout.tsx as a sibling of <main>, not inside it. If sidebar content varies per page, use a slot pattern or React context to project sidebar content into the layout-level <aside>.",
        "vue": "In Nuxt, use a named slot in layouts/default.vue for sidebar content: <aside><slot name='sidebar' /></aside> placed outside <main>. Page components fill the slot without nesting <aside> inside <main>.",
        "angular": "In Angular, place <aside> in app.component.html alongside <main>, not inside the <router-outlet>. Use a service or ng-content projection to populate sidebar content from route components."
      },
      "fix_difficulty_notes": "The HTML spec allows <aside> inside <article> or <section>, where it is scoped to that sectioning element and does not create a top-level complementary landmark. The violation occurs when an <aside> intended as a page-level sidebar is nested inside <main>. Move it to be a sibling of <main>. Common in blog layouts where the sidebar is mistakenly placed inside the main content area.",
      "manual_test": {
        "description": "Verify the complementary landmark is at the top level of the landmark hierarchy.",
        "steps": [
          "In VoiceOver, open the Landmarks rotor — 'complementary' must appear at the top level, not nested under 'main'.",
          "In DevTools, verify <aside> is not a descendant of <main>, <header>, or <footer>.",
          "Navigate to the aside with a screen reader and confirm it is announced as a standalone complementary landmark."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-banner-is-top-level",
          "reason": "All primary landmarks share the same top-level requirement — fix nesting issues for all landmarks together."
        },
        {
          "id": "landmark-main-is-top-level",
          "reason": "Complementary and main landmarks must both be at the top level — fix together."
        }
      ]
    },
    "landmark-contentinfo-is-top-level": {
      "fix": {
        "description": "Ensure the contentinfo landmark (<footer> or role='contentinfo') is at the top level of the document and not nested inside another landmark such as <main>, <aside>, or <nav>.",
        "code": "<!-- Correct: footer at the top level -->\n<body>\n  <header>...</header>\n  <main>...</main>\n  <footer>\n    <p>&copy; 2026 Company Name</p>\n    <nav aria-label=\"Footer\">\n      <a href=\"/privacy\">Privacy</a>\n      <a href=\"/terms\">Terms</a>\n    </nav>\n  </footer>\n</body>\n\n<!-- Incorrect: footer nested inside main -->\n<!-- <main>\n  <section>Content</section>\n  <footer>Copyright info</footer>\n</main> -->"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js, place <footer> in the root layout.tsx after <main>, not inside it. Page components should not render a top-level <footer> — the layout owns the site-wide footer.",
        "vue": "In Nuxt, place <footer> in layouts/default.vue after the <main> wrapping <slot />. Individual page components must not add a <footer> at the landmark level.",
        "angular": "In Angular, place <footer> in app.component.html after the <main> wrapping <router-outlet>. Route components must not render their own <footer> at the document root level."
      },
      "fix_difficulty_notes": "A <footer> inside <article> or <section> does not create a contentinfo landmark — it is scoped to that sectioning element. The violation occurs when the site-wide <footer> is nested inside <main> or another landmark. Move it to be a direct child of <body>. In SPAs, this is typically a layout architecture issue — the layout component must place <footer> after <main>, not inside it.",
      "manual_test": {
        "description": "Verify the contentinfo landmark is at the top level of the landmark hierarchy.",
        "steps": [
          "In VoiceOver, open the Landmarks rotor — 'content information' must appear at the top level, not nested under 'main'.",
          "In DevTools, verify <footer> is not a descendant of <main>, <header>, or <aside>.",
          "Navigate to the footer with a screen reader and confirm it is announced as a standalone contentinfo landmark."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-no-duplicate-contentinfo",
          "reason": "If multiple contentinfo landmarks exist, fix both the nesting and the duplication together."
        },
        {
          "id": "landmark-banner-is-top-level",
          "reason": "Banner and contentinfo landmarks share the same top-level requirement — fix together."
        }
      ]
    },
    "landmark-main-is-top-level": {
      "fix": {
        "description": "Ensure the main landmark (<main> or role='main') is at the top level of the document and not nested inside another landmark such as <header>, <aside>, <nav>, or <section>.",
        "code": "<!-- Correct: main at the top level -->\n<body>\n  <header>...</header>\n  <main id=\"main-content\">\n    <h1>Page title</h1>\n    <section>...</section>\n  </main>\n  <footer>...</footer>\n</body>\n\n<!-- Incorrect: main nested inside a section -->\n<!-- <section>\n  <main>Content</main>\n</section> -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js App Router, <main> belongs in layout.tsx as a direct child of <body> (or the root element). Do not wrap <main> inside a <section> or <div role='region'>.",
        "vue": "In Nuxt, <main> belongs in layouts/default.vue as a top-level element wrapping <slot />. Do not nest it inside another landmark element.",
        "angular": "In Angular, <main> belongs in app.component.html wrapping <router-outlet>. Ensure no parent component template wraps it in a <section> or other landmark."
      },
      "fix_difficulty_notes": "The main landmark must be a direct child of <body> or of a non-landmark container (like a <div> wrapper used for CSS layout). It must not be nested inside <header>, <footer>, <aside>, <nav>, or any element with an explicit landmark role. The fix is usually a layout restructure to ensure <main> sits at the correct level in the DOM hierarchy.",
      "manual_test": {
        "description": "Verify the main landmark is at the top level of the landmark hierarchy.",
        "steps": [
          "In VoiceOver, open the Landmarks rotor — 'main' must appear at the top level, not nested under another landmark.",
          "In DevTools, verify <main> is not a descendant of <header>, <footer>, <aside>, or <nav>.",
          "Use the browser Accessibility Tree panel to confirm the main landmark is a top-level landmark node."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "Ensure exactly one main landmark exists and that it is at the top level."
        },
        {
          "id": "landmark-no-duplicate-main",
          "reason": "If the main landmark is duplicated, fix both the nesting and the duplication."
        },
        {
          "id": "landmark-banner-is-top-level",
          "reason": "All primary landmarks (banner, main, contentinfo) must be at the top level — fix as a group."
        },
        {
          "id": "landmark-complementary-is-top-level",
          "reason": "Complementary and main landmarks must both be at the top level — fix together."
        }
      ]
    },
    "landmark-no-duplicate-banner": {
      "fix": {
        "description": "Ensure only one <header> element (or role='banner') exists at the top level of the page, outside of sectioning elements.",
        "code": "<body>\n  <!-- One top-level header (banner landmark): -->\n  <header><!-- site-wide header --></header>\n  <main>\n    <!-- Nested headers inside article/section do NOT create banner landmarks: -->\n    <article>\n      <header>Article header — not a banner landmark</header>\n    </article>\n  </main>\n  <footer>...</footer>\n</body>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js App Router, the root layout (layout.tsx) should have exactly one <header> at the top level. Page components must not add a second top-level <header> — use <section> or <div> for page-specific header areas.",
        "vue": "In Nuxt, the global <header> belongs in layouts/default.vue. Individual page components must not render a top-level <header> — use <section aria-labelledby='...'>.",
        "angular": "In Angular, app.component.html should contain exactly one top-level <header>. Route components must not add a second <header> at the document root level."
      },
      "fix_difficulty_notes": "A <header> element only creates a banner landmark when it is a direct child of <body> (not nested inside <article>, <aside>, <main>, <nav>, or <section>). axe may flag this when a layout component renders two <header> tags at body level — one for a skip link area and one for the visible site header. Consolidate them into one top-level <header>.",
      "manual_test": {
        "description": "Verify only one banner landmark exists using screen reader landmark navigation.",
        "steps": [
          "In NVDA, press D to cycle through landmarks — 'banner' should appear only once.",
          "In VoiceOver, use Ctrl+Opt+U, navigate to Landmarks — 'banner' or 'header' must be listed only once.",
          "In DevTools Console: document.querySelectorAll('body > header, [role=\"banner\"]').length — expect 1."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-no-duplicate-main",
          "reason": "Fix all duplicate landmark violations together — they share the same root cause in layout architecture."
        },
        {
          "id": "landmark-one-main",
          "reason": "Landmark structure issues are often co-located — fix them as a group."
        },
        {
          "id": "landmark-unique",
          "reason": "Unique landmark labels are the fix for duplicate banner violations — add aria-label to distinguish them."
        },
        {
          "id": "landmark-banner-is-top-level",
          "reason": "If the banner is duplicated and one copy is nested incorrectly, fix both the nesting and the duplication together."
        },
        {
          "id": "landmark-no-duplicate-contentinfo",
          "reason": "Fix all duplicate landmark violations together — they share the same root cause in layout architecture."
        }
      ]
    },
    "landmark-no-duplicate-contentinfo": {
      "fix": {
        "description": "Ensure the document has at most one contentinfo landmark. Multiple top-level <footer> elements or elements with role='contentinfo' create ambiguity for screen reader users navigating by landmarks.",
        "code": "<!-- Correct: one top-level footer (contentinfo landmark) -->\n<body>\n  <header>...</header>\n  <main>\n    <article>\n      <footer>Article footer — not a contentinfo landmark</footer>\n    </article>\n  </main>\n  <footer><!-- Only this one creates a contentinfo landmark -->\n    <p>&copy; 2026 Company</p>\n  </footer>\n</body>\n\n<!-- Incorrect: two top-level footers -->\n<!-- <body>\n  <main>...</main>\n  <footer>Site links</footer>\n  <footer>Copyright</footer>\n</body> -->"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js, the root layout.tsx should contain exactly one top-level <footer>. Page components that need footer-like content should use <section> or <div>, not <footer>, to avoid creating a second contentinfo landmark.",
        "vue": "In Nuxt, the global <footer> belongs in layouts/default.vue. Individual page components must not render a second top-level <footer>. Use <div> or <section> for page-specific footer content.",
        "angular": "In Angular, app.component.html should contain exactly one <footer>. Route components must not add a second <footer> at the document root level — use <section> for page-specific bottom content."
      },
      "fix_difficulty_notes": "A <footer> inside <article>, <section>, or <aside> does not create a contentinfo landmark — it is scoped to that sectioning element. The violation only occurs when two or more <footer> elements exist at the body level (not inside sectioning elements). Consolidate them into one <footer> or move the extra ones inside sectioning elements where they become scoped footers.",
      "manual_test": {
        "description": "Verify only one contentinfo landmark exists using screen reader landmark navigation.",
        "steps": [
          "In NVDA, press D to cycle landmarks — 'content information' should appear only once.",
          "In VoiceOver, open the Landmarks rotor — 'content information' must be listed once.",
          "In DevTools Console: document.querySelectorAll('body > footer, [role=\"contentinfo\"]').length — expect 1."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-contentinfo-is-top-level",
          "reason": "Duplicate contentinfo landmarks are often caused by incorrect nesting — fix both together."
        },
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "Fix all duplicate landmark violations together — they share the same root cause in layout architecture."
        },
        {
          "id": "landmark-unique",
          "reason": "If duplicate contentinfo landmarks cannot be eliminated, give each a unique aria-label."
        }
      ]
    },
    "landmark-no-duplicate-main": {
      "fix": {
        "description": "Ensure only one <main> element (or role='main') exists on the page. If multiple content areas are needed, use <section> with unique aria-labelledby.",
        "code": "<main id=\"main-content\">\n  <!-- all primary page content -->\n  <section aria-labelledby=\"section-a-heading\">\n    <h2 id=\"section-a-heading\">Section A</h2>\n  </section>\n  <section aria-labelledby=\"section-b-heading\">\n    <h2 id=\"section-b-heading\">Section B</h2>\n  </section>\n</main>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js App Router, <main> belongs in layout.tsx, not in page.tsx. Individual page components render content inside the layout's <main> — never add a second <main> inside a page component.",
        "vue": "In Nuxt, <main> belongs in layouts/default.vue wrapping <slot />. Page components must not add a <main> wrapper.",
        "angular": "In Angular, <main> belongs in app.component.html wrapping <router-outlet>. Route component templates must not contain a second <main>."
      },
      "fix_difficulty_notes": "In SPAs, a second <main> commonly appears when a layout component defines one and a page component adds another. The fix is to ensure only the layout component owns the <main> wrapper, and page components render their content inside it without adding a second <main>.",
      "manual_test": {
        "description": "Confirm only one main landmark exists on the page.",
        "steps": [
          "Run in DevTools Console: document.querySelectorAll('main, [role=\"main\"]').length — expect 1.",
          "Navigate landmarks with a screen reader — 'main' should appear only once.",
          "For SPAs, check after each route transition — a second <main> may appear on specific routes."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "landmark-one-main requires exactly one <main> — duplicate main violations are the inverse of the same requirement."
        },
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "Fix all duplicate landmark violations together."
        },
        {
          "id": "landmark-main-is-top-level",
          "reason": "If the main landmark is duplicated, fix both the nesting and the duplication."
        }
      ]
    },
    "landmark-one-main": {
      "fix": {
        "description": "Add a <main> landmark wrapping your page content.",
        "code": "<main id=\"main-content\">\n  <!-- page content -->\n</main>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Place <main id='main-content'> in the root layout component (app/layout.tsx in Next.js App Router, or the root App component). Do not place <main> in individual page components — it will be missing for routes that render before the layout mounts.",
        "vue": "Add <main id='main-content'> to the root layout component (App.vue or layouts/default.vue in Nuxt), wrapping <router-view /> or <slot />. Nuxt: set it in layouts/default.vue.",
        "angular": "Add <main id='main-content'> in app.component.html wrapping <router-outlet>. This ensures the landmark is present for all routes and the skip link target resolves correctly."
      },
      "fix_difficulty_notes": "SPAs often render the <main> landmark conditionally — in React, Vue Router, and Angular, the layout shell may not include <main> if each page component is responsible for its own layout. Ensure the root layout component (e.g., layout.tsx in Next.js, App.vue in Vue, app.component.html in Angular) always wraps page content in <main>, not individual page components. Axe may also flag SPA routes where <main> is rendered client-side after the initial snapshot.",
      "manual_test": {
        "description": "Verify that the page content is structurally contained within the main landmark.",
        "steps": [
          "Open the accessibility tree in DevTools.",
          "Locate the 'main' role element.",
          "Ensure it contains all unique page content (excluding header/footer)."
        ]
      },
      "related_rules": [
        {
          "id": "bypass",
          "reason": "The skip link target (#main-content) should reference the <main> landmark."
        },
        {
          "id": "region",
          "reason": "Adding <main> may resolve orphan-content region violations."
        },
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "Landmark structure issues are often co-located — fix them as a group."
        },
        {
          "id": "landmark-no-duplicate-main",
          "reason": "Duplicate main violations are the inverse of the single <main> requirement — fix together."
        },
        {
          "id": "landmark-main-is-top-level",
          "reason": "Ensure exactly one main landmark exists and that it is at the top level."
        },
        {
          "id": "skip-link",
          "reason": "The skip link target should be the <main> landmark — ensure it exists and has the correct id."
        }
      ]
    },
    "landmark-unique": {
      "fix": {
        "description": "Add unique accessible labels to landmarks of the same type using aria-label or aria-labelledby.",
        "code": "<nav aria-label=\"Primary navigation\">\n  <!-- main site links -->\n</nav>\n\n<nav aria-label=\"Breadcrumb\">\n  <!-- breadcrumb trail -->\n</nav>\n\n<nav aria-label=\"Footer links\">\n  <!-- footer navigation -->\n</nav>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, pass the aria-label prop to navigation components: <Nav aria-label='Primary navigation'>. Ensure the component forwards the prop to the native <nav> element via spread or explicit prop.",
        "vue": "In Vue, bind aria-label directly on <nav>: <nav aria-label='Primary navigation'>. Navigation components should accept and forward an aria-label prop to the root <nav>.",
        "angular": "In Angular, use aria-label='Primary navigation' or [attr.aria-label]='navLabel' on <nav> elements. Shared navigation components should accept an @Input() ariaLabel string and bind it."
      },
      "fix_difficulty_notes": "This applies to nav, aside, section with role, and form landmarks — any type appearing more than once. Keep labels short and descriptive: 'Primary', 'Footer', 'Breadcrumb'. Do not add aria-label to <main> or <header> unless they are duplicated (which is itself a separate violation). The label becomes part of the AT announcement: 'Primary navigation, navigation landmark'.",
      "manual_test": {
        "description": "Navigate all landmarks and verify each has a unique, descriptive label.",
        "steps": [
          "In VoiceOver, press Ctrl+Opt+U and navigate to Landmarks — confirm each entry has a distinct label.",
          "In NVDA, press R to cycle through regions — duplicate labels (two unlabeled 'navigation' entries) indicate missing aria-label.",
          "Identify all <nav>, <aside>, and <section> elements — verify each has a unique aria-label or aria-labelledby."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "If duplicate banners exist, add aria-label to each — or eliminate the duplicate."
        },
        {
          "id": "bypass",
          "reason": "Unique landmark labels enhance skip navigation — users can jump directly to a specific landmark."
        },
        {
          "id": "landmark-no-duplicate-contentinfo",
          "reason": "If duplicate contentinfo landmarks cannot be eliminated, give each a unique aria-label."
        }
      ]
    },
    "link-in-text-block": {
      "fix": {
        "description": "Links within a block of text must be distinguishable from surrounding text by a visual cue other than color alone (e.g., underline, bold, outline). Users with color vision deficiency cannot rely on color difference to identify links (WCAG 1.4.1).",
        "code": "<!-- Before: link distinguished only by color -->\n<p>Read our <a href=\"/terms\" style=\"color: blue; text-decoration: none;\">terms of service</a>.</p>\n\n<!-- After: underline makes the link identifiable without color -->\n<p>Read our <a href=\"/terms\">terms of service</a>.</p>\n<!-- Browser default underline is sufficient -->\n\n<!-- Or use a visible underline + contrast -->\n<style>\n  a { text-decoration: underline; text-underline-offset: 0.2em; }\n</style>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Tailwind CSS projects, the 'no-underline' utility on links inside text blocks violates this rule. Use 'underline' or 'decoration-2' instead. In design systems, ensure the link component applies a visible non-color indicator by default.",
        "vue": "In Vue, global CSS resets (normalize.css, Tailwind's preflight) often remove link underlines. Re-add underlines to links within text blocks: a:not([class]) { text-decoration: underline; }. Scoped styles in Vue SFCs may not reach deep enough — check computed styles.",
        "angular": "In Angular Material, links may inherit the Material typography styles that remove underlines. Override in the component stylesheet: a { text-decoration: underline; }. Angular's ViewEncapsulation may prevent global styles from applying — use ::ng-deep cautiously or component-level styles."
      },
      "fix_difficulty_notes": "The 3:1 contrast ratio between link color and surrounding text color is the alternative to underlines per WCAG 1.4.1 — but meeting this ratio is difficult to verify and unreliable for users with color vision deficiency. The safest approach: always underline links within text blocks. Links in navigation menus, buttons, or clearly distinct UI elements are generally exempt because their context makes them identifiable as interactive.",
      "manual_test": {
        "description": "Identify links within text blocks and verify they are distinguishable without relying on color.",
        "steps": [
          "View the page in grayscale mode (DevTools > Rendering > Emulate vision deficiency > Achromatopsia).",
          "Identify all links within text blocks — each must be visually distinguishable from surrounding text.",
          "If a link is invisible in grayscale, add an underline or other non-color visual cue."
        ]
      }
    },
    "link-name": {
      "fix": {
        "description": "Use descriptive link text that conveys the destination or purpose. Avoid \"click here\" or \"read more\".",
        "code": "<a href=\"/products\">View our product catalog</a>\n<!-- Avoid: <a href=\"/products\">click here</a> -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React Router, use <Link to='/path'>Descriptive text</Link>. For icon links, add aria-label directly: <Link to='/search' aria-label='Search products'>. Avoid wrapping <Link> around empty or icon-only elements without an aria-label.",
        "vue": "In Vue Router, use <RouterLink to='/path'>Descriptive text</RouterLink>. For icon links, add :aria-label='...' on the RouterLink component.",
        "angular": "Use the routerLink directive on native <a> elements: <a routerLink='/path'>Descriptive text</a>. The native <a> carries the correct link role and accessible name automatically."
      },
      "fix_difficulty_notes": "Adding aria-label to a link that already has visible text creates a mismatch — voice control users speak the visible text, not the aria-label, and activation may fail. Use aria-label only for icon links with no visible text, or use aria-labelledby to reference visible content.",
      "manual_test": {
        "description": "Examine the link text in isolation.",
        "steps": [
          "Open the links list in a screen reader (e.g., JAWS Key + F7).",
          "Check if links like 'Read More' are distinguishable without their surrounding text."
        ]
      },
      "related_rules": [
        {
          "id": "button-name",
          "reason": "The same accessible name requirement applies to buttons — fix all interactive element naming together."
        },
        {
          "id": "input-button-name",
          "reason": "The same accessible name requirement applies to <input type=\"button\"> — fix all naming violations together."
        },
        {
          "id": "aria-command-name",
          "reason": "link-name covers native <a> elements — fix all interactive element naming together."
        }
      ]
    },
    "list": {
      "fix": {
        "description": "Ensure <ul> and <ol> elements contain only <li> children (and optionally <script> or <template>). Remove or rewrap invalid direct children.",
        "code": "<!-- Before: div inside ul (invalid) -->\n<ul>\n  <div class=\"list-item\">Item 1</div>\n  <div class=\"list-item\">Item 2</div>\n</ul>\n\n<!-- After: proper li elements -->\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, mapping an array to list items is straightforward: {items.map(item => <li key={item.id}>{item.name}</li>)}. Never wrap the map in an extra <div> inside <ul> — use React.Fragment or a flat map.",
        "vue": "In Vue, use v-for directly on <li>: <li v-for='item in items' :key='item.id'>{{ item.name }}</li>. Avoid adding a wrapper component between <ul> and <li>.",
        "angular": "In Angular, use *ngFor directly on <li>: <li *ngFor='let item of items'>{{ item.name }}</li>. Component wrappers between <ul> and <li> will introduce invalid children."
      },
      "fix_difficulty_notes": "Some CSS frameworks (Bootstrap, Tailwind) output <div> wrappers inside list elements via JavaScript-rendered components. axe will flag these. Before fixing, check whether the violation is in source HTML or in framework-rendered output — the fix location differs. Also note: a <ul> with role='none' on all <li> children (to remove list semantics) is an intentional pattern and not a violation of this rule.",
      "manual_test": {
        "description": "Verify a screen reader announces the correct list count and enables list navigation.",
        "steps": [
          "Navigate to the list with VoiceOver or NVDA — the AT should announce 'list, X items'.",
          "If no item count is announced or the list role is absent, the structure is broken.",
          "In DevTools, inspect the <ul> or <ol> and verify all direct children are <li> elements."
        ]
      },
      "related_rules": [
        {
          "id": "listitem",
          "reason": "The inverse rule — li elements must be inside a ul/ol. Fix list structure violations together."
        },
        {
          "id": "definition-list",
          "reason": "Both validate list structures — audit all list semantics violations together."
        }
      ]
    },
    "listitem": {
      "fix": {
        "description": "Wrap orphan <li> elements inside a <ul> or <ol> parent, or change the element to a non-list element if list semantics are not intended.",
        "code": "<!-- Before: li without a list parent -->\n<li>Item 1</li>\n<li>Item 2</li>\n\n<!-- After: wrapped in ul -->\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n\n<!-- Or if list semantics not intended: -->\n<p>Item 1</p>\n<p>Item 2</p>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, a component that returns <li> must always be rendered inside a <ul> or <ol>. If the component can be used in contexts without a list parent, consider making it return a generic container and letting the parent decide whether to wrap in <ul>.",
        "vue": "In Vue, a <li> component must have a <ul> or <ol> as its direct DOM parent. Vue's component wrapper does not count as a list — verify the rendered HTML structure in DevTools, not just the Vue template.",
        "angular": "In Angular, an <li> component inside <app-list-item> is still a valid <li> in the rendered DOM if the component tag is replaced. Verify the rendered output — Angular component tags are replaced, so check the actual HTML tree."
      },
      "fix_difficulty_notes": "This often occurs in component-based frameworks when a list item component renders <li> at the root but is used outside a parent list component. The fix is either to ensure the parent always provides a <ul>/<ol> context, or to restructure the component so <li> is not the root element when rendered standalone.",
      "manual_test": {
        "description": "Inspect the rendered DOM to confirm li elements have valid list parents.",
        "steps": [
          "In DevTools, right-click an <li> and 'Inspect' — verify the parent element is a <ul>, <ol>, or <menu>.",
          "Run in Console: [...document.querySelectorAll('li')].filter(li => !['UL','OL','MENU'].includes(li.parentElement.tagName)) — non-empty = orphan li elements.",
          "With a screen reader, navigate to the flagged area — orphan li elements may be announced without list context."
        ]
      },
      "related_rules": [
        {
          "id": "list",
          "reason": "Inverse rule — fix list/listitem violations together to restore correct list semantics."
        }
      ]
    },
    "marquee": {
      "fix": {
        "description": "Remove all <marquee> elements. The <marquee> element is deprecated in HTML and creates moving content that users cannot pause, which is inaccessible to users with cognitive disabilities and fails WCAG 2.2.2.",
        "code": "<!-- Before: scrolling marquee -->\n<marquee>Breaking news: accessibility matters!</marquee>\n\n<!-- After: static text with optional CSS animation that respects user preferences -->\n<p class=\"news-ticker\" role=\"alert\">Breaking news: accessibility matters!</p>\n<style>\n  .news-ticker { /* static by default */ }\n  @media (prefers-reduced-motion: no-preference) {\n    .news-ticker { animation: scroll-text 10s linear infinite; }\n  }\n  @media (prefers-reduced-motion: reduce) {\n    .news-ticker { animation: none; }\n  }\n</style>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "The <marquee> element is not a standard React element and should never be used. If scrolling text is needed, implement it with CSS animations and useReducedMotion() from Framer Motion or a prefers-reduced-motion media query hook.",
        "vue": "In Vue, <marquee> is treated as an unknown HTML element. Replace with a <p> or <div> and use CSS animations that respect prefers-reduced-motion. Nuxt projects should use the usePreferredReducedMotion() composable from VueUse.",
        "angular": "In Angular, replace <marquee> with a component that uses CSS animations controlled by a prefers-reduced-motion check. Use the Angular CDK BreakpointObserver or matchMedia to detect and respect the user's motion preference."
      },
      "fix_difficulty_notes": "This is one of the easiest fixes — simply remove the <marquee> element and replace with static content. The <marquee> element is fully deprecated and unsupported in the HTML spec. If scrolling/ticker functionality is genuinely needed (e.g., a stock ticker), implement it with CSS animations that respect prefers-reduced-motion and include a pause button for manual control.",
      "manual_test": {
        "description": "Verify no content on the page scrolls or moves without user control.",
        "steps": [
          "Search the page source for <marquee> elements — there should be none.",
          "If CSS-animated scrolling text exists, enable 'Reduce motion' in OS settings and verify it stops.",
          "Verify any scrolling content has a visible pause button."
        ]
      },
      "related_rules": [
        {
          "id": "blink",
          "reason": "Both <marquee> and <blink> are deprecated elements causing inaccessible animations — remove both together."
        }
      ]
    },
    "meta-refresh": {
      "fix": {
        "description": "Remove automatic page refresh. If redirecting immediately, a delay of 0 is permitted.",
        "code": "<!-- Remove this: -->\n<!-- <meta http-equiv=\"refresh\" content=\"5; url=...\"> -->\n\n<!-- Instant redirect only (delay=0 is OK): -->\n<meta http-equiv=\"refresh\" content=\"0; url=https://example.com/new-page\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js, use redirect() in server components or middleware for redirects, and useRouter().replace() for client-side navigation. Neither uses <meta http-equiv='refresh'>. Never insert a meta refresh tag.",
        "vue": "In Nuxt, use navigateTo() or definePageMeta({ redirect: '/' }) — both produce server or router-level redirects without <meta http-equiv='refresh'>.",
        "angular": "Use the Angular Router service (this.router.navigate() or this.router.navigateByUrl()) for all navigation. Never insert <meta http-equiv='refresh'> into templates or index.html."
      },
      "fix_difficulty_notes": "Server-side HTTP redirects (301/302) do not use <meta http-equiv='refresh'> and are not flagged by this rule. The violation only occurs when a timed redirect is implemented in the HTML <head>. A delay of 0 (instant redirect) is the only permitted use — it is commonly used for canonical URL normalization and is WCAG-compliant.",
      "manual_test": {
        "description": "Confirm the page does not reload or redirect without user interaction.",
        "steps": [
          "Load the page and wait 30 seconds — it must not refresh automatically.",
          "Check the <head> for <meta http-equiv=\"refresh\"> with a non-zero delay.",
          "Search JavaScript for setInterval/setTimeout calls that trigger window.location changes."
        ]
      }
    },
    "meta-viewport": {
      "fix": {
        "description": "Remove user-scalable=no from the viewport meta tag to allow users to zoom.",
        "code": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js App Router, manage the viewport meta via the Metadata API: export const viewport: Viewport = { width: 'device-width', initialScale: 1 }; in layout.tsx. Never set maximumScale: 1 or userScalable: false — these block zoom.",
        "vue": "In Nuxt, set the viewport in nuxt.config.ts: app.head.meta = [{ name: 'viewport', content: 'width=device-width, initial-scale=1' }]. Omit user-scalable=no entirely.",
        "angular": "The viewport meta is in index.html. Remove user-scalable=no if present: <meta name='viewport' content='width=device-width, initial-scale=1'>. Do not add maximum-scale=1 either — it has the same effect."
      },
      "fix_difficulty_notes": "iOS Safari (10+) ignores user-scalable=no as an accessibility override, but Android browsers may enforce it. Remove it unconditionally — there is no valid accessibility reason to block zoom, and it is explicitly forbidden by WCAG 1.4.4.",
      "manual_test": {
        "description": "Verify the page can be zoomed to 400% without horizontal scrolling on a 1280px viewport.",
        "steps": [
          "Open the page in Chrome and press Ctrl/Cmd + '+' repeatedly until 400% zoom.",
          "Confirm all content reflows vertically — no horizontal scrollbar should appear.",
          "On a mobile device, pinch-to-zoom must not be blocked."
        ]
      },
      "related_rules": [
        {
          "id": "meta-viewport-large",
          "reason": "meta-viewport checks for user-scalable=no (blocks zoom entirely); meta-viewport-large checks for insufficient maximum-scale."
        }
      ]
    },
    "meta-viewport-large": {
      "fix": {
        "description": "Ensure <meta name='viewport'> allows scaling to at least 500% (maximum-scale >= 5 or omit maximum-scale entirely). This is a stricter best-practice check beyond the WCAG AA requirement.",
        "code": "<!-- Best: no maximum-scale restriction at all -->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n<!-- Acceptable: maximum-scale is 5 or higher -->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=10\">\n\n<!-- Violation: maximum-scale below 5 -->\n<!-- <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=2\"> -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js App Router, configure viewport via the Metadata API: export const viewport: Viewport = { width: 'device-width', initialScale: 1 }; — omit maximumScale entirely. The Pages Router uses <Head><meta name='viewport' ... /></Head>.",
        "vue": "In Nuxt, set viewport in nuxt.config.ts: app.head.meta = [{ name: 'viewport', content: 'width=device-width, initial-scale=1' }]. Do not include maximum-scale unless it is 5 or higher.",
        "angular": "In Angular, the viewport meta is in index.html. Remove or increase maximum-scale: <meta name='viewport' content='width=device-width, initial-scale=1'>."
      },
      "fix_difficulty_notes": "This is a best-practice rule that goes beyond the WCAG AA requirement (which only requires not blocking zoom entirely via user-scalable=no or maximum-scale=1). The best-practice threshold is maximum-scale >= 5 (500% zoom). The simplest fix is to omit maximum-scale entirely — there is no valid accessibility reason to cap zoom level. iOS Safari ignores maximum-scale restrictions as an accessibility override, but Android browsers may enforce them.",
      "manual_test": {
        "description": "Verify the page can be zoomed significantly beyond the default scale on mobile devices.",
        "steps": [
          "On a mobile device or responsive simulator, pinch-to-zoom to 500% or higher.",
          "If zoom is capped before 500%, maximum-scale is set too low.",
          "Inspect the <meta name='viewport'> tag in DevTools and verify maximum-scale is absent or >= 5."
        ]
      },
      "related_rules": [
        {
          "id": "meta-viewport",
          "reason": "meta-viewport checks for user-scalable=no (blocks zoom entirely); meta-viewport-large checks for insufficient maximum-scale."
        }
      ]
    },
    "nested-interactive": {
      "fix": {
        "description": "Remove or restructure nested interactive elements. Interactive controls (buttons, links, inputs) must not be descendants of other interactive controls.",
        "code": "<!-- Before: button inside a link (invalid) -->\n<a href=\"/product\">\n  Product name\n  <button onclick=\"addToCart()\">Add to cart</button>\n</a>\n\n<!-- After: separate elements -->\n<div class=\"product-card\">\n  <a href=\"/product\">Product name</a>\n  <button onclick=\"addToCart()\">Add to cart</button>\n</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React card components, avoid wrapping the entire JSX tree in <Link> or <a> when it contains interactive children. Use a CSS stretched-link pattern: position the <a> absolutely with ::after covering the card, while the button stays outside the <a> in DOM order.",
        "vue": "In Vue, the same pattern applies — <RouterLink> wrapping a card with buttons inside is invalid HTML. Use the stretched-link CSS technique or restructure the component so interactive children are siblings, not descendants, of the link.",
        "angular": "In Angular, wrapping <mat-card> or a template outlet in [routerLink] creates the same issue. Set [routerLink] on a visible text element or use a CSS overlay approach to preserve DOM structure."
      },
      "fix_difficulty_notes": "The most common pattern causing this is a 'card' component where the entire card is wrapped in an <a> tag and a button (e.g., 'Add to cart', 'Save') is placed inside. The HTML spec forbids interactive content inside <a>. Solutions: (1) use the 'stretched link' CSS pattern to make the <a> visually cover the card without wrapping the button, or (2) use JavaScript to handle card-level clicks while keeping elements separate in the DOM.",
      "manual_test": {
        "description": "Tab into the nested element and verify both the outer and inner interactive elements are individually focusable and operable.",
        "steps": [
          "Tab to the flagged element — note which element receives focus first.",
          "Press Tab again — verify the inner interactive element also receives focus separately.",
          "Press Enter or Space on each — confirm they perform their intended actions independently.",
          "Test with a screen reader: both the link and the button should be announced as separate interactive elements."
        ]
      }
    },
    "no-autoplay-audio": {
      "fix": {
        "description": "Remove the autoplay attribute from audio elements, or provide a clearly visible pause/stop control that activates before 3 seconds of audio plays.",
        "code": "<!-- Remove autoplay: -->\n<audio controls src=\"background.mp3\"></audio>\n\n<!-- Background video: muted is acceptable -->\n<video autoplay muted loop src=\"bg-video.mp4\"></video>\n\n<!-- If autoplay with sound is required, provide an immediate stop control: -->\n<audio autoplay id=\"bg-audio\" src=\"jingle.mp3\"></audio>\n<button onclick=\"document.getElementById('bg-audio').pause()\" style=\"position:fixed;top:1rem;right:1rem\">Stop audio</button>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, never set the autoPlay prop on <audio> for content with meaningful audio. Background decorative video with autoPlay muted is acceptable. Trigger audio playback programmatically via user interaction events, not in useEffect on mount.",
        "vue": "In Vue, avoid :autoplay='true' on audio elements. Trigger audio playback via @click handlers. Background video with autoplay muted as static attributes is acceptable.",
        "angular": "In Angular, do not bind [autoplay]='true' on audio elements. Trigger .play() calls inside (click) event handlers, not in ngOnInit lifecycle hooks."
      },
      "fix_difficulty_notes": "axe detects the autoplay attribute but cannot determine whether the audio is muted — muted autoplay is acceptable. A <video autoplay muted loop> for decorative background video does not violate WCAG 1.4.2. The violation is specifically audio content that plays without user interaction and cannot be immediately stopped. Browser autoplay policies (especially Chrome) often block autoplay with sound anyway — verify the audio actually plays in the target browser before treating it as a confirmed violation.",
      "manual_test": {
        "description": "Load the page and immediately test whether audio plays without user interaction.",
        "steps": [
          "Open the page with a screen reader active — if audio plays, it will conflict with the AT speech.",
          "Check for a visible stop/pause control that appears before the audio has played for 3 seconds.",
          "Inspect the page source for <audio autoplay> or JavaScript .play() calls on page load.",
          "Confirm muted autoplay video produces no sound — muted is WCAG-compliant."
        ]
      }
    },
    "object-alt": {
      "fix": {
        "description": "Add an aria-label to every <object> element describing its content.",
        "code": "<object data=\"chart.svg\" type=\"image/svg+xml\" aria-label=\"Bar chart: Q1 2024 sales by region\">\n  Fallback text for unsupported browsers\n</object>"
      },
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The <object> element is rarely used in modern development — most use cases (SVG, PDF, media) are better served by <img>, <video>, <embed>, or <iframe>. If <object> is used, the aria-label must describe what the embedded content communicates to the user (not just the file type or format). If the object is purely decorative, consider replacing it with an accessible equivalent (e.g., an <img> with alt='').",
      "manual_test": {
        "description": "Verify a screen reader announces the object's accessible name.",
        "steps": [
          "Tab to the <object> element with VoiceOver or NVDA active.",
          "The screen reader must announce the label and the element type.",
          "If the object is purely decorative, consider replacing it with an equivalent image with alt=\"\"."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The same text alternative requirement applies to <img> — audit both together."
        }
      ]
    },
    "p-as-heading": {
      "fix": {
        "description": "Replace <p> elements styled to look like headings with actual heading elements (<h1>–<h6>) at the appropriate level in the document hierarchy.",
        "code": "<!-- Before: paragraph styled as heading -->\n<p class=\"text-2xl font-bold\">Section Title</p>\n<p>Content paragraph...</p>\n\n<!-- After: semantic heading -->\n<h2>Section Title</h2>\n<p>Content paragraph...</p>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In component libraries (shadcn/ui, Radix), heading-like components sometimes render as <p> by default. Use the 'as' prop or the 'asChild' pattern to change the rendered element: <Text as='h2' className='text-2xl font-bold'>Section Title</Text>.",
        "vue": "In Vue UI kits (Vuetify, Nuxt UI), check if the heading-like component supports a 'tag' prop: <VTitle tag='h2'>Section Title</VTitle>. Without it, add the heading element directly in the template.",
        "angular": "In Angular, heading-like components often render as <div> or <p>. Use the component's selector or a host element attribute to change the rendered tag, or apply the heading element directly in the template rather than relying on the component's default tag."
      },
      "fix_difficulty_notes": "axe detects this heuristically — it flags <p> elements with large, bold, or otherwise heading-like CSS properties. This can produce false positives on intro paragraphs, pull quotes, or callout boxes that are intentionally styled large. Verify visually: does this text introduce a new section of content? If yes, it should be a heading. If it is decorative, a caption, or a lead-in paragraph, it may not need to be a heading despite the styling.",
      "manual_test": {
        "description": "Navigate the page using only the heading shortcut in a screen reader and confirm all section labels are reachable.",
        "steps": [
          "Use NVDA/JAWS (H key) or VoiceOver (Cmd+Fn+Right) to jump between headings.",
          "If a visually prominent section label is skipped (not reachable by heading navigation), it is a p-as-heading violation.",
          "Visually inspect large, bold text that appears section-like — compare its element type in DevTools."
        ]
      },
      "related_rules": [
        {
          "id": "heading-order",
          "reason": "After converting p-as-heading to real headings, verify the heading hierarchy is correct — new headings must fit the existing order."
        },
        {
          "id": "page-has-heading-one",
          "reason": "If converting a p-as-heading introduces a new h1, verify it is the only h1 on the page."
        }
      ]
    },
    "page-has-heading-one": {
      "fix": {
        "description": "Add exactly one <h1> as the primary page heading.",
        "code": "<h1>Main page heading</h1>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In Next.js App Router, place the h1 directly in page.tsx, not in a client component that renders conditionally or inside a Suspense loading state — axe evaluates the initial HTML payload before client hydration fills the loading boundary.",
        "vue": "In Nuxt, ensure the page-level h1 is in the <template> of the page component so it is included in the server-rendered HTML. Avoid placing the h1 exclusively inside an async component that renders after the initial paint.",
        "angular": "With Angular Universal (SSR), the h1 must be part of the component template, not inserted via JavaScript after hydration. Verify the h1 is visible in the pre-rendered HTML using View Source."
      },
      "fix_difficulty_notes": "In SPAs and SSR frameworks, the h1 may be injected client-side after the initial DOM snapshot axe evaluates. Ensure the h1 is server-side rendered or present in the initial HTML payload. In Next.js, place the h1 directly in the page component, not behind a loading state.",
      "manual_test": {
        "description": "Confirm there is exactly one h1 per page — not zero, not two.",
        "steps": [
          "Open DevTools Console and run: document.querySelectorAll('h1').length — expect 1.",
          "For SPAs, navigate between routes and re-run the check after each transition.",
          "Read the h1 aloud — does it accurately describe the unique purpose of this page?"
        ]
      },
      "related_rules": [
        {
          "id": "heading-order",
          "reason": "Fixing the missing h1 anchors the heading hierarchy and may cascade-resolve heading-order violations."
        },
        {
          "id": "p-as-heading",
          "reason": "If converting a p-as-heading introduces a new h1, verify it is the only h1 on the page."
        }
      ]
    },
    "presentation-role-conflict": {
      "fix": {
        "description": "Ensure elements with role='presentation' or role='none' do not have global ARIA attributes or tabindex that would conflict with their presentational purpose. These conflicts cause inconsistent behavior across screen readers.",
        "code": "<!-- Before: conflicting attributes on a presentational element -->\n<table role=\"presentation\" aria-label=\"Layout table\" tabindex=\"0\">\n  <tr><td>Content</td></tr>\n</table>\n\n<!-- After: remove conflicting attributes -->\n<table role=\"presentation\">\n  <tr><td>Content</td></tr>\n</table>\n\n<!-- Or remove the presentational role if ARIA/tabindex are needed -->\n<table aria-label=\"Data summary\" tabindex=\"0\">\n  <tr><td>Content</td></tr>\n</table>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, components that spread props onto a root element may inadvertently add aria-label, aria-describedby, or tabIndex to an element with role='presentation'. Audit the rendered DOM to ensure presentational elements have no global ARIA attributes.",
        "vue": "In Vue, attribute inheritance (inheritAttrs: true by default) can pass global ARIA attributes from a parent component down to a child with role='presentation'. Set inheritAttrs: false on presentational wrapper components.",
        "angular": "In Angular, host bindings on components with role='presentation' may add tabindex or aria-label via @HostBinding. Audit host bindings and remove any that conflict with the presentational role."
      },
      "fix_difficulty_notes": "When role='presentation' or role='none' is set, the element is removed from the accessibility tree. Adding global ARIA attributes (aria-label, aria-describedby, aria-live) or tabindex creates a conflict: the element tries to be both invisible and interactive to AT. The fix is to either remove the conflicting attributes (if the element is truly presentational) or remove role='presentation' (if the element needs to be accessible). Screen readers resolve this conflict differently — some honor the role, others honor the ARIA attributes.",
      "manual_test": {
        "description": "Verify the element is either fully presentational (invisible to AT) or fully accessible, with no conflicting signals.",
        "steps": [
          "In the browser Accessibility Tree panel, locate the element — if role='presentation' is applied, it should not appear in the tree.",
          "Tab through the page — if the element receives focus despite role='presentation', there is a tabindex conflict.",
          "With a screen reader, navigate to the area — the element should either be completely silent (presentational) or fully announced (not presentational)."
        ]
      },
      "related_rules": [
        {
          "id": "aria-prohibited-attr",
          "reason": "Both rules address ARIA attributes that should not be present on the element — fix together."
        }
      ]
    },
    "redundant-entry": {
      "fix": {
        "description": "Do not require users to re-enter information already provided in the same session (WCAG 3.3.7). Pre-populate fields or provide a copy option.",
        "code": "<!-- Pre-populate from session data: -->\n<label for=\"ship-address\">Shipping address</label>\n<input id=\"ship-address\" type=\"text\" autocomplete=\"shipping street-address\"\n  value=\"{{ session.billing_address }}\">\n\n<!-- Or offer a checkbox: -->\n<label>\n  <input type=\"checkbox\" id=\"same-as-billing\">\n  Same as billing address\n</label>"
      },
      "false_positive_risk": "high",
      "framework_notes": {
        "react": "Use React Context or a form state library (React Hook Form, Formik) to preserve data across multi-step flows. In Next.js, persist form state in URL search params or session storage to survive route transitions without requiring re-entry.",
        "vue": "Use Pinia or Vuex to share form data across route-separated steps. In Nuxt, useState() persists data between pages without a full store — useful for lightweight multi-step form state.",
        "angular": "Use an Angular service with a shared BehaviorSubject to carry form state across route-separated steps. Angular Reactive Forms do not automatically persist across route navigations — manual persistence via a service is required."
      },
      "fix_difficulty_notes": "Automated tools cannot reliably detect this violation — they scan the static DOM of a single page without session context. Treat axe findings for this rule as a prompt for manual review, not a confirmed violation. Walk through multi-step flows manually to determine if previously entered data is unnecessarily re-requested.",
      "manual_test": {
        "description": "Walk through a multi-step form and verify previously entered data is not requested again.",
        "steps": [
          "Complete step 1 of a multi-step flow (e.g., billing address).",
          "On step 2 (e.g., shipping), check if the same data is pre-populated or a 'same as above' option is provided.",
          "If neither is present, the WCAG 3.3.7 violation stands."
        ]
      }
    },
    "region": {
      "fix": {
        "description": "Wrap all visible content in semantic landmark elements.",
        "code": "<header><!-- header content --></header>\n<main><!-- main content --></main>\n<footer><!-- footer content --></footer>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "Use semantic JSX elements: <header>, <main>, <nav>, <aside>, <footer> instead of <div> wrappers. In Next.js App Router, landmarks naturally fall into layout.tsx (header/footer) and page.tsx (main content).",
        "vue": "Use semantic HTML5 elements in Vue templates — they work identically to plain HTML. In Nuxt, place <header> and <footer> in the layout component and wrap <slot /> in <main>.",
        "angular": "Angular adds a custom element wrapper (<app-root>, <app-header>) — ensure the semantic landmark element (<header>, <main>) is inside the component template, not expected to be provided by the custom wrapper."
      },
      "fix_difficulty_notes": "Decorative separators, spacer divs, and background containers do not need to be inside landmarks. Only meaningful visible content requires landmark wrapping. Review each flagged element before adding a landmark.",
      "manual_test": {
        "description": "Check for content outside of landmarks using a screen reader or landmark extension.",
        "steps": [
          "Use a landmark bypass extension or screen reader command (e.g., 'R' in NVDA/JAWS).",
          "Ensure no 'orphan' content exists outside of landmark regions."
        ]
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "Adding a <main> landmark is typically the primary fix for orphan content."
        },
        {
          "id": "skip-link",
          "reason": "Proper landmark regions reduce the need for skip links but do not replace them — both mechanisms should coexist."
        }
      ]
    },
    "role-img-alt": {
      "fix": {
        "description": "Elements with role='img' must have an accessible name via aria-label or aria-labelledby. This includes SVGs, CSS-styled elements, and custom image components that use role='img' to convey visual meaning.",
        "code": "<!-- SVG with role='img' and aria-label -->\n<svg role=\"img\" aria-label=\"Company logo\" viewBox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"#333\" />\n</svg>\n\n<!-- Decorative SVG: use role='presentation' or aria-hidden -->\n<svg role=\"presentation\" aria-hidden=\"true\" viewBox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"#333\" />\n</svg>\n\n<!-- Div with role='img' (e.g., CSS background image) -->\n<div role=\"img\" aria-label=\"Sunset over mountains\"\n  style=\"background-image: url('sunset.jpg'); width: 300px; height: 200px;\"></div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, inline SVGs should have role='img' and aria-label on the root <svg> element. For SVG icon components, accept an aria-label prop and apply it to the SVG. Decorative SVGs should have aria-hidden='true'. Libraries like @heroicons/react and lucide-react handle this correctly when passing aria-label.",
        "vue": "In Vue, SVG components should accept an aria-label prop. Use role='img' on the root <svg> and v-bind:aria-label. Decorative icons should use aria-hidden='true'. Nuxt Image generates <img> tags (not role='img') — this rule applies to custom SVG and CSS image components.",
        "angular": "In Angular, SVG icon components (including MatIcon) should have role='img' and an accessible name. MatIcon supports [attr.aria-label] directly. For custom SVG components, bind [attr.aria-label]='imageLabel' and set role='img' on the host element."
      },
      "fix_difficulty_notes": "The most common trigger: inline SVGs without an accessible name. Every SVG that conveys meaning should have role='img' and aria-label. Decorative SVGs (icons next to text, dividers, backgrounds) should have aria-hidden='true' instead. CSS background images conveying meaning need a wrapper with role='img' and aria-label — the background-image itself is invisible to AT.",
      "manual_test": {
        "description": "Navigate to the element with a screen reader and verify it is announced with a descriptive name.",
        "steps": [
          "Navigate to the role='img' element — the screen reader should announce the accessible name and 'image' role.",
          "If the image is decorative, verify it is hidden from AT (not announced at all).",
          "For SVGs, confirm the <title> element or aria-label provides a meaningful description."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "Both rules require images to have accessible names — fix all image alternatives together."
        },
        {
          "id": "svg-img-alt",
          "reason": "svg-img-alt specifically targets SVG elements with role='img' — they overlap with this rule."
        }
      ]
    },
    "scope-attr-valid": {
      "fix": {
        "description": "Ensure the scope attribute is used correctly on tables: scope must only appear on <th> elements and its value must be 'row', 'col', 'rowgroup', or 'colgroup'.",
        "code": "<!-- Correct: scope on <th> elements -->\n<table>\n  <thead>\n    <tr>\n      <th scope=\"col\">Name</th>\n      <th scope=\"col\">Email</th>\n      <th scope=\"col\">Role</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th scope=\"row\">Jane Doe</th>\n      <td>jane@example.com</td>\n      <td>Admin</td>\n    </tr>\n  </tbody>\n</table>\n\n<!-- Invalid: scope on <td> -->\n<!-- <td scope=\"row\">Jane</td> -->"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React table components, ensure scope is only passed to <th> elements, not <td>. When using dynamic rendering (mapping over columns), conditionally apply scope based on whether the cell is a header: scope={isHeader ? 'col' : undefined}.",
        "vue": "In Vue, bind :scope only on <th> elements: <th :scope=\"isRowHeader ? 'row' : 'col'\">. Do not use scope on <td> — it is invalid HTML and ignored by screen readers.",
        "angular": "In Angular Material mat-table, headers are rendered via mat-header-cell. Add scope='col' to column headers and scope='row' to row headers manually — Angular Material does not set scope automatically."
      },
      "fix_difficulty_notes": "The scope attribute tells screen readers which data cells a header applies to. scope='col' means the header applies to the cells below it; scope='row' means it applies to cells to its right. Using scope on <td> is invalid HTML — move the scope to the appropriate <th>. For complex tables with multi-level headers, use the headers attribute on <td> elements instead of scope.",
      "manual_test": {
        "description": "Navigate the table with a screen reader and verify headers are correctly associated with data cells.",
        "steps": [
          "In NVDA, use Ctrl+Alt+Arrow keys to move between cells — each data cell must announce its associated column and row headers.",
          "If headers are not announced or the wrong header is read, inspect scope attributes in DevTools.",
          "Verify scope is only present on <th> elements and uses valid values: 'row', 'col', 'rowgroup', or 'colgroup'."
        ]
      },
      "related_rules": [
        {
          "id": "td-headers-attr",
          "reason": "For complex tables where scope is insufficient, the headers attribute on <td> provides explicit header associations."
        },
        {
          "id": "th-has-data-cells",
          "reason": "Headers must have data cells associated with them — fix scope and header-data relationships together."
        },
        {
          "id": "empty-table-header",
          "reason": "Scope on an empty <th> is meaningless — ensure headers have text content before adding scope."
        }
      ]
    },
    "scrollable-region-focusable": {
      "fix": {
        "description": "Make scrollable regions keyboard-accessible by adding tabindex=\"0\" and a descriptive label.",
        "code": "<div tabindex=\"0\" role=\"region\" aria-label=\"Content section\" style=\"overflow: auto;\">\n  <!-- scrollable content -->\n</div>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "Use a ref to check if the element actually overflows before adding tabIndex={0}. In React: const ref = useRef(); if (ref.current.scrollHeight > ref.current.clientHeight) add tabIndex. Avoid adding tabIndex to containers managed by virtual scroll libraries (react-window, react-virtual) — they handle keyboard internally.",
        "vue": "Use a template ref and check scrollHeight > clientHeight in onMounted before binding :tabindex='0'. CSS overflow containers created by v-show or transition wrappers may be flagged falsely — verify the element has genuine scroll content.",
        "angular": "Use @ViewChild and check nativeElement.scrollHeight > nativeElement.clientHeight in ngAfterViewInit. CDK ScrollingModule (VirtualScrollViewport) handles keyboard natively — do not add tabindex to its host element."
      },
      "fix_difficulty_notes": "This rule fires on any element with overflow:auto or overflow:scroll — including CSS clip containers, masked elements, and carousels that overflow visually but have no actual scrollable content. Before adding tabindex='0', confirm the element is genuinely scrollable (has overflow content) and that keyboard users need to scroll it. Adding tabindex='0' to a non-scrollable container adds unnecessary tab stops.",
      "manual_test": {
        "description": "Tab to the scrollable region and verify arrow keys scroll it.",
        "steps": [
          "Tab to the flagged element — keyboard focus must land on it.",
          "Press Arrow Down / Arrow Up — the content must scroll.",
          "Confirm a screen reader announces the region label when it receives focus."
        ]
      },
      "related_rules": [
        {
          "id": "aria-hidden-focus",
          "reason": "Both affect keyboard focus — audit all focusability violations together to avoid conflicts."
        },
        {
          "id": "focus-order-semantics",
          "reason": "Scrollable regions may need tabindex='0' for keyboard access but also need an appropriate role."
        }
      ]
    },
    "select-name": {
      "fix": {
        "description": "Associate every <select> element with a visible <label>.",
        "code": "<label for=\"country\">Country</label>\n<select id=\"country\" name=\"country\">\n  <option value=\"us\">United States</option>\n</select>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Use htmlFor on <label> pointing to the select's id. For custom select components (react-select, Headless UI Listbox), pass the accessible name via their label prop or aria-labelledby — these components use the combobox/listbox ARIA pattern internally.",
        "vue": "Native <select> uses standard <label for='id'>. For custom select components (Headless UI Listbox, Floating Vue Select), pass a label via their label prop — the component handles aria-labelledby internally.",
        "angular": "In Angular Material, <mat-select> is labeled via <mat-label> inside <mat-form-field>. For standalone <select> elements, use <label [for]='selectId'>Label</label>."
      },
      "fix_difficulty_notes": "In design systems, <select> is commonly replaced with a custom dropdown (a div/button combination). If the custom dropdown lacks role='listbox', aria-expanded, and aria-labelledby pointing to the visible label, none of the standard label association patterns apply. Prefer the native <select> element wherever possible — it carries all required implicit accessibility semantics.",
      "manual_test": {
        "description": "Focus the select and verify the screen reader announces its label.",
        "steps": [
          "Tab to the <select> with VoiceOver or NVDA active.",
          "The announcement must include both the label name and 'combo box' role.",
          "Click the label text — focus must move to the select input."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "The same label association pattern applies — fix label rule to resolve both."
        }
      ]
    },
    "server-side-image-map": {
      "fix": {
        "description": "Replace server-side image maps (using ismap on <img>) with client-side image maps (<map> + <area>) or alternative navigation that does not depend on precise pointer coordinates.",
        "code": "<!-- Before: server-side image map (inaccessible) -->\n<a href=\"/map-handler\">\n  <img src=\"navigation.png\" ismap alt=\"Site navigation\">\n</a>\n\n<!-- After: client-side image map with alt text per area -->\n<img src=\"navigation.png\" usemap=\"#nav-map\" alt=\"Site navigation\">\n<map name=\"nav-map\">\n  <area shape=\"rect\" coords=\"0,0,100,50\" href=\"/home\" alt=\"Home\">\n  <area shape=\"rect\" coords=\"100,0,200,50\" href=\"/about\" alt=\"About\">\n  <area shape=\"rect\" coords=\"200,0,300,50\" href=\"/contact\" alt=\"Contact\">\n</map>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Server-side image maps are extremely rare in React applications. If the ismap attribute is present on an <img>, replace the entire pattern with individual <Link> components styled with CSS Grid or positioned over the image. This is more maintainable and accessible.",
        "vue": "In Vue, replace server-side image maps with positioned <router-link> components or a client-side <map>. Server-side image maps send cursor coordinates to the server, which is incompatible with SPA routing.",
        "angular": "In Angular, replace the ismap pattern with Angular Router links positioned over the image, or use a client-side <map> with <area> elements. Server-side coordinate handling is incompatible with Angular's client-side routing."
      },
      "fix_difficulty_notes": "Server-side image maps send mouse click coordinates to the server, which determines the action. This is completely inaccessible to keyboard users (no coordinates are sent with Enter key) and screen reader users (no alternative text for regions). The fix: replace with a client-side image map (<map>/<area>) with alt text per area, or better yet, replace with individual links positioned via CSS.",
      "manual_test": {
        "description": "Verify the image map can be navigated and activated using only the keyboard.",
        "steps": [
          "Search the HTML source for ismap on any <img> element — it should not be present.",
          "If a client-side image map is used instead, Tab through each <area> and verify it receives focus and has an accessible name.",
          "Activate each area with Enter — verify it navigates to the correct destination."
        ]
      },
      "related_rules": [
        {
          "id": "area-alt",
          "reason": "If replacing with a client-side image map, ensure every <area> has alt text."
        }
      ]
    },
    "skip-link": {
      "fix": {
        "description": "Ensure all skip links have a focusable target. A skip link (typically 'Skip to main content') must point to an element that exists in the DOM and can receive focus, usually the <main> element with an id attribute.",
        "code": "<!-- Skip link in the header: -->\n<body>\n  <a href=\"#main-content\" class=\"skip-link\">Skip to main content</a>\n  <header>...</header>\n  <main id=\"main-content\" tabindex=\"-1\">\n    <h1>Page title</h1>\n    ...\n  </main>\n  <footer>...</footer>\n</body>\n\n<!-- CSS for visually hidden skip link (visible on focus): -->\n<!--\n.skip-link {\n  position: absolute;\n  left: -9999px;\n  top: auto;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n}\n.skip-link:focus {\n  position: static;\n  width: auto;\n  height: auto;\n  overflow: visible;\n  padding: 0.5rem 1rem;\n  background: #000;\n  color: #fff;\n  z-index: 9999;\n}\n-->"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In Next.js App Router, add the skip link in the root layout.tsx before <header>. Set tabIndex={-1} on <main id='main-content'> so it can receive focus when the skip link is activated. Some browsers require tabindex='-1' for non-interactive elements to be focusable via fragment navigation.",
        "vue": "In Nuxt, add the skip link in layouts/default.vue before <header>. Add tabindex='-1' and id='main-content' to the <main> element. Ensure the skip link is the first focusable element in the DOM.",
        "angular": "In Angular, add the skip link in app.component.html before <header>. Use [tabIndex]='-1' on <main id='main-content'>. Angular's router may re-render the main content area on navigation — ensure the id persists across route changes."
      },
      "fix_difficulty_notes": "The skip link target must meet two conditions: (1) the element with the matching id must exist in the DOM, and (2) it must be focusable. Native interactive elements are focusable by default; non-interactive elements like <main> or <div> require tabindex='-1' to receive programmatic focus. In SPAs, the target element may not exist during initial render if content is loaded asynchronously — ensure the target is rendered before the skip link can be activated.",
      "manual_test": {
        "description": "Activate the skip link and verify focus moves to the main content area.",
        "steps": [
          "Press Tab on page load — the skip link should be the first focusable element and become visible.",
          "Press Enter on the skip link — focus must move to the main content area.",
          "Verify the next Tab press moves to the first interactive element inside <main>, not back to the header.",
          "With a screen reader active, confirm the skip link target is announced when focus arrives."
        ]
      },
      "related_rules": [
        {
          "id": "bypass",
          "reason": "Skip links are the primary mechanism for satisfying the bypass blocks requirement (WCAG 2.4.1)."
        },
        {
          "id": "landmark-one-main",
          "reason": "The skip link target should be the <main> landmark — ensure it exists and has the correct id."
        },
        {
          "id": "region",
          "reason": "Proper landmark regions reduce the need for skip links but do not replace them — both mechanisms should coexist."
        }
      ]
    },
    "summary-name": {
      "fix": {
        "description": "Every <summary> element must have discernible text content so screen readers can announce its purpose. The <summary> serves as the visible heading and toggle control for a <details> disclosure widget.",
        "code": "<!-- Before: empty summary -->\n<details>\n  <summary></summary>\n  <p>Additional information here.</p>\n</details>\n\n<!-- After: summary with descriptive text -->\n<details>\n  <summary>More information about shipping</summary>\n  <p>We offer free shipping on orders over $50.</p>\n</details>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, <summary> elements with dynamic content like <summary>{title}</summary> render empty if title is undefined. Guard with: {title && <details><summary>{title}</summary>...</details>}. Accordion components (Radix Collapsible, Headless UI Disclosure) manage this automatically.",
        "vue": "In Vue, <summary>{{ title }}</summary> renders empty if title is falsy. Use v-if='title' on the <details> or provide a fallback string. Headless UI and PrimeVue accordion components handle this internally.",
        "angular": "In Angular, <summary>{{ title }}</summary> renders empty if title is undefined. Use *ngIf='title' on the <details> element or provide a default string. Angular CDK Accordion manages accessible names automatically."
      },
      "fix_difficulty_notes": "The fix is to add descriptive text content to the <summary> element. In CMS-driven content, the issue often occurs when an author creates a <details> block but leaves the summary empty. The text should describe what the disclosure widget reveals when expanded — not a generic label like 'Details' or 'More'.",
      "manual_test": {
        "description": "Navigate to the <details> widget with a screen reader and verify the summary is announced.",
        "steps": [
          "Tab to the <summary> element — the screen reader should announce its text and role (e.g., 'More information about shipping, summary, collapsed').",
          "Press Enter or Space to expand — the state change should be announced ('expanded').",
          "If the summary is empty, the screen reader announces only the role without a label."
        ]
      }
    },
    "svg-img-alt": {
      "fix": {
        "description": "Add an accessible name to informative SVGs using role='img' and aria-label. For decorative SVGs, use aria-hidden='true'.",
        "code": "<!-- Informative SVG (icon conveying meaning): -->\n<svg role=\"img\" aria-label=\"Shopping cart — 3 items\" focusable=\"false\">\n  <!-- svg paths -->\n</svg>\n\n<!-- Decorative SVG (visual only, adjacent text explains it): -->\n<svg aria-hidden=\"true\" focusable=\"false\">\n  <!-- svg paths -->\n</svg>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, SVG components commonly strip accessibility attributes. Add role='img' and aria-label directly on the <svg> element: <svg role='img' aria-label='Close' aria-hidden={undefined}>. Icon libraries like Heroicons and Lucide expose aria-hidden and aria-label props.",
        "vue": "In Vue, pass aria-hidden='true' or aria-label as attributes on the <svg> component. Most Vue icon libraries (unplugin-icons, vue-feather) accept these as standard HTML attributes.",
        "angular": "In Angular Material, <mat-icon> renders an SVG or ligature — it sets aria-hidden by default. For standalone SVG components, use [attr.aria-label]='label' and [attr.aria-hidden]='isDecorative'."
      },
      "fix_difficulty_notes": "Most SVGs in UI are decorative (icons next to visible button text, background illustrations). axe may flag them as missing an alt even when the adjacent text is sufficient. The decision is: does this SVG convey meaning that is NOT expressed in adjacent visible text? If yes → aria-label. If no → aria-hidden='true'. Never add aria-label that duplicates adjacent text — this creates redundant announcements.",
      "manual_test": {
        "description": "Determine whether each SVG communicates content not expressed in adjacent text.",
        "steps": [
          "Tab to each SVG in the page — with VoiceOver or NVDA active, note what is announced.",
          "If the SVG is informative and nothing is announced, aria-label is missing.",
          "If the SVG is decorative and its label is read aloud (duplicating adjacent text), add aria-hidden='true'.",
          "Check SVG children: <title> inside an SVG provides an accessible name in some browsers/AT combinations — verify it is reliably picked up before relying on it."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The same alt text requirement applies to <img> — fix all alt text violations together."
        },
        {
          "id": "image-redundant-alt",
          "reason": "When adding aria-label to SVGs, avoid duplicating visible adjacent text."
        },
        {
          "id": "input-image-alt",
          "reason": "The same alt text requirement applies to <input type=\"image\"> — fix all alt text violations together."
        },
        {
          "id": "role-img-alt",
          "reason": "svg-img-alt specifically targets SVG elements with role='img' — they overlap with this rule."
        }
      ]
    },
    "tabindex": {
      "fix": {
        "description": "Remove positive tabindex values. Use tabindex=\"0\" to include in natural tab order, tabindex=\"-1\" to exclude.",
        "code": "<!-- Include in natural tab order: -->\n<div role=\"button\" tabindex=\"0\">Focusable element</div>\n<!-- Programmatically focusable only: -->\n<div tabindex=\"-1\">Focus via script only</div>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In JSX, the attribute is camelCase: tabIndex={0} or tabIndex={-1}. Never use positive integers. For programmatically managed focus (e.g., opening a modal), call element.focus() instead of relying on tabIndex values greater than 0.",
        "vue": "Use :tabindex='0' or tabindex='-1' in Vue templates. Do not expose a tabindex prop that accepts positive integers — validate the value at the component level.",
        "angular": "Use [tabIndex]='value' for dynamic binding, ensuring only 0 or -1 are bound. The Angular CDK FocusTrap handles sequential focus management within dialogs without requiring positive tabindex values."
      },
      "fix_difficulty_notes": "Positive tabindex values (tabindex='1', tabindex='2') create a separate focus sequence that runs before the natural DOM order. All positive-tabindex elements are visited first, then everything else. This almost always breaks focus flow. Remove all positive tabindex values and reorder the DOM instead if a different focus sequence is needed.",
      "manual_test": {
        "description": "Tab through the page and verify focus order matches visual reading order.",
        "steps": [
          "Press Tab repeatedly from the top of the page — focus must move top-to-bottom, left-to-right.",
          "If focus jumps unexpectedly, inspect the tabindex attribute on the focused element.",
          "Confirm no element has tabindex > 0 in the source."
        ]
      },
      "related_rules": [
        {
          "id": "focus-order-semantics",
          "reason": "Both rules address focus order issues — fix tabindex values and semantic roles together."
        }
      ]
    },
    "table-duplicate-name": {
      "fix": {
        "description": "Remove the summary attribute or change the caption text so the table caption and summary do not contain the same text.",
        "code": "<!-- Remove summary entirely (deprecated in HTML5) -->\n<table>\n  <caption>Sales data by region and quarter — columns are quarters Q1–Q4, rows are regions</caption>\n  ...\n</table>\n\n<!-- Or if summary must remain, use different text: -->\n<table summary=\"Use arrow keys to navigate rows and columns.\">\n  <caption>Sales data by region and quarter</caption>\n  ...\n</table>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React table components, avoid passing both caption and summary props with the same content. Remove the summary attribute entirely — it is deprecated.",
        "vue": "In Vue, do not bind :summary on <table>. Use <caption> for all table descriptions.",
        "angular": "In Angular, remove [attr.summary] bindings from table components. Migrate to <caption> with descriptive text or aria-describedby pointing to an adjacent description."
      },
      "fix_difficulty_notes": "The summary attribute is deprecated in HTML5 and should not be used in new code. The preferred pattern is to put all necessary description in the <caption> element. If legacy code uses both, the simplest fix is to remove the summary attribute entirely. For complex tables requiring navigation instructions, use aria-describedby pointing to a visible description paragraph adjacent to the table.",
      "manual_test": {
        "description": "Navigate to the table with a screen reader and verify the table description is announced only once.",
        "steps": [
          "Move screen reader focus into the table — the AT will announce the caption and/or summary.",
          "If the same text is announced twice in sequence, both caption and summary are set identically.",
          "Inspect the <table> element in DevTools for both a <caption> child and a summary attribute — remove the summary."
        ]
      },
      "related_rules": [
        {
          "id": "table-fake-caption",
          "reason": "If both a <caption> and aria-label exist, they must not duplicate each other."
        }
      ]
    },
    "table-fake-caption": {
      "fix": {
        "description": "Tables that use the first row as a visual caption must use the <caption> element instead. A row spanning all columns to simulate a caption is not accessible — screen readers do not associate it with the table as a label.",
        "code": "<!-- Before: fake caption using first row -->\n<table>\n  <tr>\n    <td colspan=\"3\"><strong>Quarterly Sales</strong></td>\n  </tr>\n  <tr>\n    <th>Region</th><th>Q1</th><th>Q2</th>\n  </tr>\n  <tr>\n    <td>North</td><td>$100k</td><td>$120k</td>\n  </tr>\n</table>\n\n<!-- After: proper caption element -->\n<table>\n  <caption>Quarterly Sales</caption>\n  <thead>\n    <tr>\n      <th>Region</th><th>Q1</th><th>Q2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>North</td><td>$100k</td><td>$120k</td>\n    </tr>\n  </tbody>\n</table>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React table components, add a <caption> element as the first child of <table>. UI libraries (Tanstack Table, AG Grid React) may not render a <caption> by default — add it manually in the table wrapper or use the library's caption/title slot.",
        "vue": "In Vue, add <caption> as the first child of the <table> element in your template. Vuetify's v-data-table uses a title slot — configure it to render as a proper <caption> for data tables.",
        "angular": "In Angular Material, mat-table does not include a <caption> element by default. Add a <caption> element inside the <table mat-table> element. For CDK Table, include the <caption> in the table template."
      },
      "fix_difficulty_notes": "The <caption> element must be the first child of <table>. It is announced by screen readers as the table's name, enabling users to understand the table's purpose before navigating its cells. CSS can be used to style or visually reposition the caption (caption-side: bottom). Never use visibility:hidden or display:none — use the sr-only/visually-hidden pattern if the caption must be visible only to AT.",
      "manual_test": {
        "description": "Navigate to the table with a screen reader and verify the caption is announced as the table label.",
        "steps": [
          "Navigate to the table — the screen reader should announce the caption, row count, and column count (e.g., 'Quarterly Sales, table with 3 rows and 3 columns').",
          "If the table is announced without a name, the <caption> is missing or incorrectly placed.",
          "Verify the first data row is not being used as a visual-only caption."
        ]
      },
      "related_rules": [
        {
          "id": "table-duplicate-name",
          "reason": "If both a <caption> and aria-label exist, they must not duplicate each other."
        }
      ]
    },
    "target-size": {
      "fix": {
        "description": "Interactive elements must have a minimum target size of 24×24 CSS pixels (WCAG 2.5.8). Larger targets (44×44 px) are recommended for touch interfaces.",
        "code": "/* Minimum WCAG 2.2 AA target size */\n.btn, a, [role=\"button\"] {\n  min-width: 24px;\n  min-height: 24px;\n}\n\n/* Recommended for touch: */\n.btn {\n  min-width: 44px;\n  min-height: 44px;\n  padding: 0.5rem 1rem;\n}"
      },
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "WCAG 2.5.8 provides an exception for inline text links within a sentence (e.g., 'see our privacy policy') where sufficient spacing around the link satisfies the criterion. axe may flag these — verify whether the exception applies before adding padding that could break the text flow.",
      "manual_test": {
        "description": "Measure the rendered size of small interactive elements — CSS values alone can be misleading.",
        "steps": [
          "In DevTools, inspect icon-only buttons, checkboxes, and radio inputs.",
          "Check the computed width and height including padding in the Box Model panel.",
          "On a touch device or with DevTools device emulation, attempt to tap small targets to confirm they are hittable."
        ]
      }
    },
    "td-has-header": {
      "fix": {
        "description": "In data tables with more than one row and column, every non-empty <td> must be associated with a <th> header cell. Use <th> elements for column and row headers, and scope or headers attributes for complex tables.",
        "code": "<!-- Simple table: use <th> with scope -->\n<table>\n  <caption>Employee Directory</caption>\n  <thead>\n    <tr>\n      <th scope=\"col\">Name</th>\n      <th scope=\"col\">Department</th>\n      <th scope=\"col\">Extension</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Jane Doe</td>\n      <td>Engineering</td>\n      <td>1234</td>\n    </tr>\n  </tbody>\n</table>\n\n<!-- Complex table with row and column headers -->\n<table>\n  <caption>Quarterly Revenue</caption>\n  <thead>\n    <tr><th></th><th scope=\"col\">Q1</th><th scope=\"col\">Q2</th></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th scope=\"row\">North</th><td>$100k</td><td>$120k</td>\n    </tr>\n  </tbody>\n</table>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, dynamic table components must render <th> elements for headers, not <td> with styling. Use scope='col' on column headers and scope='row' on row headers. Tanstack Table renders headers as <th> by default — verify the rendered output.",
        "vue": "In Vue, ensure the table header row uses <th> not <td>. Vuetify's v-data-table renders column headers as <th> automatically. For custom tables, add scope='col' to each <th> in the <thead>.",
        "angular": "Angular Material's mat-table uses mat-header-cell, which renders as <th> with role='columnheader'. Verify the rendered HTML includes proper scope attributes. For native HTML tables in Angular, add scope='col' or scope='row' to <th> elements."
      },
      "fix_difficulty_notes": "This rule triggers on 'large' tables (more than 3 rows and 3 columns) where data cells are not associated with headers. The most common fix: convert the first row from <td> to <th scope='col'> and the first column from <td> to <th scope='row'>. For complex tables with multi-level headers, use the headers attribute on <td> to explicitly reference <th id> values. Avoid merged cells (colspan/rowspan) when possible — they complicate header association significantly.",
      "manual_test": {
        "description": "Navigate the table with a screen reader and verify each data cell announces its associated headers.",
        "steps": [
          "Enter the table with a screen reader and navigate cell by cell using table navigation keys (Ctrl+Alt+Arrow in NVDA).",
          "Each data cell must announce its column header (and row header, if applicable) before the cell content.",
          "If headers are not announced, add <th> elements with appropriate scope attributes."
        ]
      },
      "related_rules": [
        {
          "id": "th-has-data-cells",
          "reason": "th-has-data-cells verifies headers have associated data; td-has-header verifies data cells have associated headers — fix both together."
        },
        {
          "id": "td-headers-attr",
          "reason": "For complex tables, the headers attribute on <td> must reference valid <th> id values."
        }
      ]
    },
    "td-headers-attr": {
      "fix": {
        "description": "Ensure every ID referenced in a td's headers attribute matches an existing th element in the same table.",
        "code": "<table>\n  <thead>\n    <tr>\n      <th id=\"col-name\">Name</th>\n      <th id=\"col-dept\">Department</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td headers=\"col-name\">Alice</td>\n      <td headers=\"col-dept\">Engineering</td>\n    </tr>\n  </tbody>\n</table>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, generate table IDs programmatically: const colId = `col-${column.key}`; <th id={colId}> and <td headers={colId}>. Ensure IDs are unique if multiple table instances render on the same page.",
        "vue": "In Vue, bind unique IDs: :id='`col-${col.key}`' on <th> and :headers='`col-${col.key}`' on <td>. Use a table-scoped unique prefix if multiple tables exist.",
        "angular": "In Angular, generate IDs in the component: colId = (col: Column) => `col-${col.key}`; and bind [attr.id]='colId(col)' on th and [attr.headers]='colId(col)' on td."
      },
      "fix_difficulty_notes": "The headers attribute is only needed for complex tables where a single cell spans multiple headers or the column/row relationship is ambiguous. For simple tables (one header row, one header column), use <th scope='col'> and <th scope='row'> instead — it is simpler and better supported across AT. Only use the headers attribute when scope is insufficient.",
      "manual_test": {
        "description": "Navigate a complex table with a screen reader and verify column/row headers are announced for each cell.",
        "steps": [
          "Navigate into a table cell with NVDA or JAWS — the AT must announce the associated column and row header.",
          "In DevTools, inspect each <td headers='...'> — confirm every referenced ID exists as a <th id='...'> in the same table.",
          "For simple tables, verify <th scope='col'> and <th scope='row'> are used instead of the headers attribute."
        ]
      },
      "related_rules": [
        {
          "id": "th-has-data-cells",
          "reason": "Fix td-headers-attr and th-has-data-cells together — they are complementary table structure rules."
        },
        {
          "id": "empty-table-header",
          "reason": "The headers attribute references <th> elements by id — empty headers make these references meaningless."
        },
        {
          "id": "scope-attr-valid",
          "reason": "For complex tables where scope is insufficient, the headers attribute on <td> provides explicit header associations."
        },
        {
          "id": "td-has-header",
          "reason": "For complex tables, the headers attribute on <td> must reference valid <th> id values."
        }
      ]
    },
    "th-has-data-cells": {
      "fix": {
        "description": "Ensure every <th> element has at least one associated data cell (<td>). Remove header cells for empty columns or convert them to <td> if they contain data rather than labels.",
        "code": "<table>\n  <thead>\n    <tr>\n      <th scope=\"col\">Name</th>\n      <th scope=\"col\">Role</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Alice</td>\n      <td>Engineer</td>\n    </tr>\n  </tbody>\n</table>"
      },
      "false_positive_risk": "medium",
      "framework_notes": {
        "react": "In React, render a fallback when the data array is empty: if (!rows.length) return <p>No results found.</p>. Do not render the <table> with headers and an empty <tbody>.",
        "vue": "In Vue, use v-if='rows.length' on the <table> element. Provide an empty-state <p> or <div> with v-else outside the table.",
        "angular": "In Angular, use *ngIf='rows.length' on the <table> element and provide an alternative empty-state template with *ngIf='!rows.length'."
      },
      "fix_difficulty_notes": "This rule commonly fires on dynamically rendered tables that show an empty state (loading spinner or 'No data' row). axe flags the <th> elements as having no data cells when the table body is empty or renders a colspan'd message. Guard the table to only display headers when data is present, or use a non-table element for the empty state.",
      "manual_test": {
        "description": "Verify every column and row header has corresponding data cells in the rendered table.",
        "steps": [
          "Inspect the table in DevTools — count <th> elements in the header row and confirm the same number of columns exist in each data row.",
          "Navigate into each cell with a screen reader — the AT must announce the associated header for every data cell.",
          "Check tables rendered in an empty state — if <th> headers exist but <tbody> is empty, the violation is present."
        ]
      },
      "related_rules": [
        {
          "id": "td-headers-attr",
          "reason": "Fix table structure rules together — td-headers-attr and th-has-data-cells are complementary."
        },
        {
          "id": "empty-table-header",
          "reason": "Headers without text and headers without associated data cells are related structural issues — fix together."
        },
        {
          "id": "scope-attr-valid",
          "reason": "Headers must have data cells associated with them — fix scope and header-data relationships together."
        },
        {
          "id": "td-has-header",
          "reason": "th-has-data-cells verifies headers have associated data; td-has-header verifies data cells have associated headers — fix both together."
        }
      ]
    },
    "valid-lang": {
      "fix": {
        "description": "Use a valid BCP 47 language code on any element with a lang attribute.",
        "code": "<p lang=\"es\">Hola mundo</p>\n<blockquote lang=\"fr\">Citation en français</blockquote>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "Add the lang attribute to HTML elements in JSX: <p lang='es'>Hola</p>. Works identically to plain HTML — no special React syntax needed.",
        "vue": "Use lang='es' as a standard attribute in Vue templates. For dynamic language content, bind it: <p :lang='contentLang'>{{ text }}</p>.",
        "angular": "Use [attr.lang]='locale' for dynamic language switching on inline content, or lang='es' as a static attribute for fixed foreign-language passages."
      },
      "fix_difficulty_notes": "This rule checks inline lang attributes on child elements (e.g., <p lang='es'>), not the root <html>. The most common mistake is copying locale codes from i18n libraries (e.g., 'en_US' with underscore) — only hyphenated BCP 47 tags are valid (e.g., 'en-US', 'es', 'fr-CA'). Verify each value against https://www.iana.org/assignments/language-subtag-registry/.",
      "manual_test": {
        "description": "Verify inline language switches are recognised by a screen reader.",
        "steps": [
          "Search source files for lang= attributes on elements other than <html>.",
          "Confirm each value is a valid BCP 47 tag (e.g. 'es', 'fr-CA', 'pt-BR').",
          "With a screen reader, navigate over the inline foreign-language text — the voice should switch languages."
        ]
      },
      "related_rules": [
        {
          "id": "html-has-lang",
          "reason": "The root <html> lang attribute must be set before child lang attributes are meaningful."
        },
        {
          "id": "html-lang-valid",
          "reason": "The same BCP 47 validity requirement applies to the root lang attribute."
        }
      ]
    },
    "video-caption": {
      "fix": {
        "description": "Add a <track kind='captions'> inside every <video> element. Captions must cover all speech and meaningful audio.",
        "code": "<video controls>\n  <source src=\"presentation.mp4\" type=\"video/mp4\">\n  <track kind=\"captions\" src=\"presentation.vtt\" srclang=\"en\" label=\"English\" default>\n  <track kind=\"captions\" src=\"presentation-es.vtt\" srclang=\"es\" label=\"Español\">\n</video>"
      },
      "false_positive_risk": "low",
      "framework_notes": {
        "react": "In React, include <track> as a child of <video>. React warns if <track> lacks a key prop when rendered in a list. Use the crossOrigin prop (camelCase) if serving captions from a different domain.",
        "vue": "In Vue, nest <track> inside <video> in the template. For dynamically loaded captions, use :src='captionUrl'. Note that Vue does not reload <track> on src change alone — recreate the video element when switching sources.",
        "angular": "In Angular, include static or dynamic <track> elements inside the <video> template. For dynamically switching caption languages, use [attr.src] binding and reload the video source programmatically."
      },
      "fix_difficulty_notes": "axe cannot verify whether existing captions are accurate or synchronized — it only detects the presence of a <track kind='captions'> element. A <track> pointing to an empty or inaccurate VTT file technically passes axe but still violates WCAG 1.2.2. Always review caption content manually. For YouTube/Vimeo embeds inside <iframe>, this rule does not apply — the embedded player's caption controls are the platform's responsibility.",
      "manual_test": {
        "description": "Play the video with captions enabled and verify all spoken content is accurately captioned.",
        "steps": [
          "Enable captions in the player and play the full video — verify all dialogue, narration, and meaningful sound effects are captioned.",
          "Confirm captions are synchronized — they must appear when the corresponding audio plays.",
          "For third-party embeds (YouTube, Vimeo), verify the embed enables captions by default via URL parameters."
        ]
      },
      "related_rules": [
        {
          "id": "audio-caption",
          "reason": "Both require media captions — fix all media accessibility violations together."
        }
      ]
    }
  }
}
