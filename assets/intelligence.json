{
  "rules": {
    "accessible-auth-minimum": {
      "fix": {
        "description": "Authentication must not require solving a cognitive test (CAPTCHA, puzzle, memorization) without providing an accessible alternative (WCAG 3.3.8).",
        "code": "<!-- Option 1: Offer an audio CAPTCHA alternative -->\n<div class=\"captcha-group\">\n  <img src=\"captcha.png\" alt=\"Enter the characters shown\">\n  <a href=\"/audio-captcha\">Use audio CAPTCHA instead</a>\n</div>\n\n<!-- Option 2: Use passkeys (no cognitive test required) -->\n<button type=\"button\" onclick=\"authenticateWithPasskey()\">\n  Sign in with passkey\n</button>"
      },
      "effort": "high",
      "impacted_users": "Users with cognitive disabilities (dyslexia, memory impairments)",
      "expected": "Authentication processes must not require solving a cognitive function test without providing an accessible alternative method (WCAG 3.3.8).",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "Automated tools can detect the presence of a CAPTCHA but cannot verify whether an accessible alternative is functional. Treat findings as a prompt for manual review. The WCAG 3.3.8 exception allows cognitive tests if an accessible alternative (audio CAPTCHA, passkey, magic link, email OTP) is offered alongside.",
      "framework_notes": {
        "react": "When using NextAuth.js, prefer magic link (email provider) or passkey authentication — these eliminate cognitive tests entirely. If CAPTCHA is required, use hCaptcha with accessibility mode enabled, or Google reCAPTCHA v3 (which requires no user interaction).",
        "vue": "In Nuxt, @nuxtjs/auth-next supports email magic links and OAuth providers — both are more accessible than CAPTCHA-based flows. For CAPTCHA, hCaptcha offers an accessible challenge alternative.",
        "angular": "In Angular apps using Auth0 or Firebase Auth, enable passwordless (magic link) or passkey authentication. If CAPTCHA is required, integrate hCaptcha with its accessibility challenge option, which provides audio and visual alternatives."
      },
      "manual_test": {
        "description": "Attempt to complete authentication using only a screen reader and no visual CAPTCHA solving.",
        "steps": [
          "Navigate to the login page with VoiceOver active.",
          "If a CAPTCHA is present, verify an audio alternative is offered and functional.",
          "Attempt login using passkey or magic link — no cognitive puzzle should be required."
        ]
      }
    },
    "aria-hidden-focus": {
      "fix": {
        "description": "Remove aria-hidden=\"true\" from elements that can receive focus, or exclude them from the tab order.",
        "code": "<!-- Option 1: Remove aria-hidden -->\n<button>Visible button</button>\n<!-- Option 2: Keep hidden but remove from tab order -->\n<span aria-hidden=\"true\" tabindex=\"-1\">Decorative text</span>"
      },
      "effort": "low",
      "impacted_users": "Keyboard-only users and screen reader users",
      "expected": "Elements with aria-hidden=\"true\" must not be focusable.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Setting aria-hidden='true' on a parent hides all its descendants from AT but does not remove their keyboard focusability. Interactive children (buttons, links, inputs) inside an aria-hidden container will still receive Tab focus, creating 'ghost focus'. Apply tabindex='-1' to each interactive descendant, or restructure so no focusable elements exist inside the aria-hidden container.",
      "framework_notes": {
        "react": "In React portals (modals, dialogs, tooltips), aria-hidden='true' is commonly applied to the app root during open state. Ensure portals render outside the aria-hidden subtree (e.g., appended to <body>). Libraries like Radix UI handle this correctly via the inert attribute and portal rendering.",
        "vue": "In Vue with Teleport, the teleported content renders outside the component's DOM subtree — verify the Teleport target element (e.g., #teleport-target or body) is not inside an aria-hidden container.",
        "angular": "Angular CDK Overlay (used by Material dialogs and menus) renders at the body level, outside aria-hidden scopes. Verify that aria-hidden is applied to the correct host element — not to a container that includes the CDK overlay outlet."
      },
      "manual_test": {
        "description": "Tab into the flagged element and verify a screen reader either announces it or skips it cleanly.",
        "steps": [
          "Tab to the element — if focus reaches it while aria-hidden=\"true\" is set, the fix is needed.",
          "After fix: Tab through the area again — the element should either be announced (aria-hidden removed) or completely skipped (tabindex=-1 added).",
          "With VoiceOver or NVDA active, confirm no 'ghost' announcement occurs."
        ]
      },
      "related_rules": [
        {
          "id": "scrollable-region-focusable",
          "reason": "Both affect keyboard focus — audit all focusability violations together to avoid conflicts."
        }
      ]
    },
    "aria-input-field-name": {
      "fix": {
        "description": "Add an accessible name to ARIA input fields (role='textbox', role='searchbox', role='spinbutton', role='slider', role='combobox') via aria-label or aria-labelledby.",
        "code": "<!-- ARIA textbox with aria-labelledby: -->\n<span id=\"search-label\">Search</span>\n<div role=\"textbox\" contenteditable=\"true\"\n  aria-labelledby=\"search-label\"\n  aria-multiline=\"false\">\n</div>\n\n<!-- Prefer native input (simpler, better AT support): -->\n<label for=\"search\">Search</label>\n<input type=\"search\" id=\"search\">"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "ARIA input roles (textbox, searchbox, spinbutton, slider, combobox) must have an accessible name.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The best fix is almost always to replace the ARIA input with a native HTML input — native elements have implicit roles, built-in keyboard support, and do not require manual ARIA attribute management. Use ARIA input roles only when a native equivalent is technically impossible (e.g., a rich text editor with contenteditable).",
      "framework_notes": {
        "react": "Rich text editors (Draft.js, Slate, Quill) use contenteditable divs with role='textbox'. Ensure the editor component exposes an aria-label prop and applies it to the root contenteditable element. For standard inputs, always use <label htmlFor='id'>.",
        "vue": "WYSIWYG editor components (Tiptap, Quill) wrap role='textbox' elements. Pass aria-label via the component's label prop. For standard inputs, use <label :for='id'>.",
        "angular": "Angular CDK or ProseMirror-based editors use contenteditable with ARIA roles. Bind [attr.aria-label]='editorLabel' on the root element. For standard inputs, use mat-label or <label [for]='id'>."
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "If a native input can replace the ARIA input, the standard label association pattern resolves both."
        },
        {
          "id": "aria-toggle-field-name",
          "reason": "Fix all ARIA field naming violations together — they share the same accessible name patterns."
        }
      ],
      "manual_test": {
        "description": "Tab to the ARIA input and verify the screen reader announces both the label and its role.",
        "steps": [
          "Tab to the element — the AT must announce the label and role (e.g., 'Search, text field').",
          "Type into the field — typed characters must be echoed by the screen reader.",
          "For custom editors, verify aria-multiline is set correctly ('true' for multiline, 'false' for single-line)."
        ]
      }
    },
    "aria-prohibited-attr": {
      "fix": {
        "description": "Remove ARIA attributes that are prohibited for the element's role. Each ARIA role has a defined set of allowed attributes — attributes outside that set are ignored or cause incorrect AT behavior.",
        "code": "<!-- aria-label is prohibited on role='presentation' and role='none' -->\n<!-- Before: -->\n<div role=\"none\" aria-label=\"Section wrapper\">...</div>\n<!-- After: -->\n<div>...</div>\n\n<!-- aria-checked is prohibited on role='button' -->\n<!-- Before: -->\n<button role=\"button\" aria-checked=\"true\">Toggle</button>\n<!-- After (use role='switch' for toggle state): -->\n<button role=\"switch\" aria-checked=\"true\">Toggle</button>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users",
      "expected": "ARIA attributes must only be used on roles that allow them per the WAI-ARIA specification.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The most common case is aria-label on role='none' or role='presentation' — the role explicitly removes the element from the accessibility tree, so any ARIA attribute on it has no effect (and axe flags it). Also common: adding aria-expanded or aria-checked to a plain <button> role instead of using role='switch' or role='menuitemcheckbox'. Consult https://www.w3.org/TR/wai-aria/#role_definitions for the 'Inherited States and Properties' list per role.",
      "framework_notes": {
        "react": "In React, ARIA attributes are passed as JSX props — there is no compile-time check for prohibited combinations. Use eslint-plugin-jsx-a11y, which includes the aria-prhibited-attr rule to catch these at build time.",
        "vue": "In Vue, ARIA attributes are standard HTML attributes — no framework-level check exists. Use eslint-plugin-vue with vue/no-aria-hidden-on-focusable or similar lint rules.",
        "angular": "In Angular, no built-in check prevents prohibited ARIA combinations. The Angular CDK a11y lint rules (via @angular-eslint) flag some cases — enable them in .eslintrc."
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "Often co-located — fix the role first, then verify required attributes are present and prohibited ones are removed."
        },
        {
          "id": "aria-valid-attr-value",
          "reason": "After fixing prohibited attrs, check that remaining ARIA attribute values are valid tokens."
        }
      ],
      "manual_test": {
        "description": "Verify ARIA attributes on the flagged element are permitted by its role.",
        "steps": [
          "Inspect the flagged element in DevTools — note its role (explicit or implicit) and all aria-* attributes.",
          "Look up the role in the WAI-ARIA spec (https://www.w3.org/TR/wai-aria/#role_definitions) and find its 'Supported States and Properties' list.",
          "Remove any attribute not listed. If the attribute is semantically needed, switch to a role that supports it."
        ]
      }
    },
    "aria-required-attr": {
      "fix": {
        "description": "Add the required ARIA attribute(s) for the element's role. See the WAI-ARIA spec for required attributes per role.",
        "code": "<!-- combobox requires: aria-expanded + aria-controls -->\n<div role=\"combobox\" aria-expanded=\"false\" aria-controls=\"listbox-id\" aria-haspopup=\"listbox\">\n  <input type=\"text\" aria-autocomplete=\"list\">\n</div>\n<ul role=\"listbox\" id=\"listbox-id\">...</ul>\n\n<!-- scrollbar requires: aria-controls + aria-valuenow + aria-valuemin + aria-valuemax -->\n<div role=\"scrollbar\" aria-controls=\"scrollable-region\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"100\"></div>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users",
      "expected": "ARIA roles must include all required attributes defined in the WAI-ARIA spec.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Required attributes vary per role — consult https://www.w3.org/TR/wai-aria/#role_definitions. The most frequent mistake: using role='combobox' without aria-expanded, or role='slider' without aria-valuenow/aria-valuemin/aria-valuemax. When in doubt, prefer native HTML elements (e.g., <select> instead of role='listbox') which carry implicit semantics.",
      "framework_notes": {
        "react": "Headless component libraries (Radix UI, Headless UI, Ark UI) handle required ARIA attributes internally — do not duplicate or override them. If building a custom ARIA widget from scratch, consult the WAI-ARIA spec for each role's required attributes before binding props.",
        "vue": "Floating Vue, Headless UI for Vue, and Vuetify manage ARIA attributes internally. Only add ARIA attributes when building custom widgets. Binding incorrect or unsupported attributes can introduce new violations rather than fixing existing ones.",
        "angular": "Angular CDK's a11y module (FocusTrap, ListKeyManager, ActiveDescendantKeyManager) manages required ARIA attributes for composite widgets. Use these utilities before building custom ARIA widgets from scratch."
      },
      "manual_test": {
        "description": "Verify the ARIA widget is fully operable by a screen reader after adding the required attributes.",
        "steps": [
          "Locate the flagged element in DevTools and read its role attribute.",
          "Cross-reference the WAI-ARIA spec (https://www.w3.org/TR/wai-aria/) for required attributes of that role.",
          "Tab to the element with a screen reader active — confirm all state information (expanded, selected, etc.) is announced."
        ]
      },
      "related_rules": [
        {
          "id": "aria-roles",
          "reason": "An invalid role is often the root cause of missing required attributes — fix the role first."
        },
        {
          "id": "aria-valid-attr-value",
          "reason": "After adding required attributes, verify their values are valid."
        }
      ]
    },
    "aria-roles": {
      "fix": {
        "description": "Replace invalid ARIA role values with valid roles from the WAI-ARIA specification, or remove the role attribute if it is not needed.",
        "code": "<!-- Invalid roles: -->\n<!-- role=\"text\" — not a valid ARIA role -->\n<!-- role=\"container\" — not a valid ARIA role -->\n<!-- role=\"button\" on a <button> — redundant, not a violation but unnecessary -->\n\n<!-- Valid replacements: -->\n<div role=\"region\" aria-labelledby=\"section-heading\">...</div>\n<span role=\"status\" aria-live=\"polite\">Saved successfully</span>\n<div role=\"alert\">Error: field is required</div>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (invalid roles are ignored or misinterpreted by AT)",
      "expected": "All role attribute values must be valid ARIA roles from the WAI-ARIA specification.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Common invalid roles: 'text' (not valid — use role='paragraph' or remove the role), 'input' (not valid — use native <input>), 'container' (not valid — use role='group'). Also watch for typos: 'dialouge' instead of 'dialog'. Adding a role that matches the element's implicit role (e.g., role='button' on <button>) is not a violation but is unnecessary — remove it for cleaner markup.",
      "framework_notes": {
        "react": "In React, ARIA roles are passed as the role prop. Use eslint-plugin-jsx-a11y (aria-role rule) to catch invalid role values at build time — there is no runtime validation.",
        "vue": "In Vue, invalid role values are passed through to the DOM without validation. Use eslint-plugin-vuejs-accessibility to catch invalid role attributes in templates.",
        "angular": "In Angular, @angular-eslint includes aria-role lint rules. Enable them in .eslintrc to validate role attribute values at compile time."
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "After fixing an invalid role, verify the replacement role has all required ARIA attributes."
        },
        {
          "id": "aria-prohibited-attr",
          "reason": "After fixing the role, verify no ARIA attributes are prohibited for the new role."
        }
      ],
      "manual_test": {
        "description": "Verify the corrected role is announced correctly by a screen reader.",
        "steps": [
          "Navigate to the element with VoiceOver or NVDA — the role must be announced (e.g., 'button', 'alert', 'region').",
          "If no role is announced or 'group' is announced unexpectedly, the role attribute may be invalid.",
          "Cross-reference the role value against https://www.w3.org/TR/wai-aria/#role_definitions."
        ]
      }
    },
    "aria-toggle-field-name": {
      "fix": {
        "description": "Add an accessible name to toggle input fields (checkbox, radio, switch) via a <label>, aria-label, or aria-labelledby.",
        "code": "<!-- Checkbox with associated label: -->\n<label for=\"subscribe\">\n  <input type=\"checkbox\" id=\"subscribe\"> Subscribe to newsletter\n</label>\n\n<!-- Custom ARIA switch with aria-label: -->\n<button role=\"switch\" aria-checked=\"false\" aria-label=\"Enable dark mode\">\n  <span class=\"toggle-knob\" aria-hidden=\"true\"></span>\n</button>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "Toggle fields (checkbox, radio, role='switch') must have an accessible name so AT can announce what is being toggled.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Custom toggle switches built with role='switch' require both aria-label AND aria-checked. Missing either triggers a violation. For checkbox inputs, a label must be associated via for/id or by wrapping — visually adjacent text without a <label> element is not sufficient for AT.",
      "framework_notes": {
        "react": "In React, custom toggle components must spread aria-label and aria-checked to the underlying element. For native checkboxes, use htmlFor on <label>. For switches: <button role='switch' aria-checked={isOn} aria-label='Enable notifications'>.",
        "vue": "In Vue, custom toggle components must pass aria-label and aria-checked to the root element. For native checkboxes, use <label :for='id'> with matching :id on the <input>.",
        "angular": "In Angular, use <label [for]='checkboxId'> for native checkboxes. For custom switches, bind [attr.aria-label]='label' and [attr.aria-checked]='isChecked' on the role='switch' element."
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "The same label association pattern resolves both label and aria-toggle-field-name violations."
        },
        {
          "id": "aria-required-attr",
          "reason": "role='switch' requires aria-checked — fix the accessible name and required attributes together."
        }
      ],
      "manual_test": {
        "description": "Tab to each toggle and verify the screen reader announces both its name and current state.",
        "steps": [
          "Tab to the checkbox or toggle — the AT must announce the label and state (e.g., 'Subscribe to newsletter, unchecked').",
          "Toggle the control — the state change must be announced ('checked' / 'unchecked').",
          "For custom switches, confirm aria-checked is updated programmatically when the toggle state changes."
        ]
      }
    },
    "aria-valid-attr-value": {
      "fix": {
        "description": "Set a valid value for the ARIA attribute. Consult the WAI-ARIA spec for the list of allowed values.",
        "code": "<!-- Common invalid → valid corrections: -->\n\n<!-- aria-live: must be 'off' | 'polite' | 'assertive' -->\n<div aria-live=\"polite\">...</div>  <!-- not aria-live=\"yes\" -->\n\n<!-- aria-expanded: must be 'true' | 'false' -->\n<button aria-expanded=\"false\">Menu</button>  <!-- not aria-expanded=\"0\" -->\n\n<!-- aria-haspopup: must be 'true' | 'false' | 'menu' | 'listbox' | 'tree' | 'grid' | 'dialog' -->\n<button aria-haspopup=\"menu\">Options</button>  <!-- not aria-haspopup=\"dropdown\" -->"
      },
      "effort": "low",
      "impacted_users": "Screen reader users",
      "expected": "ARIA attributes must use only valid values defined in the WAI-ARIA spec.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The most common mistake is using incorrect types for boolean attributes: aria-expanded='0' or aria-expanded='yes' instead of 'true'/'false'. In template engines, ensure dynamic state is coerced to the string 'true' or 'false', not a JavaScript boolean. React spreads boolean props correctly — aria-expanded={isOpen} renders 'true'/'false' — but aria-expanded={isOpen ? 1 : 0} does not.",
      "framework_notes": {
        "react": "React coerces aria-expanded={isOpen} to the string 'true'/'false' correctly. Do not use aria-expanded={isOpen ? '1' : '0'} or other non-token values. Use aria-expanded={undefined} to omit the attribute entirely when the role does not require it.",
        "vue": "Use :aria-expanded='isOpen' — Vue renders boolean true/false as the strings 'true'/'false'. Do not use :aria-expanded='isOpen ? 1 : 0'. To omit the attribute, bind to null: :aria-expanded='null'.",
        "angular": "Use [attr.aria-expanded]='isOpen' binding — Angular renders the boolean as the correct string. Setting [attr.aria-expanded]='null' removes the attribute entirely when not applicable."
      },
      "manual_test": {
        "description": "Confirm the corrected attribute value is recognised by a screen reader.",
        "steps": [
          "Locate the element in DevTools — note the invalid attribute value flagged by axe.",
          "Update the value to a valid token per the WAI-ARIA spec.",
          "Interact with the element using VoiceOver or NVDA and confirm the state is announced correctly (e.g., 'expanded', 'collapsed')."
        ]
      },
      "related_rules": [
        {
          "id": "aria-required-attr",
          "reason": "Required attributes must be present before their values can be validated — fix both together."
        },
        {
          "id": "aria-roles",
          "reason": "An invalid role produces invalid attribute values — fix the role before the attribute values."
        }
      ]
    },
    "audio-caption": {
      "fix": {
        "description": "Add a <track kind='captions'> element inside every <audio> element, or provide a text transcript linked adjacent to the player.",
        "code": "<audio controls>\n  <source src=\"podcast.mp3\" type=\"audio/mpeg\">\n  <track kind=\"captions\" src=\"podcast.vtt\" srclang=\"en\" label=\"English captions\" default>\n</audio>\n\n<!-- Alternative: linked transcript -->\n<audio controls src=\"podcast.mp3\"></audio>\n<p><a href=\"podcast-transcript.html\">Read the full transcript</a></p>"
      },
      "effort": "high",
      "impacted_users": "Deaf users and users with hearing disabilities",
      "expected": "All <audio> elements with speech or meaningful audio must provide synchronized captions or a full transcript.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Captions must be synchronized with the audio — a plain text page is a transcript, not captions. VTT (WebVTT) is the standard format for <track> elements and is supported in all modern browsers. Generating captions retroactively is effort-intensive; tools like Whisper (OpenAI), Adobe Premiere, or Rev.com can auto-generate VTT files that require human review before publishing.",
      "framework_notes": {
        "react": "In React, pass <track> as a child of the <audio> JSX element. React requires a key prop on <track> when rendered in a list. Use the default prop (boolean) to set the default caption track.",
        "vue": "In Vue, nest <track> inside <audio> in the template. For dynamic caption src, bind :src='captionsSrc'. The default boolean attribute is passed as a plain HTML attribute without binding.",
        "angular": "In Angular, the native <audio> element with nested <track> works in component templates. For dynamic caption URLs, use [attr.src]='captionsSrc' on the <track> element."
      },
      "related_rules": [
        {
          "id": "video-caption",
          "reason": "Both require media captions — fix all media accessibility violations together."
        }
      ],
      "manual_test": {
        "description": "Play the audio content and verify captions or transcript accurately reflect all spoken content.",
        "steps": [
          "Play the audio with captions enabled — confirm every spoken word is captioned, including speaker identification if multiple speakers are present.",
          "If a transcript is provided instead of captions, verify it covers 100% of spoken content in readable order.",
          "Check that captions are synchronized — they must appear at the correct time, not delayed or early."
        ]
      }
    },
    "autocomplete-valid": {
      "fix": {
        "description": "Add a valid autocomplete token to form inputs to assist users with autofill.",
        "code": "<input type=\"email\" name=\"email\" autocomplete=\"email\">\n<input type=\"text\" name=\"name\" autocomplete=\"name\">\n<input type=\"tel\" name=\"phone\" autocomplete=\"tel\">"
      },
      "effort": "low",
      "impacted_users": "Users with motor disabilities and cognitive disabilities",
      "expected": "Inputs collecting personal data must have a valid autocomplete attribute per WCAG 1.3.5.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Acceptable autocomplete tokens are strictly defined by the HTML Living Standard. Custom or invented values (e.g., autocomplete='my-app-email') are invalid even if they help password managers. Use only the tokens listed at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute. Verify you are applying the token to the right field type — autocomplete='email' on a phone number field is invalid.",
      "framework_notes": {
        "react": "Pass autocomplete as a string prop in JSX: <input autoComplete='email' />. Note: React uses camelCase autoComplete, which renders as the autocomplete HTML attribute. React Hook Form does not intercept it — set it directly on the input element.",
        "vue": "Use autocomplete='email' as a plain HTML attribute in Vue templates. Vee-Validate passes the autocomplete attribute through to the native input via v-bind on the field component.",
        "angular": "Use the autocomplete attribute in Angular Reactive Forms or Template-driven forms — Angular does not strip or override it. For Angular Material inputs, add autocomplete='email' to the <input> element inside <mat-form-field>."
      },
      "manual_test": {
        "description": "Verify autofill populates the correct field type in a real browser.",
        "steps": [
          "Open the form in Chrome or Safari with autofill data saved.",
          "Trigger autofill (e.g., click the field or use Cmd+Shift+A in Chrome) — confirm the field receives the right data type.",
          "Check DevTools: the autocomplete attribute value must be a valid token from the WCAG 1.3.5 list."
        ]
      }
    },
    "button-name": {
      "fix": {
        "description": "Give every button an accessible name via visible text or aria-label.",
        "code": "<!-- Via visible text: -->\n<button>Submit form</button>\n<!-- Icon button via aria-label: -->\n<button aria-label=\"Close dialog\"><svg aria-hidden=\"true\">...</svg></button>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "Every <button> and [role=\"button\"] must have a non-empty accessible name.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Using aria-label on a button with visible text creates a label mismatch — voice control users speak the visible text, not the aria-label. If visible text exists, keep it and remove aria-label. Only use aria-label for icon-only buttons with no visible text.",
      "framework_notes": {
        "react": "Use aria-label prop: <button aria-label=\"Close dialog\">. Prefer visible text children whenever possible.",
        "vue": "Use :aria-label or aria-label attribute — standard HTML semantics apply.",
        "angular": "Use [attr.aria-label] binding or the CDK a11y AccessibilityModule for managed focus."
      },
      "manual_test": {
        "description": "Test button names using a screen reader or Inspect tools.",
        "steps": [
          "Tab to the button.",
          "Listen to the announced name; ensure it matches the button's action."
        ]
      },
      "related_rules": [
        {
          "id": "input-button-name",
          "reason": "The same accessible name requirement applies to <input type='button'/'submit'/'reset'> — fix all button naming violations together."
        },
        {
          "id": "link-name",
          "reason": "The same accessible name requirement applies to links — fix all interactive element naming together."
        }
      ]
    },
    "bypass": {
      "fix": {
        "description": "Add a skip link at the very top of each page so keyboard users can bypass repetitive navigation.",
        "code": "<a class=\"skip-link\" href=\"#main-content\">Skip to main content</a>\n<nav><!-- navigation --></nav>\n<main id=\"main-content\">\n  <!-- page content -->\n</main>"
      },
      "effort": "low",
      "impacted_users": "Keyboard-only users and screen reader users",
      "expected": "Page must provide a mechanism to skip repetitive navigation (e.g., a skip link).",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "The skip link must be visible on focus — hiding it with display:none or visibility:hidden prevents keyboard users from seeing or activating it. The correct pattern is to position it off-screen by default (position:absolute; left:-9999px) and bring it on-screen on :focus (left:0; top:0). The target anchor (#main-content) must be a real element — if it's missing or the href is broken, the skip link appears to work but focus doesn't actually move.",
      "framework_notes": {
        "react": "In Next.js, add the skip link as the first element in the root layout (app/layout.tsx), before the <header> or navigation components. Style it with CSS to appear only on :focus. The target #main-content must reference the <main id='main-content'> in the same layout.",
        "vue": "In Nuxt, add the skip link at the very top of layouts/default.vue, before the <header> component. The target #main-content must be on the <main> element wrapping <slot />.",
        "angular": "Add the skip link as the first element inside app.component.html, before <app-header> or navigation. The target #main-content must match the id on the <main> element rendered inside the page — typically adjacent to <router-outlet>."
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "The skip link target (#main-content) must point to the <main> landmark."
        }
      ],
      "manual_test": {
        "description": "Verify the skip link is functional, not just present in the DOM.",
        "steps": [
          "Press Tab on page load — the first focusable element should be the skip link.",
          "Press Enter on the skip link — keyboard focus must move to the main content area.",
          "Confirm the skip link is visible when focused (not permanently hidden with display:none)."
        ]
      }
    },
    "color-contrast": {
      "fix": {
        "description": "Increase the contrast ratio between text and its background. Minimum 4.5:1 for normal text, 3:1 for large text (≥18pt or ≥14pt bold).",
        "code": "/* Adjust the foreground or background color until contrast ≥4.5:1 */\n/* Use CSS custom properties to keep the fix systematic: */\n.element {\n  color: var(--color-text-primary); /* verify ≥4.5:1 against background */\n  background-color: var(--color-surface); /* e.g. #fff or #1e293b */\n}\n/* Tip: Check contrast at https://webaim.org/resources/contrastchecker/ */"
      },
      "effort": "high",
      "impacted_users": "Users with low vision or color blindness",
      "expected": "Text contrast ratio must be at least 4.5:1 for normal text, 3:1 for large text.",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "False positives are common on text rendered over gradient backgrounds, images, or when color is set dynamically via JavaScript or CSS variables resolved at runtime. axe-core samples a single point of the background — text on gradients may appear to fail even when contrast is sufficient. Verify each flagged instance visually using the browser DevTools color picker or https://webaim.org/resources/contrastchecker/ before fixing.",
      "framework_notes": {
        "react": "In Tailwind (including shadcn/ui), verify that HSL CSS custom properties resolve to accessible values in both light and dark themes. CSS-in-JS libraries (styled-components, Emotion) compute colors at runtime — axe audits the computed value, not the source variable.",
        "vue": "In Vue with Tailwind or CSS Modules, verify contrast in the computed styles, not just the source CSS variables. Use DevTools color picker to confirm the rendered ratio.",
        "angular": "In Angular Material, override theme colors via mat.define-theme() using contrast-checked color pairs. Avoid raw CSS overrides that bypass the Angular Material theming system's built-in contrast checks."
      },
      "manual_test": {
        "description": "Verify contrast in interactive states — axe only scans the static DOM.",
        "steps": [
          "Hover over links and buttons — check that text contrast remains ≥4.5:1 in the hover state.",
          "Focus interactive elements with Tab — verify the focused state maintains sufficient contrast.",
          "Check text rendered over images or gradients using the DevTools color picker."
        ]
      }
    },
    "consistent-help": {
      "fix": {
        "description": "Help mechanisms (support link, chat, contact info, self-help tool) must appear in the same relative order on every page where they appear (WCAG 3.2.6).",
        "code": "<!-- Place help in a consistent location across all pages (e.g., persistent header or footer): -->\n<header>\n  <nav aria-label=\"Support\">\n    <a href=\"/help\">Help centre</a>\n    <a href=\"/contact\">Contact support</a>\n  </nav>\n</header>"
      },
      "effort": "medium",
      "impacted_users": "Users with cognitive disabilities who rely on consistent page layouts",
      "expected": "Help mechanisms must appear in the same relative order on every page where they are provided (WCAG 3.2.6).",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "Automated tools can only scan one page at a time and cannot compare help mechanism position across pages. axe findings for this rule are heuristic — they identify potential consistency issues but cannot confirm a violation without cross-page comparison. Manually verify across at least 3 page templates.",
      "manual_test": {
        "description": "Navigate between at least 3 different pages and verify help links appear in the same position.",
        "steps": [
          "Identify all help mechanisms on the homepage (e.g., chat widget, help link in footer).",
          "Visit 2 more pages and confirm the help mechanisms appear in the same order and position.",
          "If any page hides or repositions the help mechanism, it violates WCAG 3.2.6."
        ]
      },
      "framework_notes": {
        "react": "Place help mechanisms in the root layout component (e.g., app/layout.tsx in Next.js App Router, or App.jsx). Never put them in individual page components — they will appear/disappear per route, breaking consistency. In Next.js Pages Router, use _app.js.",
        "vue": "Add help mechanisms to the root layout (App.vue or layouts/default.vue in Nuxt). Avoid placing them in page-level components. In Nuxt, layouts/default.vue is the canonical location to guarantee consistent rendering across all routes.",
        "shopify": "Place help links in layout/theme.liquid or a persistent snippet included in every section. Never add them only to specific section templates — they will be absent on pages that don't render that section.",
        "wordpress": "Add help mechanisms to header.php or footer.php in the active theme. Avoid widget areas that may not appear on all page templates (e.g., some templates skip the sidebar)."
      }
    },
    "document-title": {
      "fix": {
        "description": "Add a descriptive, unique <title> element to every page.",
        "code": "<title>Product Details — My Store</title>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and users with cognitive disabilities",
      "expected": "Page must have a descriptive, unique <title> element.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "In SPAs, the <title> is often set only on initial load. After client-side route changes, the title must be updated programmatically — the browser tab title stays stale otherwise. Each page title should follow the pattern 'Page Name — Site Name' so users understand context without reading page content.",
      "framework_notes": {
        "react": "Use document.title in a useEffect, or react-helmet for declarative title management. In Next.js, use <title> inside <Head> from 'next/head' — it is server-side rendered.",
        "vue": "Update document.title in vue-router's afterEach navigation guard, or use vue-meta / @vueuse/head for declarative management.",
        "angular": "Inject the Title service from @angular/platform-browser and call this.title.setTitle() inside route guards or component ngOnInit."
      },
      "manual_test": {
        "description": "Verify the title is unique per page and describes the current content.",
        "steps": [
          "Navigate to at least 3 different pages and check the browser tab title each time.",
          "Confirm each title is different and reflects the specific page (not just the site name).",
          "For SPAs, confirm the title updates dynamically after route changes."
        ]
      }
    },
    "dragging-movements": {
      "fix": {
        "description": "All drag-and-drop functionality must have a single-pointer alternative (e.g., click-to-select then click-to-drop, or arrow buttons) for users who cannot perform drag gestures (WCAG 2.5.7).",
        "code": "<!-- Provide non-drag alternative with arrow buttons: -->\n<ul role=\"listbox\" aria-label=\"Sortable items\">\n  <li role=\"option\" tabindex=\"0\">\n    Item 1\n    <button aria-label=\"Move item up\">↑</button>\n    <button aria-label=\"Move item down\">↓</button>\n  </li>\n</ul>"
      },
      "effort": "high",
      "impacted_users": "Users with motor disabilities who cannot perform drag gestures",
      "expected": "All drag-and-drop functionality must have an equivalent single-pointer alternative operable without dragging (WCAG 2.5.7).",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "axe detects drag interactions heuristically based on event listeners — it may flag elements that listen to drag events but do not actually require dragging for their core function. Verify that the flagged element genuinely has drag-only functionality before implementing an alternative. WCAG 2.5.7 includes an exception when the dragging motion is 'essential' (e.g., a signature pad or freehand drawing tool).",
      "framework_notes": {
        "react": "Libraries like @dnd-kit/core provide keyboard-accessible drag-and-drop out of the box. react-beautiful-dnd also supports keyboard dragging. If using a custom drag implementation with mousedown/mousemove events, add keyboard event handlers (Arrow keys for movement, Space/Enter to confirm drop) as an accessible alternative.",
        "vue": "Vue Draggable (vuedraggable) and @vueuse/gesture may not include keyboard alternatives by default. Supplement drag interactions with arrow key handlers and explicit 'move up/down' buttons visible to all users.",
        "angular": "Angular CDK DragDrop (CdkDrag) does not provide keyboard drag-and-drop by default. Add a secondary keyboard interface (e.g., Up/Down arrow buttons) as the accessible alternative alongside the drag functionality."
      },
      "manual_test": {
        "description": "Verify the non-drag alternative completes the same task end-to-end.",
        "steps": [
          "Identify all drag interactions (sortable lists, file uploads, kanban boards).",
          "Complete the full task using only keyboard or single clicks — no drag gesture.",
          "Confirm the result is identical to what the drag interaction would produce."
        ]
      }
    },
    "duplicate-id": {
      "fix": {
        "description": "All id attributes must be unique within the page. Search for duplicate values and rename them.",
        "code": "<!-- Before: duplicate ids -->\n<nav id=\"main-nav\">...</nav>\n<footer id=\"main-nav\">...</footer>\n\n<!-- After: unique ids -->\n<nav id=\"primary-nav\">...</nav>\n<footer id=\"footer-nav\">...</footer>\n\n<!-- Update any referencing aria-labelledby / aria-controls / href=\"#\" accordingly -->"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (broken element references)",
      "expected": "All id attributes must be unique within the document.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "In component-based frameworks, duplicate IDs typically occur when the same component renders multiple times on the same page. Use framework-native ID generation: useId() in React 18+, a unique :id binding per instance in Vue, or a service-based ID generator in Angular.",
      "framework_notes": {
        "react": "Use the useId() hook (React 18+) to generate unique IDs per component instance: const id = useId(); return <label htmlFor={id}>.",
        "vue": "Bind a unique key to IDs: <label :for=\"`field-${uid}`\"> where uid is a prop or generated value (e.g., Math.random().toString(36)).",
        "angular": "Inject a counter service or use the CDK's uniqueId utility to generate stable, unique IDs per component instance."
      },
      "related_rules": [
        {
          "id": "duplicate-id-aria",
          "reason": "Duplicate IDs break both element references and ARIA relationships — fix all ID uniqueness violations together."
        }
      ],
      "manual_test": {
        "description": "Verify no duplicate id values exist, especially across dynamically rendered components.",
        "steps": [
          "Open DevTools Console and run: document.querySelectorAll('[id]') — look for repeated values.",
          "Paste: [...document.querySelectorAll('[id]')].filter((el, i, arr) => arr.findIndex(e => e.id === el.id) !== i) — non-empty result = duplicates.",
          "Check SPAs after route changes — ids may be duplicated when components re-render."
        ]
      }
    },
    "duplicate-id-aria": {
      "fix": {
        "description": "Ensure all IDs referenced by ARIA attributes (aria-labelledby, aria-describedby, aria-controls, aria-owns) are unique. Duplicate IDs cause screen readers to reference the wrong element.",
        "code": "<!-- Before: duplicate IDs break aria-labelledby -->\n<span id=\"label\">Username</span>\n<input aria-labelledby=\"label\" type=\"text\">\n<!-- ...later on same page... -->\n<span id=\"label\">Email</span>  <!-- duplicate! -->\n\n<!-- After: unique IDs -->\n<span id=\"username-label\">Username</span>\n<input aria-labelledby=\"username-label\" type=\"text\">\n<span id=\"email-label\">Email</span>\n<input aria-labelledby=\"email-label\" type=\"email\">"
      },
      "effort": "medium",
      "impacted_users": "Screen reader users (broken accessible name, description, or widget relationships)",
      "expected": "All IDs referenced by ARIA attributes must be unique within the document. Duplicate ARIA-referenced IDs cause AT to resolve to the first matching element, breaking all subsequent references.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Unlike duplicate-id (which flags all duplicate IDs), this rule specifically targets IDs that are referenced by ARIA attributes — making it higher severity because the duplicate directly breaks an accessibility relationship. In component-based apps, this almost always occurs when the same component renders multiple times with a hardcoded ID in its template. Use framework ID generation utilities to ensure uniqueness per instance.",
      "framework_notes": {
        "react": "Use React 18's useId() hook to generate unique IDs per component instance: const id = useId(); return <><span id={id}>Label</span><input aria-labelledby={id} /></>. Never hardcode IDs in components that render more than once.",
        "vue": "In Vue, generate a unique ID per instance using a composable: const id = `field-${Math.random().toString(36).slice(2)}`; or use the useId() utility from VueUse. Bind with :id='id' and :aria-labelledby='id'.",
        "angular": "In Angular, inject a counter service or use a module-level incrementing variable to generate stable unique IDs: private static idCounter = 0; readonly fieldId = `field-${++FieldComponent.idCounter}`;. Bind with [attr.id]='fieldId'."
      },
      "related_rules": [
        {
          "id": "duplicate-id",
          "reason": "Duplicate IDs break both element references and ARIA relationships — fix all ID uniqueness violations together."
        }
      ],
      "manual_test": {
        "description": "Verify that ARIA-referenced IDs resolve to the correct element on the page.",
        "steps": [
          "In DevTools Console, run: document.querySelectorAll('[aria-labelledby],[aria-describedby],[aria-controls],[aria-owns]') and for each, verify the referenced ID is unique.",
          "With a screen reader, focus the flagged input or widget — the announced label must match the visible label text.",
          "If the component renders multiple times on the page (e.g., in a list), check that each instance references a different ID."
        ]
      }
    },
    "empty-heading": {
      "fix": {
        "description": "Add meaningful text content to the heading element, or remove it if it serves no structural purpose.",
        "code": "<!-- Before: empty heading -->\n<h2></h2>\n\n<!-- After: heading with content -->\n<h2>Section title</h2>\n\n<!-- Or remove entirely if structural-only -->\n<!-- Use CSS pseudo-content for decorative dividers instead -->"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by headings",
      "expected": "Every heading element must contain non-empty, meaningful text content.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Empty headings commonly occur in CMS-driven layouts where a heading tag is part of a section template but the author left the field blank. In component libraries, empty headings can also result from a conditional slot that renders nothing. Check both the template and the content source — the fix may be in the CMS content, not the code.",
      "framework_notes": {
        "react": "In React, a heading with dynamic content like <h2>{title}</h2> renders an empty heading if title is undefined, null, or an empty string. Guard with: {title && <h2>{title}</h2>} or provide a fallback string.",
        "vue": "In Vue, <h2>{{ title }}</h2> renders an empty heading if title is falsy. Use a v-if guard: <h2 v-if='title'>{{ title }}</h2> or a computed fallback.",
        "angular": "In Angular, <h2>{{ title }}</h2> renders empty if title is undefined. Use *ngIf='title' on the heading element, or provide a default value in the component."
      },
      "related_rules": [
        {
          "id": "heading-order",
          "reason": "Empty headings disrupt the heading hierarchy — resolve them together."
        }
      ],
      "manual_test": {
        "description": "Verify every heading has meaningful content that describes its section.",
        "steps": [
          "Open DevTools and run: document.querySelectorAll('h1,h2,h3,h4,h5,h6') — check each for empty innerText.",
          "Navigate the page with a screen reader using the heading shortcut (H in NVDA/JAWS) — empty headings will be announced as 'heading level X' with no label.",
          "Confirm each heading text accurately describes the content that follows it."
        ]
      }
    },
    "focus-appearance": {
      "fix": {
        "description": "The focus indicator must cover a minimum area (perimeter × 2 CSS px) and maintain a 3:1 contrast ratio between focused and unfocused states (WCAG 2.4.11).",
        "code": ":focus-visible {\n  outline: 3px solid #005FCC;\n  outline-offset: 2px;\n  /* Ensure contrast ratio ≥ 3:1 vs adjacent background */\n}\n\n/* Remove browser default only when providing a custom style */\n:focus:not(:focus-visible) {\n  outline: none;\n}"
      },
      "effort": "medium",
      "impacted_users": "Keyboard-only users and users with low vision",
      "expected": "Focus indicators must be clearly visible, with a minimum area of the component perimeter × 2 CSS px and a 3:1 contrast ratio between focused and unfocused states (WCAG 2.4.11).",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "outline:none does not necessarily mean no focus indicator — a visible box-shadow, background-color change, or border change can fully satisfy WCAG 2.4.11. axe may flag outline:none even when a compliant custom indicator is present. Verify visually that a focus indicator exists before applying a fix. When suppressing the outline, always provide a replacement via box-shadow or border.",
      "manual_test": {
        "description": "Tab through every interactive element and verify the focus indicator is visible and distinct.",
        "steps": [
          "Press Tab repeatedly and confirm every button, link, and input shows a visible focus ring.",
          "Check that the focus indicator contrasts at least 3:1 against the adjacent unfocused background.",
          "Verify the outline is not clipped by overflow:hidden on a parent container."
        ]
      }
    },
    "form-field-multiple-labels": {
      "fix": {
        "description": "Each form field must have exactly one associated <label>. Remove duplicate labels.",
        "code": "<!-- One label per input: -->\n<label for=\"name\">Full name</label>\n<input id=\"name\" type=\"text\" name=\"name\">"
      },
      "effort": "low",
      "impacted_users": "Screen reader users",
      "expected": "Each form input must have exactly one accessible name source (label, aria-label, or aria-labelledby).",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "aria-labelledby can legitimately reference multiple IDs to concatenate a compound label (e.g., aria-labelledby='label1 label2'). axe may flag this pattern. Review whether both sources are intentional — if so, it is valid and the finding is a false positive. Remove one reference only if the concatenated announcement is redundant.",
      "framework_notes": {
        "react": "In React, multiple labeling sources are introduced accidentally when a component applies both htmlFor on a <label> and aria-label on the input itself. Choose exactly one labeling strategy per input — prefer a visible <label htmlFor='id'> and remove aria-label.",
        "vue": "In Vue form component wrappers, ensure the component does not add internal aria-labels that conflict with a parent <label>. A common issue is a UI kit that adds aria-label='Input field' to every input by default — override this with an empty string or use the component's label prop instead.",
        "angular": "In Angular Material, mat-label inside mat-form-field serves as the accessible label. Do not also add aria-label directly to the input — both will be announced, triggering this violation."
      },
      "manual_test": {
        "description": "Confirm a screen reader announces exactly one label when focused on the input.",
        "steps": [
          "Tab to the flagged input with VoiceOver or NVDA active.",
          "Listen to the announcement — it should state one name, not two concatenated labels.",
          "In DevTools Accessibility panel, check the 'Name' field — it should contain a single, clean label."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "Multiple labels on an input conflict with the single-label association requirement — fix both together."
        },
        {
          "id": "label-content-name-mismatch",
          "reason": "Multiple labels often cause the accessible name to diverge from visible text."
        }
      ]
    },
    "frame-title": {
      "fix": {
        "description": "Add a descriptive title attribute to every <iframe>.",
        "code": "<iframe\n  title=\"Embedded map showing our store location\"\n  src=\"https://maps.example.com/embed\"\n></iframe>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users",
      "expected": "Every <iframe> must have a descriptive title attribute.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Hidden or off-screen iframes used for third-party scripts (analytics, chat SDKs, A/B testing) should use title='' (empty) to suppress screen reader announcement — not a descriptive title. Only visible, interactive iframes that users would encounter need a meaningful title.",
      "framework_notes": {
        "react": "When embedding iframes (Google Maps, YouTube, Stripe), add the title prop directly: <iframe title='Google Maps — store location' src='...' />. Third-party React wrapper components that embed iframes should expose a title prop passthrough.",
        "vue": "Use the title attribute directly: <iframe title='Payment form' :src='url' />. For third-party Vue components that embed iframes internally, check the component's props API for a title or label prop.",
        "angular": "Use [title]='iframeTitle' binding for dynamic titles, or title='Embedded video' for static ones. For hidden tracking iframes generated by third-party scripts, set title='' programmatically to suppress screen reader announcement."
      },
      "manual_test": {
        "description": "Tab into the iframe area and verify the screen reader announces its title.",
        "steps": [
          "Tab to the iframe — the screen reader must announce 'frame' and the title content.",
          "Confirm the title describes the frame's purpose (e.g., 'Google Maps — Store Location'), not a generic label ('iframe').",
          "For hidden or off-screen iframes (e.g., third-party scripts), add title=\"\" to suppress SR announcement."
        ]
      }
    },
    "heading-order": {
      "fix": {
        "description": "Fix the heading hierarchy — no levels may be skipped.",
        "code": "<h1>Page title</h1>\n<h2>Section heading</h2>\n<h3>Subsection heading</h3>\n<!-- Invalid: jumping from h1 to h3 -->"
      },
      "effort": "medium",
      "impacted_users": "Screen reader users navigating by headings",
      "expected": "Heading levels must not skip (h1 → h2 → h3, no gaps allowed).",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Never use heading elements purely for visual sizing (e.g., using <h4> because it renders smaller). Use CSS classes for font size. The heading level must reflect document structure, not visual hierarchy. Resolve page-has-heading-one first — a missing h1 often causes cascading heading-order violations.",
      "framework_notes": {
        "react": "In component libraries (shadcn/ui, Radix), heading levels are often hardcoded (e.g., CardTitle always renders as h3). Use the 'as' prop to override the level based on context: <CardTitle as='h2'> when the component appears as a top-level section heading.",
        "vue": "In Vue UI kits (Vuetify, Nuxt UI), check if heading components support a 'tag' prop to override the rendered element. Use semantic levels based on document structure, not visual size.",
        "angular": "In Angular Material, headings inside mat-card and mat-expansion-panel are often rendered as <div> or <span>. Add the appropriate heading element explicitly inside the component template rather than relying on implicit heading structure."
      },
      "related_rules": [
        {
          "id": "page-has-heading-one",
          "reason": "Fixing the h1 establishes the root of the hierarchy — resolve it first."
        }
      ],
      "manual_test": {
        "description": "Verify headings describe their sections meaningfully, not just maintain numeric order.",
        "steps": [
          "Read only the heading text in sequence — do they form a logical outline of the page?",
          "Check that no heading is used purely for visual sizing (e.g. an h3 that is not a subsection of the h2 above it).",
          "Use the browser Accessibility Tree or a headings extension to review the full outline."
        ]
      }
    },
    "html-has-lang": {
      "fix": {
        "description": "Add a lang attribute to the <html> element so screen readers pronounce content correctly.",
        "code": "<html lang=\"en\">"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (language detection for pronunciation)",
      "expected": "The <html> element must have a lang attribute.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The lang attribute must be on the <html> element itself, not on a meta tag or the <body>. In framework app templates, the <html> tag is typically in an index.html or document template file outside of component scope — not in a React/Vue/Angular component. For multilingual SPAs, update document.documentElement.lang programmatically on each route change to reflect the current content language.",
      "framework_notes": {
        "react": "In Next.js App Router, set lang in the root layout: export default function RootLayout() { return <html lang='en'>...</html>; } in app/layout.tsx. For i18n, derive the lang from the locale route segment.",
        "vue": "In Nuxt, set lang in nuxt.config.ts: app: { head: { htmlAttrs: { lang: 'en' } } }. For multilingual Nuxt apps, @nuxtjs/i18n sets the lang attribute per locale automatically.",
        "angular": "In Angular, set lang in index.html: <html lang='en'>. With Angular Universal (SSR), inject LOCALE_ID and set document.documentElement.lang in a server-side app initializer to support locale-specific rendering."
      },
      "manual_test": {
        "description": "Confirm a screen reader switches to the correct language voice when reading the page.",
        "steps": [
          "Enable VoiceOver or NVDA with multiple language voices installed.",
          "Navigate to the page — the screen reader must use the declared language voice.",
          "If content is bilingual, verify elements with lang overrides on child elements are also announced in the correct language."
        ]
      },
      "related_rules": [
        {
          "id": "html-lang-valid",
          "reason": "Adding a lang attribute must use a valid BCP 47 language tag — fix both together."
        },
        {
          "id": "valid-lang",
          "reason": "Child elements with lang attributes must also use valid tags — audit all lang values at once."
        }
      ]
    },
    "html-lang-valid": {
      "fix": {
        "description": "Use a valid BCP 47 language tag on the <html> element.",
        "code": "<!-- English -->\n<html lang=\"en\">\n<!-- French Canadian -->\n<html lang=\"fr-CA\">\n<!-- Brazilian Portuguese -->\n<html lang=\"pt-BR\">"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (language detection for pronunciation)",
      "expected": "The lang attribute on <html> must be a valid BCP 47 language tag.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Common mistakes: using underscore separator ('en_US') instead of hyphen ('en-US'), or spelling out the full language name ('english') instead of the BCP 47 subtag ('en'). Verify against https://www.iana.org/assignments/language-subtag-registry/.",
      "framework_notes": {
        "react": "Same fix location as html-has-lang — set lang in app/layout.tsx: <html lang='en-US'>. Ensure the value is a valid BCP 47 tag, not a locale string from your i18n library (e.g., 'en_US' with underscore is invalid).",
        "vue": "Same as html-has-lang — set in nuxt.config.ts htmlAttrs or in the HTML template. Verify the value against the BCP 47 registry before deploying.",
        "angular": "Same as html-has-lang — set in index.html or via Angular Universal's locale injection. Confirm the value uses hyphen separators (en-US), not underscore (en_US)."
      },
      "related_rules": [
        {
          "id": "html-has-lang",
          "reason": "html-has-lang and html-lang-valid are often co-located — fix the lang attribute once to resolve both."
        },
        {
          "id": "valid-lang",
          "reason": "The same BCP 47 validity requirement applies to lang attributes on child elements."
        }
      ],
      "manual_test": {
        "description": "Verify the lang value is a recognised BCP 47 tag.",
        "steps": [
          "Inspect the <html> element in DevTools — read the lang attribute.",
          "Cross-check against the IANA Language Subtag Registry (https://www.iana.org/assignments/language-subtag-registry/).",
          "Common mistakes: 'en_US' (underscore) instead of 'en-US' (hyphen), or 'english' (full word) instead of 'en'."
        ]
      }
    },
    "identical-links-same-purpose": {
      "fix": {
        "description": "Ensure links with identical visible text lead to the same destination, or differentiate them with unique text or aria-label to clarify their distinct purposes.",
        "code": "<!-- Before: two 'Read more' links with different destinations -->\n<a href=\"/article-1\">Read more</a>\n<a href=\"/article-2\">Read more</a>\n\n<!-- After: descriptive link text -->\n<a href=\"/article-1\">Read more about accessibility</a>\n<a href=\"/article-2\">Read more about inclusive design</a>\n\n<!-- Or: extend with aria-label (preserves visual design) -->\n<a href=\"/article-1\" aria-label=\"Read more about accessibility\">Read more</a>\n<a href=\"/article-2\" aria-label=\"Read more about inclusive design\">Read more</a>"
      },
      "effort": "medium",
      "impacted_users": "Screen reader users navigating the links list and voice control users",
      "expected": "Links with the same accessible name must have the same destination, or their distinct purpose must be distinguishable from context or accessible name.",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "axe uses heuristics to detect this — it flags links with identical text pointing to different URLs. False positives are common when 'Read more' links in a card grid are accompanied by a heading that provides context. WCAG 2.4.4 allows disambiguation through programmatic context (e.g., an aria-labelledby relationship between a card heading and its link). Check whether this is already satisfied before fixing. The simplest fix that avoids template changes is aria-label.",
      "framework_notes": {
        "react": "In React, card components with 'Read more' links should accept a linkLabel prop: <a href={href} aria-label={`Read more about ${title}`}>Read more</a>. This preserves visual design while adding screen reader context.",
        "vue": "In Vue, pass the article or card title into the link: <a :href='url' :aria-label='`Read more about ${title}`'>Read more</a>.",
        "angular": "In Angular, use [attr.aria-label]='\"Read more about \" + card.title' on the link element within the card component."
      },
      "manual_test": {
        "description": "Open the links list in a screen reader and verify each link is distinguishable without surrounding context.",
        "steps": [
          "In JAWS, press Ctrl+Insert+F7 to open the links list — scan for duplicate link text pointing to different URLs.",
          "In VoiceOver, use Ctrl+Opt+U and navigate to Links — duplicate entries indicate this violation.",
          "For each duplicate, verify whether programmatic context (heading, list item, aria-labelledby) makes the purpose clear without reading the link in isolation."
        ]
      }
    },
    "image-alt": {
      "fix": {
        "description": "Add a descriptive alt attribute to every <img>. Use alt=\"\" for decorative images.",
        "code": "<img src=\"photo.jpg\" alt=\"Description of the image\">\n<!-- Decorative image (hidden from AT): -->\n<img src=\"divider.png\" alt=\"\">"
      },
      "effort": "medium",
      "impacted_users": "Blind users relying on screen readers",
      "expected": "Every <img> must have an alt attribute. Decorative images use alt=\"\".",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "axe-core confirms alt presence but cannot evaluate alt quality. An alt='photo.jpg' or alt='image' passes axe but violates 1.1.1. Always verify that alt text is descriptive and conveys the image's purpose. For decorative images, use alt='' (empty, not omitted — omitting alt causes some screen readers to announce the filename).",
      "framework_notes": {
        "react": "Use the alt prop directly on <img>: <img src={src} alt=\"Description\" />. For decorative images: alt=\"\".",
        "vue": "Use :alt binding or plain alt attribute — standard HTML semantics apply.",
        "angular": "Use [attr.alt] binding or plain alt attribute on <img> elements."
      },
      "manual_test": {
        "description": "Verify the alt text is meaningful, not just present.",
        "steps": [
          "Read the alt text in isolation — does it convey the image's purpose without seeing it?",
          "Flag alts that are filenames (e.g. 'hero.jpg'), generic ('image', 'photo'), or identical to adjacent text.",
          "For decorative images, confirm alt=\"\" is used (not omitted entirely)."
        ]
      },
      "related_rules": [
        {
          "id": "input-image-alt",
          "reason": "The same alt text requirement applies to <input type=\"image\"> — fix all alt text violations together."
        },
        {
          "id": "svg-img-alt",
          "reason": "SVGs used as images need equivalent alt text — audit both together."
        },
        {
          "id": "image-redundant-alt",
          "reason": "When adding alt text, avoid duplicating visible adjacent text — fixing one can trigger the other."
        }
      ]
    },
    "image-redundant-alt": {
      "fix": {
        "description": "Remove or shorten the alt text when it duplicates adjacent visible text. Use alt='' to mark the image as decorative when adjacent text fully explains it.",
        "code": "<!-- Before: alt duplicates adjacent figcaption -->\n<figure>\n  <img src=\"chart.png\" alt=\"Bar chart showing Q1 2024 sales by region\">\n  <figcaption>Bar chart showing Q1 2024 sales by region</figcaption>\n</figure>\n\n<!-- After: empty alt — caption provides the description -->\n<figure>\n  <img src=\"chart.png\" alt=\"\">\n  <figcaption>Bar chart showing Q1 2024 sales by region</figcaption>\n</figure>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (redundant announcements increase cognitive load)",
      "expected": "Image alt text must not duplicate adjacent visible text. If adjacent text fully describes the image, use alt='' to mark it as decorative.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "axe flags exact or near-exact matches between alt and adjacent text — but verify the adjacent text is truly sufficient before setting alt=''. For charts, the figcaption may describe the title but not the data values — the image alt may still be needed. In <figure>/<figcaption> pairs, the figcaption typically replaces the alt for descriptive images, but for complex diagrams, consider aria-describedby pointing to a detailed description.",
      "framework_notes": {
        "react": "In React, CMS-driven content often auto-populates alt from the image title, which duplicates the adjacent heading. Use conditional alt: alt={caption ? '' : imageAlt} when a caption is present.",
        "vue": "In Vue, compute the alt conditionally: :alt='caption ? \"\" : imageAlt'. Avoid binding the same string to both alt and a figcaption.",
        "angular": "In Angular, use conditional binding: [attr.alt]='caption ? \"\" : imageAlt' to suppress redundant alt when a visible caption is present."
      },
      "manual_test": {
        "description": "Navigate to each image with a screen reader and verify the alt text adds value beyond adjacent visible text.",
        "steps": [
          "Navigate over each image — the screen reader announces the alt text.",
          "If the same text was already announced as adjacent content (heading, caption, paragraph), the alt is redundant — set alt=''.",
          "Verify that images with alt='' are truly decorative and their full context is communicated by surrounding visible text."
        ]
      }
    },
    "input-button-name": {
      "fix": {
        "description": "Add a value attribute or aria-label to every <input type='button'>, <input type='submit'>, and <input type='reset'>.",
        "code": "<!-- Input buttons use value as accessible name: -->\n<input type=\"submit\" value=\"Submit order\">\n<input type=\"reset\" value=\"Clear form\">\n<input type=\"button\" value=\"Load more results\">\n\n<!-- If value must stay empty for visual reasons, use aria-label: -->\n<input type=\"submit\" value=\"\" aria-label=\"Submit order\">"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "Input elements with type 'button', 'submit', or 'reset' must have a non-empty accessible name via the value attribute or aria-label.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "For <input type='submit'> and <input type='reset'>, browsers provide default labels ('Submit' and 'Reset') when value is omitted — axe may or may not flag these depending on context. Prefer explicit value attributes over browser defaults, as default labels are not consistently translated across locales. Prefer <button type='submit'> over <input type='submit'> for new code — it is more flexible.",
      "framework_notes": {
        "react": "In React, use the value prop: <input type='submit' value='Submit order' />. For modern React, prefer <button type='submit'>Submit order</button> — it supports child elements (icons, spans) and is more styleable.",
        "vue": "In Vue, use value='Submit order' or :value='submitLabel' for dynamic labels. Prefer <button type='submit'> over <input type='submit'> for greater flexibility.",
        "angular": "In Angular, use [value]='submitLabel' or a static value attribute. Angular Material's mat-button directives work on <button> — prefer <button> for all interactive controls."
      },
      "related_rules": [
        {
          "id": "button-name",
          "reason": "The same accessible name requirement applies to <button> elements — fix all button naming violations together."
        },
        {
          "id": "link-name",
          "reason": "The same accessible name requirement applies to links — fix all interactive element naming together."
        }
      ],
      "manual_test": {
        "description": "Tab to the input button and verify the screen reader announces a meaningful label.",
        "steps": [
          "Tab to the <input type='submit'> or <input type='button'>.",
          "The AT must announce the button label and role (e.g., 'Submit order, button').",
          "If only 'button' is announced with no label, the value attribute is missing or empty."
        ]
      }
    },
    "input-image-alt": {
      "fix": {
        "description": "Add an alt attribute to every <input type=\"image\"> describing the action it performs.",
        "code": "<input type=\"image\" src=\"submit.png\" alt=\"Submit form\">"
      },
      "effort": "low",
      "impacted_users": "Blind users relying on screen readers",
      "expected": "Every <input type=\"image\"> must have an alt attribute describing the button's action.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The alt must describe the button's action, not the image appearance. 'Submit form' is correct; 'Blue arrow pointing right' is not.",
      "manual_test": {
        "description": "Tab to the image input and verify the screen reader announces the action.",
        "steps": [
          "Tab to the <input type=\"image\"> — the screen reader must announce the alt text.",
          "Confirm the alt text describes the action (e.g., 'Submit form'), not the image appearance.",
          "If no screen reader is available, inspect the alt attribute in DevTools."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The same alt text requirement applies to <img> — fix all alt text violations together."
        },
        {
          "id": "svg-img-alt",
          "reason": "SVGs used as images share the same accessible name requirement."
        }
      ]
    },
    "label": {
      "fix": {
        "description": "Associate every form input with a visible <label> element.",
        "code": "<label for=\"email\">Email address</label>\n<input id=\"email\" type=\"email\" name=\"email\">"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "Every form input must have an associated <label>, aria-label, or aria-labelledby.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "aria-label works technically but voice control users cannot target the field by speaking the label — they need a visible text match. Prefer a visible <label> over aria-label for all inputs. placeholder is not a substitute for a label — it disappears on input and is not reliably announced by screen readers.",
      "framework_notes": {
        "react": "Use htmlFor prop (not 'for') on <label>: <label htmlFor=\"email\">Email</label>. The 'for' attribute is reserved in JSX.",
        "vue": "Use the standard for attribute: <label for=\"email\">. Vue renders standard HTML — no special prop needed.",
        "angular": "Use [for]=\"inputId\" binding or wrap the input inside the label element to avoid explicit ID linking."
      },
      "related_rules": [
        {
          "id": "select-name",
          "reason": "The same label association pattern resolves select-name violations."
        },
        {
          "id": "autocomplete-valid",
          "reason": "Properly labeled inputs should also have correct autocomplete tokens — fix label association and autocomplete together."
        },
        {
          "id": "form-field-multiple-labels",
          "reason": "Fixing label association may expose or create multiple-label conflicts — audit both together."
        },
        {
          "id": "label-content-name-mismatch",
          "reason": "The visible label text must match the accessible name — fix label association and name mismatch together."
        }
      ],
      "manual_test": {
        "description": "Click the label text to ensure focus moves to the input.",
        "steps": [
          "Click the text label.",
          "If the input field doesn't gain focus, the label is not correctly associated (missing 'for' or 'id' match)."
        ]
      }
    },
    "label-content-name-mismatch": {
      "fix": {
        "description": "Ensure the element's accessible name contains or starts with the visible label text so voice control users can activate it by speaking what they see.",
        "code": "<!-- Visible label: 'Search products' -->\n<!-- aria-label must contain that text: -->\n<button aria-label=\"Search products\">Search products</button>\n\n<!-- Or remove aria-label and rely on visible text: -->\n<button>Search products</button>\n\n<!-- If icon + text: make aria-label match the visible text -->\n<button aria-label=\"Search products\">\n  <svg aria-hidden=\"true\">...</svg>\n  Search products\n</button>"
      },
      "effort": "low",
      "impacted_users": "Voice control users (Dragon NaturallySpeaking, iOS Voice Control)",
      "expected": "The accessible name of interactive elements must contain the visible label text (WCAG 2.5.3).",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "The accessible name must contain (not just match) the visible text — it can have additional context. For example, aria-label='Search products in catalog' on a button with visible text 'Search products' is valid. The violation is when aria-label completely replaces the visible label with different text (e.g., visible 'Buy now', aria-label='Add to cart'). The simplest fix is often to remove the aria-label and let the visible text serve as the accessible name.",
      "framework_notes": {
        "react": "In React, avoid aria-label props that differ from the button's child text. For icon buttons, if you add visible text alongside the icon, the aria-label becomes unnecessary — remove it.",
        "vue": "In Vue, check components that accept both a label slot and an aria-label prop — if both are provided with different values, this violation occurs. Prefer deriving the accessible name from the visible slot content.",
        "angular": "In Angular, aria-label bindings on buttons with text content are a common source of this violation. Remove [attr.aria-label] on buttons that have visible text children unless the label extends the text rather than replacing it."
      },
      "manual_test": {
        "description": "Test activation by speaking the visible label using Voice Control or Dragon.",
        "steps": [
          "Enable iOS Voice Control or Dragon NaturallySpeaking.",
          "Speak the visible button or link text exactly as it appears on screen.",
          "If the element is not activated, the accessible name does not match the visible label — a mismatch exists.",
          "In DevTools Accessibility panel, compare the 'Name' field against the visible text."
        ]
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "Fixing label association is the primary step before resolving name mismatch."
        },
        {
          "id": "form-field-multiple-labels",
          "reason": "Multiple labels frequently cause accessible name to differ from visible label text."
        }
      ]
    },
    "landmark-no-duplicate-banner": {
      "fix": {
        "description": "Ensure only one <header> element (or role='banner') exists at the top level of the page, outside of sectioning elements.",
        "code": "<body>\n  <!-- One top-level header (banner landmark): -->\n  <header><!-- site-wide header --></header>\n  <main>\n    <!-- Nested headers inside article/section do NOT create banner landmarks: -->\n    <article>\n      <header>Article header — not a banner landmark</header>\n    </article>\n  </main>\n  <footer>...</footer>\n</body>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by landmarks",
      "expected": "A page must not have more than one banner landmark (<header> at top level or role='banner').",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "A <header> element only creates a banner landmark when it is a direct child of <body> (not nested inside <article>, <aside>, <main>, <nav>, or <section>). axe may flag this when a layout component renders two <header> tags at body level — one for a skip link area and one for the visible site header. Consolidate them into one top-level <header>.",
      "framework_notes": {
        "react": "In Next.js App Router, the root layout (layout.tsx) should have exactly one <header> at the top level. Page components must not add a second top-level <header> — use <section> or <div> for page-specific header areas.",
        "vue": "In Nuxt, the global <header> belongs in layouts/default.vue. Individual page components must not render a top-level <header> — use <section aria-labelledby='...'>.",
        "angular": "In Angular, app.component.html should contain exactly one top-level <header>. Route components must not add a second <header> at the document root level."
      },
      "related_rules": [
        {
          "id": "landmark-no-duplicate-main",
          "reason": "Fix all duplicate landmark violations together — they share the same root cause in layout architecture."
        },
        {
          "id": "landmark-one-main",
          "reason": "Landmark structure issues are often co-located — fix them as a group."
        }
      ],
      "manual_test": {
        "description": "Verify only one banner landmark exists using screen reader landmark navigation.",
        "steps": [
          "In NVDA, press D to cycle through landmarks — 'banner' should appear only once.",
          "In VoiceOver, use Ctrl+Opt+U, navigate to Landmarks — 'banner' or 'header' must be listed only once.",
          "In DevTools Console: document.querySelectorAll('body > header, [role=\"banner\"]').length — expect 1."
        ]
      }
    },
    "landmark-no-duplicate-main": {
      "fix": {
        "description": "Ensure only one <main> element (or role='main') exists on the page. If multiple content areas are needed, use <section> with unique aria-labelledby.",
        "code": "<main id=\"main-content\">\n  <!-- all primary page content -->\n  <section aria-labelledby=\"section-a-heading\">\n    <h2 id=\"section-a-heading\">Section A</h2>\n  </section>\n  <section aria-labelledby=\"section-b-heading\">\n    <h2 id=\"section-b-heading\">Section B</h2>\n  </section>\n</main>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by landmarks",
      "expected": "A page must not have more than one main landmark (<main> or role='main'). Multiple main landmarks break skip navigation.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "In SPAs, a second <main> commonly appears when a layout component defines one and a page component adds another. The fix is to ensure only the layout component owns the <main> wrapper, and page components render their content inside it without adding a second <main>.",
      "framework_notes": {
        "react": "In Next.js App Router, <main> belongs in layout.tsx, not in page.tsx. Individual page components render content inside the layout's <main> — never add a second <main> inside a page component.",
        "vue": "In Nuxt, <main> belongs in layouts/default.vue wrapping <slot />. Page components must not add a <main> wrapper.",
        "angular": "In Angular, <main> belongs in app.component.html wrapping <router-outlet>. Route component templates must not contain a second <main>."
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "landmark-one-main requires exactly one <main> — duplicate main violations are the inverse of the same requirement."
        },
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "Fix all duplicate landmark violations together."
        }
      ],
      "manual_test": {
        "description": "Confirm only one main landmark exists on the page.",
        "steps": [
          "Run in DevTools Console: document.querySelectorAll('main, [role=\"main\"]').length — expect 1.",
          "Navigate landmarks with a screen reader — 'main' should appear only once.",
          "For SPAs, check after each route transition — a second <main> may appear on specific routes."
        ]
      }
    },
    "landmark-one-main": {
      "fix": {
        "description": "Add a <main> landmark wrapping your page content.",
        "code": "<main id=\"main-content\">\n  <!-- page content -->\n</main>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by landmarks",
      "expected": "Page must contain exactly one <main> landmark element.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "SPAs often render the <main> landmark conditionally — in React, Vue Router, and Angular, the layout shell may not include <main> if each page component is responsible for its own layout. Ensure the root layout component (e.g., layout.tsx in Next.js, App.vue in Vue, app.component.html in Angular) always wraps page content in <main>, not individual page components. Axe may also flag SPA routes where <main> is rendered client-side after the initial snapshot.",
      "framework_notes": {
        "react": "Place <main id='main-content'> in the root layout component (app/layout.tsx in Next.js App Router, or the root App component). Do not place <main> in individual page components — it will be missing for routes that render before the layout mounts.",
        "vue": "Add <main id='main-content'> to the root layout component (App.vue or layouts/default.vue in Nuxt), wrapping <router-view /> or <slot />. Nuxt: set it in layouts/default.vue.",
        "angular": "Add <main id='main-content'> in app.component.html wrapping <router-outlet>. This ensures the landmark is present for all routes and the skip link target resolves correctly."
      },
      "related_rules": [
        {
          "id": "bypass",
          "reason": "The skip link target (#main-content) should reference the <main> landmark."
        },
        {
          "id": "region",
          "reason": "Adding <main> may resolve orphan-content region violations."
        }
      ],
      "manual_test": {
        "description": "Verify that the page content is structurally contained within the main landmark.",
        "steps": [
          "Open the accessibility tree in DevTools.",
          "Locate the 'main' role element.",
          "Ensure it contains all unique page content (excluding header/footer)."
        ]
      }
    },
    "landmark-unique": {
      "fix": {
        "description": "Add unique accessible labels to landmarks of the same type using aria-label or aria-labelledby.",
        "code": "<nav aria-label=\"Primary navigation\">\n  <!-- main site links -->\n</nav>\n\n<nav aria-label=\"Breadcrumb\">\n  <!-- breadcrumb trail -->\n</nav>\n\n<nav aria-label=\"Footer links\">\n  <!-- footer navigation -->\n</nav>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by landmarks",
      "expected": "When multiple landmarks of the same type exist (e.g., multiple <nav> elements), each must have a unique accessible label.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "This applies to nav, aside, section with role, and form landmarks — any type appearing more than once. Keep labels short and descriptive: 'Primary', 'Footer', 'Breadcrumb'. Do not add aria-label to <main> or <header> unless they are duplicated (which is itself a separate violation). The label becomes part of the AT announcement: 'Primary navigation, navigation landmark'.",
      "framework_notes": {
        "react": "In React, pass the aria-label prop to navigation components: <Nav aria-label='Primary navigation'>. Ensure the component forwards the prop to the native <nav> element via spread or explicit prop.",
        "vue": "In Vue, bind aria-label directly on <nav>: <nav aria-label='Primary navigation'>. Navigation components should accept and forward an aria-label prop to the root <nav>.",
        "angular": "In Angular, use aria-label='Primary navigation' or [attr.aria-label]='navLabel' on <nav> elements. Shared navigation components should accept an @Input() ariaLabel string and bind it."
      },
      "related_rules": [
        {
          "id": "landmark-no-duplicate-banner",
          "reason": "If duplicate banners exist, add aria-label to each — or eliminate the duplicate."
        },
        {
          "id": "bypass",
          "reason": "Unique landmark labels enhance skip navigation — users can jump directly to a specific landmark."
        }
      ],
      "manual_test": {
        "description": "Navigate all landmarks and verify each has a unique, descriptive label.",
        "steps": [
          "In VoiceOver, press Ctrl+Opt+U and navigate to Landmarks — confirm each entry has a distinct label.",
          "In NVDA, press R to cycle through regions — duplicate labels (two unlabeled 'navigation' entries) indicate missing aria-label.",
          "Identify all <nav>, <aside>, and <section> elements — verify each has a unique aria-label or aria-labelledby."
        ]
      }
    },
    "link-name": {
      "fix": {
        "description": "Use descriptive link text that conveys the destination or purpose. Avoid \"click here\" or \"read more\".",
        "code": "<a href=\"/products\">View our product catalog</a>\n<!-- Avoid: <a href=\"/products\">click here</a> -->"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "Every <a href> must have descriptive, non-empty text content or an aria-label.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Adding aria-label to a link that already has visible text creates a mismatch — voice control users speak the visible text, not the aria-label, and activation may fail. Use aria-label only for icon links with no visible text, or use aria-labelledby to reference visible content.",
      "framework_notes": {
        "react": "In React Router, use <Link to='/path'>Descriptive text</Link>. For icon links, add aria-label directly: <Link to='/search' aria-label='Search products'>. Avoid wrapping <Link> around empty or icon-only elements without an aria-label.",
        "vue": "In Vue Router, use <RouterLink to='/path'>Descriptive text</RouterLink>. For icon links, add :aria-label='...' on the RouterLink component.",
        "angular": "Use the routerLink directive on native <a> elements: <a routerLink='/path'>Descriptive text</a>. The native <a> carries the correct link role and accessible name automatically."
      },
      "manual_test": {
        "description": "Examine the link text in isolation.",
        "steps": [
          "Open the links list in a screen reader (e.g., JAWS Key + F7).",
          "Check if links like 'Read More' are distinguishable without their surrounding text."
        ]
      },
      "related_rules": [
        {
          "id": "button-name",
          "reason": "The same accessible name requirement applies to buttons — fix all interactive element naming together."
        },
        {
          "id": "input-button-name",
          "reason": "The same accessible name requirement applies to <input type=\"button\"> — fix all naming violations together."
        }
      ]
    },
    "list": {
      "fix": {
        "description": "Ensure <ul> and <ol> elements contain only <li> children (and optionally <script> or <template>). Remove or rewrap invalid direct children.",
        "code": "<!-- Before: div inside ul (invalid) -->\n<ul>\n  <div class=\"list-item\">Item 1</div>\n  <div class=\"list-item\">Item 2</div>\n</ul>\n\n<!-- After: proper li elements -->\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (list item count and navigation)",
      "expected": "<ul> and <ol> must only contain <li> elements as direct children. Screen readers use this structure to announce the list count and enable list navigation.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "Some CSS frameworks (Bootstrap, Tailwind) output <div> wrappers inside list elements via JavaScript-rendered components. axe will flag these. Before fixing, check whether the violation is in source HTML or in framework-rendered output — the fix location differs. Also note: a <ul> with role='none' on all <li> children (to remove list semantics) is an intentional pattern and not a violation of this rule.",
      "framework_notes": {
        "react": "In React, mapping an array to list items is straightforward: {items.map(item => <li key={item.id}>{item.name}</li>)}. Never wrap the map in an extra <div> inside <ul> — use React.Fragment or a flat map.",
        "vue": "In Vue, use v-for directly on <li>: <li v-for='item in items' :key='item.id'>{{ item.name }}</li>. Avoid adding a wrapper component between <ul> and <li>.",
        "angular": "In Angular, use *ngFor directly on <li>: <li *ngFor='let item of items'>{{ item.name }}</li>. Component wrappers between <ul> and <li> will introduce invalid children."
      },
      "related_rules": [
        {
          "id": "listitem",
          "reason": "The inverse rule — li elements must be inside a ul/ol. Fix list structure violations together."
        }
      ],
      "manual_test": {
        "description": "Verify a screen reader announces the correct list count and enables list navigation.",
        "steps": [
          "Navigate to the list with VoiceOver or NVDA — the AT should announce 'list, X items'.",
          "If no item count is announced or the list role is absent, the structure is broken.",
          "In DevTools, inspect the <ul> or <ol> and verify all direct children are <li> elements."
        ]
      }
    },
    "listitem": {
      "fix": {
        "description": "Wrap orphan <li> elements inside a <ul> or <ol> parent, or change the element to a non-list element if list semantics are not intended.",
        "code": "<!-- Before: li without a list parent -->\n<li>Item 1</li>\n<li>Item 2</li>\n\n<!-- After: wrapped in ul -->\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n\n<!-- Or if list semantics not intended: -->\n<p>Item 1</p>\n<p>Item 2</p>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (invalid list structure causes incorrect announcements)",
      "expected": "<li> elements must be direct children of <ul>, <ol>, or <menu> elements.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "This often occurs in component-based frameworks when a list item component renders <li> at the root but is used outside a parent list component. The fix is either to ensure the parent always provides a <ul>/<ol> context, or to restructure the component so <li> is not the root element when rendered standalone.",
      "framework_notes": {
        "react": "In React, a component that returns <li> must always be rendered inside a <ul> or <ol>. If the component can be used in contexts without a list parent, consider making it return a generic container and letting the parent decide whether to wrap in <ul>.",
        "vue": "In Vue, a <li> component must have a <ul> or <ol> as its direct DOM parent. Vue's component wrapper does not count as a list — verify the rendered HTML structure in DevTools, not just the Vue template.",
        "angular": "In Angular, an <li> component inside <app-list-item> is still a valid <li> in the rendered DOM if the component tag is replaced. Verify the rendered output — Angular component tags are replaced, so check the actual HTML tree."
      },
      "related_rules": [
        {
          "id": "list",
          "reason": "Inverse rule — fix list/listitem violations together to restore correct list semantics."
        }
      ],
      "manual_test": {
        "description": "Inspect the rendered DOM to confirm li elements have valid list parents.",
        "steps": [
          "In DevTools, right-click an <li> and 'Inspect' — verify the parent element is a <ul>, <ol>, or <menu>.",
          "Run in Console: [...document.querySelectorAll('li')].filter(li => !['UL','OL','MENU'].includes(li.parentElement.tagName)) — non-empty = orphan li elements.",
          "With a screen reader, navigate to the flagged area — orphan li elements may be announced without list context."
        ]
      }
    },
    "meta-refresh": {
      "fix": {
        "description": "Remove automatic page refresh. If redirecting immediately, a delay of 0 is permitted.",
        "code": "<!-- Remove this: -->\n<!-- <meta http-equiv=\"refresh\" content=\"5; url=...\"> -->\n\n<!-- Instant redirect only (delay=0 is OK): -->\n<meta http-equiv=\"refresh\" content=\"0; url=https://example.com/new-page\">"
      },
      "effort": "low",
      "impacted_users": "Users with cognitive disabilities and screen reader users",
      "expected": "Pages must not auto-refresh or auto-redirect with a non-zero delay (WCAG 2.2.2).",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Server-side HTTP redirects (301/302) do not use <meta http-equiv='refresh'> and are not flagged by this rule. The violation only occurs when a timed redirect is implemented in the HTML <head>. A delay of 0 (instant redirect) is the only permitted use — it is commonly used for canonical URL normalization and is WCAG-compliant.",
      "framework_notes": {
        "react": "In Next.js, use redirect() in server components or middleware for redirects, and useRouter().replace() for client-side navigation. Neither uses <meta http-equiv='refresh'>. Never insert a meta refresh tag.",
        "vue": "In Nuxt, use navigateTo() or definePageMeta({ redirect: '/' }) — both produce server or router-level redirects without <meta http-equiv='refresh'>.",
        "angular": "Use the Angular Router service (this.router.navigate() or this.router.navigateByUrl()) for all navigation. Never insert <meta http-equiv='refresh'> into templates or index.html."
      },
      "manual_test": {
        "description": "Confirm the page does not reload or redirect without user interaction.",
        "steps": [
          "Load the page and wait 30 seconds — it must not refresh automatically.",
          "Check the <head> for <meta http-equiv=\"refresh\"> with a non-zero delay.",
          "Search JavaScript for setInterval/setTimeout calls that trigger window.location changes."
        ]
      }
    },
    "meta-viewport": {
      "fix": {
        "description": "Remove user-scalable=no from the viewport meta tag to allow users to zoom.",
        "code": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"
      },
      "effort": "low",
      "impacted_users": "Users who need to zoom (low vision, motor disabilities)",
      "expected": "Viewport meta must not disable user scaling (user-scalable=no is forbidden).",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "iOS Safari (10+) ignores user-scalable=no as an accessibility override, but Android browsers may enforce it. Remove it unconditionally — there is no valid accessibility reason to block zoom, and it is explicitly forbidden by WCAG 1.4.4.",
      "framework_notes": {
        "react": "In Next.js App Router, manage the viewport meta via the Metadata API: export const viewport: Viewport = { width: 'device-width', initialScale: 1 }; in layout.tsx. Never set maximumScale: 1 or userScalable: false — these block zoom.",
        "vue": "In Nuxt, set the viewport in nuxt.config.ts: app.head.meta = [{ name: 'viewport', content: 'width=device-width, initial-scale=1' }]. Omit user-scalable=no entirely.",
        "angular": "The viewport meta is in index.html. Remove user-scalable=no if present: <meta name='viewport' content='width=device-width, initial-scale=1'>. Do not add maximum-scale=1 either — it has the same effect."
      },
      "manual_test": {
        "description": "Verify the page can be zoomed to 400% without horizontal scrolling on a 1280px viewport.",
        "steps": [
          "Open the page in Chrome and press Ctrl/Cmd + '+' repeatedly until 400% zoom.",
          "Confirm all content reflows vertically — no horizontal scrollbar should appear.",
          "On a mobile device, pinch-to-zoom must not be blocked."
        ]
      }
    },
    "nested-interactive": {
      "fix": {
        "description": "Remove or restructure nested interactive elements. Interactive controls (buttons, links, inputs) must not be descendants of other interactive controls.",
        "code": "<!-- Before: button inside a link (invalid) -->\n<a href=\"/product\">\n  Product name\n  <button onclick=\"addToCart()\">Add to cart</button>\n</a>\n\n<!-- After: separate elements -->\n<div class=\"product-card\">\n  <a href=\"/product\">Product name</a>\n  <button onclick=\"addToCart()\">Add to cart</button>\n</div>"
      },
      "effort": "medium",
      "impacted_users": "Keyboard-only users and screen reader users",
      "expected": "Interactive elements (a, button, input, select, textarea) must not be nested inside other interactive elements.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The most common pattern causing this is a 'card' component where the entire card is wrapped in an <a> tag and a button (e.g., 'Add to cart', 'Save') is placed inside. The HTML spec forbids interactive content inside <a>. Solutions: (1) use the 'stretched link' CSS pattern to make the <a> visually cover the card without wrapping the button, or (2) use JavaScript to handle card-level clicks while keeping elements separate in the DOM.",
      "framework_notes": {
        "react": "In React card components, avoid wrapping the entire JSX tree in <Link> or <a> when it contains interactive children. Use a CSS stretched-link pattern: position the <a> absolutely with ::after covering the card, while the button stays outside the <a> in DOM order.",
        "vue": "In Vue, the same pattern applies — <RouterLink> wrapping a card with buttons inside is invalid HTML. Use the stretched-link CSS technique or restructure the component so interactive children are siblings, not descendants, of the link.",
        "angular": "In Angular, wrapping <mat-card> or a template outlet in [routerLink] creates the same issue. Set [routerLink] on a visible text element or use a CSS overlay approach to preserve DOM structure."
      },
      "manual_test": {
        "description": "Tab into the nested element and verify both the outer and inner interactive elements are individually focusable and operable.",
        "steps": [
          "Tab to the flagged element — note which element receives focus first.",
          "Press Tab again — verify the inner interactive element also receives focus separately.",
          "Press Enter or Space on each — confirm they perform their intended actions independently.",
          "Test with a screen reader: both the link and the button should be announced as separate interactive elements."
        ]
      }
    },
    "no-autoplay-audio": {
      "fix": {
        "description": "Remove the autoplay attribute from audio elements, or provide a clearly visible pause/stop control that activates before 3 seconds of audio plays.",
        "code": "<!-- Remove autoplay: -->\n<audio controls src=\"background.mp3\"></audio>\n\n<!-- Background video: muted is acceptable -->\n<video autoplay muted loop src=\"bg-video.mp4\"></video>\n\n<!-- If autoplay with sound is required, provide an immediate stop control: -->\n<audio autoplay id=\"bg-audio\" src=\"jingle.mp3\"></audio>\n<button onclick=\"document.getElementById('bg-audio').pause()\" style=\"position:fixed;top:1rem;right:1rem\">Stop audio</button>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (audio conflicts with AT speech), users with cognitive disabilities, users with vestibular disorders",
      "expected": "Audio that plays automatically must stop within 3 seconds, or a mechanism to pause/stop/mute it must be provided at the start of the page (WCAG 1.4.2).",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "axe detects the autoplay attribute but cannot determine whether the audio is muted — muted autoplay is acceptable. A <video autoplay muted loop> for decorative background video does not violate WCAG 1.4.2. The violation is specifically audio content that plays without user interaction and cannot be immediately stopped. Browser autoplay policies (especially Chrome) often block autoplay with sound anyway — verify the audio actually plays in the target browser before treating it as a confirmed violation.",
      "framework_notes": {
        "react": "In React, never set the autoPlay prop on <audio> for content with meaningful audio. Background decorative video with autoPlay muted is acceptable. Trigger audio playback programmatically via user interaction events, not in useEffect on mount.",
        "vue": "In Vue, avoid :autoplay='true' on audio elements. Trigger audio playback via @click handlers. Background video with autoplay muted as static attributes is acceptable.",
        "angular": "In Angular, do not bind [autoplay]='true' on audio elements. Trigger .play() calls inside (click) event handlers, not in ngOnInit lifecycle hooks."
      },
      "manual_test": {
        "description": "Load the page and immediately test whether audio plays without user interaction.",
        "steps": [
          "Open the page with a screen reader active — if audio plays, it will conflict with the AT speech.",
          "Check for a visible stop/pause control that appears before the audio has played for 3 seconds.",
          "Inspect the page source for <audio autoplay> or JavaScript .play() calls on page load.",
          "Confirm muted autoplay video produces no sound — muted is WCAG-compliant."
        ]
      }
    },
    "object-alt": {
      "fix": {
        "description": "Add an aria-label to every <object> element describing its content.",
        "code": "<object data=\"chart.svg\" type=\"image/svg+xml\" aria-label=\"Bar chart: Q1 2024 sales by region\">\n  Fallback text for unsupported browsers\n</object>"
      },
      "effort": "low",
      "impacted_users": "Blind users relying on screen readers",
      "expected": "Every <object> must have an accessible name via aria-label or aria-labelledby.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The <object> element is rarely used in modern development — most use cases (SVG, PDF, media) are better served by <img>, <video>, <embed>, or <iframe>. If <object> is used, the aria-label must describe what the embedded content communicates to the user (not just the file type or format). If the object is purely decorative, consider replacing it with an accessible equivalent (e.g., an <img> with alt='').",
      "manual_test": {
        "description": "Verify a screen reader announces the object's accessible name.",
        "steps": [
          "Tab to the <object> element with VoiceOver or NVDA active.",
          "The screen reader must announce the label and the element type.",
          "If the object is purely decorative, consider replacing it with an equivalent image with alt=\"\"."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The same text alternative requirement applies to <img> — audit both together."
        }
      ]
    },
    "p-as-heading": {
      "fix": {
        "description": "Replace <p> elements styled to look like headings with actual heading elements (<h1>–<h6>) at the appropriate level in the document hierarchy.",
        "code": "<!-- Before: paragraph styled as heading -->\n<p class=\"text-2xl font-bold\">Section Title</p>\n<p>Content paragraph...</p>\n\n<!-- After: semantic heading -->\n<h2>Section Title</h2>\n<p>Content paragraph...</p>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by headings",
      "expected": "Text that visually functions as a section heading must be marked up with a heading element (<h1>–<h6>), not a styled paragraph.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "axe detects this heuristically — it flags <p> elements with large, bold, or otherwise heading-like CSS properties. This can produce false positives on intro paragraphs, pull quotes, or callout boxes that are intentionally styled large. Verify visually: does this text introduce a new section of content? If yes, it should be a heading. If it is decorative, a caption, or a lead-in paragraph, it may not need to be a heading despite the styling.",
      "framework_notes": {
        "react": "In component libraries (shadcn/ui, Radix), heading-like components sometimes render as <p> by default. Use the 'as' prop or the 'asChild' pattern to change the rendered element: <Text as='h2' className='text-2xl font-bold'>Section Title</Text>.",
        "vue": "In Vue UI kits (Vuetify, Nuxt UI), check if the heading-like component supports a 'tag' prop: <VTitle tag='h2'>Section Title</VTitle>. Without it, add the heading element directly in the template.",
        "angular": "In Angular, heading-like components often render as <div> or <p>. Use the component's selector or a host element attribute to change the rendered tag, or apply the heading element directly in the template rather than relying on the component's default tag."
      },
      "related_rules": [
        {
          "id": "heading-order",
          "reason": "After converting p-as-heading to real headings, verify the heading hierarchy is correct — new headings must fit the existing order."
        },
        {
          "id": "page-has-heading-one",
          "reason": "If converting a p-as-heading introduces a new h1, verify it is the only h1 on the page."
        }
      ],
      "manual_test": {
        "description": "Navigate the page using only the heading shortcut in a screen reader and confirm all section labels are reachable.",
        "steps": [
          "Use NVDA/JAWS (H key) or VoiceOver (Cmd+Fn+Right) to jump between headings.",
          "If a visually prominent section label is skipped (not reachable by heading navigation), it is a p-as-heading violation.",
          "Visually inspect large, bold text that appears section-like — compare its element type in DevTools."
        ]
      }
    },
    "page-has-heading-one": {
      "fix": {
        "description": "Add exactly one <h1> as the primary page heading.",
        "code": "<h1>Main page heading</h1>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users navigating by headings",
      "expected": "Page must have exactly one <h1> element as the primary heading.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "In SPAs and SSR frameworks, the h1 may be injected client-side after the initial DOM snapshot axe evaluates. Ensure the h1 is server-side rendered or present in the initial HTML payload. In Next.js, place the h1 directly in the page component, not behind a loading state.",
      "framework_notes": {
        "react": "In Next.js App Router, place the h1 directly in page.tsx, not in a client component that renders conditionally or inside a Suspense loading state — axe evaluates the initial HTML payload before client hydration fills the loading boundary.",
        "vue": "In Nuxt, ensure the page-level h1 is in the <template> of the page component so it is included in the server-rendered HTML. Avoid placing the h1 exclusively inside an async component that renders after the initial paint.",
        "angular": "With Angular Universal (SSR), the h1 must be part of the component template, not inserted via JavaScript after hydration. Verify the h1 is visible in the pre-rendered HTML using View Source."
      },
      "related_rules": [
        {
          "id": "heading-order",
          "reason": "Fixing the missing h1 anchors the heading hierarchy and may cascade-resolve heading-order violations."
        }
      ],
      "manual_test": {
        "description": "Confirm there is exactly one h1 per page — not zero, not two.",
        "steps": [
          "Open DevTools Console and run: document.querySelectorAll('h1').length — expect 1.",
          "For SPAs, navigate between routes and re-run the check after each transition.",
          "Read the h1 aloud — does it accurately describe the unique purpose of this page?"
        ]
      }
    },
    "redundant-entry": {
      "fix": {
        "description": "Do not require users to re-enter information already provided in the same session (WCAG 3.3.7). Pre-populate fields or provide a copy option.",
        "code": "<!-- Pre-populate from session data: -->\n<label for=\"ship-address\">Shipping address</label>\n<input id=\"ship-address\" type=\"text\" autocomplete=\"shipping street-address\"\n  value=\"{{ session.billing_address }}\">\n\n<!-- Or offer a checkbox: -->\n<label>\n  <input type=\"checkbox\" id=\"same-as-billing\">\n  Same as billing address\n</label>"
      },
      "effort": "high",
      "impacted_users": "Users with cognitive disabilities and motor disabilities",
      "expected": "Information already submitted during the same session must be auto-populated or selectable without requiring re-entry (WCAG 3.3.7).",
      "false_positive_risk": "high",
      "fix_difficulty_notes": "Automated tools cannot reliably detect this violation — they scan the static DOM of a single page without session context. Treat axe findings for this rule as a prompt for manual review, not a confirmed violation. Walk through multi-step flows manually to determine if previously entered data is unnecessarily re-requested.",
      "framework_notes": {
        "react": "Use React Context or a form state library (React Hook Form, Formik) to preserve data across multi-step flows. In Next.js, persist form state in URL search params or session storage to survive route transitions without requiring re-entry.",
        "vue": "Use Pinia or Vuex to share form data across route-separated steps. In Nuxt, useState() persists data between pages without a full store — useful for lightweight multi-step form state.",
        "angular": "Use an Angular service with a shared BehaviorSubject to carry form state across route-separated steps. Angular Reactive Forms do not automatically persist across route navigations — manual persistence via a service is required."
      },
      "manual_test": {
        "description": "Walk through a multi-step form and verify previously entered data is not requested again.",
        "steps": [
          "Complete step 1 of a multi-step flow (e.g., billing address).",
          "On step 2 (e.g., shipping), check if the same data is pre-populated or a 'same as above' option is provided.",
          "If neither is present, the WCAG 3.3.7 violation stands."
        ]
      }
    },
    "region": {
      "fix": {
        "description": "Wrap all visible content in semantic landmark elements.",
        "code": "<header><!-- header content --></header>\n<main><!-- main content --></main>\n<footer><!-- footer content --></footer>"
      },
      "effort": "medium",
      "impacted_users": "Screen reader users navigating by landmarks",
      "expected": "All visible page content must be contained within a landmark element (main, nav, header, footer, aside).",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "Decorative separators, spacer divs, and background containers do not need to be inside landmarks. Only meaningful visible content requires landmark wrapping. Review each flagged element before adding a landmark.",
      "framework_notes": {
        "react": "Use semantic JSX elements: <header>, <main>, <nav>, <aside>, <footer> instead of <div> wrappers. In Next.js App Router, landmarks naturally fall into layout.tsx (header/footer) and page.tsx (main content).",
        "vue": "Use semantic HTML5 elements in Vue templates — they work identically to plain HTML. In Nuxt, place <header> and <footer> in the layout component and wrap <slot /> in <main>.",
        "angular": "Angular adds a custom element wrapper (<app-root>, <app-header>) — ensure the semantic landmark element (<header>, <main>) is inside the component template, not expected to be provided by the custom wrapper."
      },
      "related_rules": [
        {
          "id": "landmark-one-main",
          "reason": "Adding a <main> landmark is typically the primary fix for orphan content."
        }
      ],
      "manual_test": {
        "description": "Check for content outside of landmarks using a screen reader or landmark extension.",
        "steps": [
          "Use a landmark bypass extension or screen reader command (e.g., 'R' in NVDA/JAWS).",
          "Ensure no 'orphan' content exists outside of landmark regions."
        ]
      }
    },
    "scrollable-region-focusable": {
      "fix": {
        "description": "Make scrollable regions keyboard-accessible by adding tabindex=\"0\" and a descriptive label.",
        "code": "<div tabindex=\"0\" role=\"region\" aria-label=\"Content section\" style=\"overflow: auto;\">\n  <!-- scrollable content -->\n</div>"
      },
      "effort": "low",
      "impacted_users": "Keyboard-only users",
      "expected": "Any element with scrollable overflow must be reachable via keyboard (tabindex=\"0\" or natively focusable).",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "This rule fires on any element with overflow:auto or overflow:scroll — including CSS clip containers, masked elements, and carousels that overflow visually but have no actual scrollable content. Before adding tabindex='0', confirm the element is genuinely scrollable (has overflow content) and that keyboard users need to scroll it. Adding tabindex='0' to a non-scrollable container adds unnecessary tab stops.",
      "manual_test": {
        "description": "Tab to the scrollable region and verify arrow keys scroll it.",
        "steps": [
          "Tab to the flagged element — keyboard focus must land on it.",
          "Press Arrow Down / Arrow Up — the content must scroll.",
          "Confirm a screen reader announces the region label when it receives focus."
        ]
      },
      "framework_notes": {
        "react": "Use a ref to check if the element actually overflows before adding tabIndex={0}. In React: const ref = useRef(); if (ref.current.scrollHeight > ref.current.clientHeight) add tabIndex. Avoid adding tabIndex to containers managed by virtual scroll libraries (react-window, react-virtual) — they handle keyboard internally.",
        "vue": "Use a template ref and check scrollHeight > clientHeight in onMounted before binding :tabindex='0'. CSS overflow containers created by v-show or transition wrappers may be flagged falsely — verify the element has genuine scroll content.",
        "angular": "Use @ViewChild and check nativeElement.scrollHeight > nativeElement.clientHeight in ngAfterViewInit. CDK ScrollingModule (VirtualScrollViewport) handles keyboard natively — do not add tabindex to its host element."
      },
      "related_rules": [
        {
          "id": "aria-hidden-focus",
          "reason": "Both affect keyboard focus — audit all focusability violations together to avoid conflicts."
        }
      ]
    },
    "select-name": {
      "fix": {
        "description": "Associate every <select> element with a visible <label>.",
        "code": "<label for=\"country\">Country</label>\n<select id=\"country\" name=\"country\">\n  <option value=\"us\">United States</option>\n</select>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users and voice control users",
      "expected": "Every <select> must have an accessible name via <label>, aria-label, or aria-labelledby.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "In design systems, <select> is commonly replaced with a custom dropdown (a div/button combination). If the custom dropdown lacks role='listbox', aria-expanded, and aria-labelledby pointing to the visible label, none of the standard label association patterns apply. Prefer the native <select> element wherever possible — it carries all required implicit accessibility semantics.",
      "framework_notes": {
        "react": "Use htmlFor on <label> pointing to the select's id. For custom select components (react-select, Headless UI Listbox), pass the accessible name via their label prop or aria-labelledby — these components use the combobox/listbox ARIA pattern internally.",
        "vue": "Native <select> uses standard <label for='id'>. For custom select components (Headless UI Listbox, Floating Vue Select), pass a label via their label prop — the component handles aria-labelledby internally.",
        "angular": "In Angular Material, <mat-select> is labeled via <mat-label> inside <mat-form-field>. For standalone <select> elements, use <label [for]='selectId'>Label</label>."
      },
      "related_rules": [
        {
          "id": "label",
          "reason": "The same label association pattern applies — fix label rule to resolve both."
        }
      ],
      "manual_test": {
        "description": "Focus the select and verify the screen reader announces its label.",
        "steps": [
          "Tab to the <select> with VoiceOver or NVDA active.",
          "The announcement must include both the label name and 'combo box' role.",
          "Click the label text — focus must move to the select input."
        ]
      }
    },
    "svg-img-alt": {
      "fix": {
        "description": "Add an accessible name to informative SVGs using role='img' and aria-label. For decorative SVGs, use aria-hidden='true'.",
        "code": "<!-- Informative SVG (icon conveying meaning): -->\n<svg role=\"img\" aria-label=\"Shopping cart — 3 items\" focusable=\"false\">\n  <!-- svg paths -->\n</svg>\n\n<!-- Decorative SVG (visual only, adjacent text explains it): -->\n<svg aria-hidden=\"true\" focusable=\"false\">\n  <!-- svg paths -->\n</svg>"
      },
      "effort": "medium",
      "impacted_users": "Blind users relying on screen readers",
      "expected": "SVG elements used as images must have an accessible name (aria-label or aria-labelledby). Decorative SVGs must be hidden from AT with aria-hidden='true'.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "Most SVGs in UI are decorative (icons next to visible button text, background illustrations). axe may flag them as missing an alt even when the adjacent text is sufficient. The decision is: does this SVG convey meaning that is NOT expressed in adjacent visible text? If yes → aria-label. If no → aria-hidden='true'. Never add aria-label that duplicates adjacent text — this creates redundant announcements.",
      "framework_notes": {
        "react": "In React, SVG components commonly strip accessibility attributes. Add role='img' and aria-label directly on the <svg> element: <svg role='img' aria-label='Close' aria-hidden={undefined}>. Icon libraries like Heroicons and Lucide expose aria-hidden and aria-label props.",
        "vue": "In Vue, pass aria-hidden='true' or aria-label as attributes on the <svg> component. Most Vue icon libraries (unplugin-icons, vue-feather) accept these as standard HTML attributes.",
        "angular": "In Angular Material, <mat-icon> renders an SVG or ligature — it sets aria-hidden by default. For standalone SVG components, use [attr.aria-label]='label' and [attr.aria-hidden]='isDecorative'."
      },
      "manual_test": {
        "description": "Determine whether each SVG communicates content not expressed in adjacent text.",
        "steps": [
          "Tab to each SVG in the page — with VoiceOver or NVDA active, note what is announced.",
          "If the SVG is informative and nothing is announced, aria-label is missing.",
          "If the SVG is decorative and its label is read aloud (duplicating adjacent text), add aria-hidden='true'.",
          "Check SVG children: <title> inside an SVG provides an accessible name in some browsers/AT combinations — verify it is reliably picked up before relying on it."
        ]
      },
      "related_rules": [
        {
          "id": "image-alt",
          "reason": "The same alt text requirement applies to <img> — fix all alt text violations together."
        },
        {
          "id": "image-redundant-alt",
          "reason": "When adding aria-label to SVGs, avoid duplicating visible adjacent text."
        }
      ]
    },
    "tabindex": {
      "fix": {
        "description": "Remove positive tabindex values. Use tabindex=\"0\" to include in natural tab order, tabindex=\"-1\" to exclude.",
        "code": "<!-- Include in natural tab order: -->\n<div role=\"button\" tabindex=\"0\">Focusable element</div>\n<!-- Programmatically focusable only: -->\n<div tabindex=\"-1\">Focus via script only</div>"
      },
      "effort": "low",
      "impacted_users": "Keyboard-only users",
      "expected": "tabindex values must be 0 or -1. Positive values disrupt natural focus order.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "Positive tabindex values (tabindex='1', tabindex='2') create a separate focus sequence that runs before the natural DOM order. All positive-tabindex elements are visited first, then everything else. This almost always breaks focus flow. Remove all positive tabindex values and reorder the DOM instead if a different focus sequence is needed.",
      "framework_notes": {
        "react": "In JSX, the attribute is camelCase: tabIndex={0} or tabIndex={-1}. Never use positive integers. For programmatically managed focus (e.g., opening a modal), call element.focus() instead of relying on tabIndex values greater than 0.",
        "vue": "Use :tabindex='0' or tabindex='-1' in Vue templates. Do not expose a tabindex prop that accepts positive integers — validate the value at the component level.",
        "angular": "Use [tabIndex]='value' for dynamic binding, ensuring only 0 or -1 are bound. The Angular CDK FocusTrap handles sequential focus management within dialogs without requiring positive tabindex values."
      },
      "manual_test": {
        "description": "Tab through the page and verify focus order matches visual reading order.",
        "steps": [
          "Press Tab repeatedly from the top of the page — focus must move top-to-bottom, left-to-right.",
          "If focus jumps unexpectedly, inspect the tabindex attribute on the focused element.",
          "Confirm no element has tabindex > 0 in the source."
        ]
      }
    },
    "table-duplicate-name": {
      "fix": {
        "description": "Remove the summary attribute or change the caption text so the table caption and summary do not contain the same text.",
        "code": "<!-- Remove summary entirely (deprecated in HTML5) -->\n<table>\n  <caption>Sales data by region and quarter — columns are quarters Q1–Q4, rows are regions</caption>\n  ...\n</table>\n\n<!-- Or if summary must remain, use different text: -->\n<table summary=\"Use arrow keys to navigate rows and columns.\">\n  <caption>Sales data by region and quarter</caption>\n  ...\n</table>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (duplicate announcement of table description creates cognitive load)",
      "expected": "The <caption> and summary attribute of a table must not contain identical text — this causes screen readers to announce the same description twice.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The summary attribute is deprecated in HTML5 and should not be used in new code. The preferred pattern is to put all necessary description in the <caption> element. If legacy code uses both, the simplest fix is to remove the summary attribute entirely. For complex tables requiring navigation instructions, use aria-describedby pointing to a visible description paragraph adjacent to the table.",
      "framework_notes": {
        "react": "In React table components, avoid passing both caption and summary props with the same content. Remove the summary attribute entirely — it is deprecated.",
        "vue": "In Vue, do not bind :summary on <table>. Use <caption> for all table descriptions.",
        "angular": "In Angular, remove [attr.summary] bindings from table components. Migrate to <caption> with descriptive text or aria-describedby pointing to an adjacent description."
      },
      "manual_test": {
        "description": "Navigate to the table with a screen reader and verify the table description is announced only once.",
        "steps": [
          "Move screen reader focus into the table — the AT will announce the caption and/or summary.",
          "If the same text is announced twice in sequence, both caption and summary are set identically.",
          "Inspect the <table> element in DevTools for both a <caption> child and a summary attribute — remove the summary."
        ]
      }
    },
    "target-size": {
      "fix": {
        "description": "Interactive elements must have a minimum target size of 24×24 CSS pixels (WCAG 2.5.8). Larger targets (44×44 px) are recommended for touch interfaces.",
        "code": "/* Minimum WCAG 2.2 AA target size */\n.btn, a, [role=\"button\"] {\n  min-width: 24px;\n  min-height: 24px;\n}\n\n/* Recommended for touch: */\n.btn {\n  min-width: 44px;\n  min-height: 44px;\n  padding: 0.5rem 1rem;\n}"
      },
      "effort": "medium",
      "impacted_users": "Mobile/touch users and users with motor disabilities",
      "expected": "All interactive targets must be at least 24×24 CSS pixels (WCAG 2.5.8). Spacing or a larger equivalent target is an acceptable alternative.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "WCAG 2.5.8 provides an exception for inline text links within a sentence (e.g., 'see our privacy policy') where sufficient spacing around the link satisfies the criterion. axe may flag these — verify whether the exception applies before adding padding that could break the text flow.",
      "manual_test": {
        "description": "Measure the rendered size of small interactive elements — CSS values alone can be misleading.",
        "steps": [
          "In DevTools, inspect icon-only buttons, checkboxes, and radio inputs.",
          "Check the computed width and height including padding in the Box Model panel.",
          "On a touch device or with DevTools device emulation, attempt to tap small targets to confirm they are hittable."
        ]
      }
    },
    "td-headers-attr": {
      "fix": {
        "description": "Ensure every ID referenced in a td's headers attribute matches an existing th element in the same table.",
        "code": "<table>\n  <thead>\n    <tr>\n      <th id=\"col-name\">Name</th>\n      <th id=\"col-dept\">Department</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td headers=\"col-name\">Alice</td>\n      <td headers=\"col-dept\">Engineering</td>\n    </tr>\n  </tbody>\n</table>"
      },
      "effort": "medium",
      "impacted_users": "Screen reader users navigating complex tables",
      "expected": "When the headers attribute is used on <td>, every referenced ID must point to a valid <th> element in the same table.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "The headers attribute is only needed for complex tables where a single cell spans multiple headers or the column/row relationship is ambiguous. For simple tables (one header row, one header column), use <th scope='col'> and <th scope='row'> instead — it is simpler and better supported across AT. Only use the headers attribute when scope is insufficient.",
      "framework_notes": {
        "react": "In React, generate table IDs programmatically: const colId = `col-${column.key}`; <th id={colId}> and <td headers={colId}>. Ensure IDs are unique if multiple table instances render on the same page.",
        "vue": "In Vue, bind unique IDs: :id='`col-${col.key}`' on <th> and :headers='`col-${col.key}`' on <td>. Use a table-scoped unique prefix if multiple tables exist.",
        "angular": "In Angular, generate IDs in the component: colId = (col: Column) => `col-${col.key}`; and bind [attr.id]='colId(col)' on th and [attr.headers]='colId(col)' on td."
      },
      "related_rules": [
        {
          "id": "th-has-data-cells",
          "reason": "Fix td-headers-attr and th-has-data-cells together — they are complementary table structure rules."
        }
      ],
      "manual_test": {
        "description": "Navigate a complex table with a screen reader and verify column/row headers are announced for each cell.",
        "steps": [
          "Navigate into a table cell with NVDA or JAWS — the AT must announce the associated column and row header.",
          "In DevTools, inspect each <td headers='...'> — confirm every referenced ID exists as a <th id='...'> in the same table.",
          "For simple tables, verify <th scope='col'> and <th scope='row'> are used instead of the headers attribute."
        ]
      }
    },
    "th-has-data-cells": {
      "fix": {
        "description": "Ensure every <th> element has at least one associated data cell (<td>). Remove header cells for empty columns or convert them to <td> if they contain data rather than labels.",
        "code": "<table>\n  <thead>\n    <tr>\n      <th scope=\"col\">Name</th>\n      <th scope=\"col\">Role</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Alice</td>\n      <td>Engineer</td>\n    </tr>\n  </tbody>\n</table>"
      },
      "effort": "medium",
      "impacted_users": "Screen reader users navigating tables",
      "expected": "Every <th> must have at least one associated data cell — a header with no data cells is meaningless structure.",
      "false_positive_risk": "medium",
      "fix_difficulty_notes": "This rule commonly fires on dynamically rendered tables that show an empty state (loading spinner or 'No data' row). axe flags the <th> elements as having no data cells when the table body is empty or renders a colspan'd message. Guard the table to only display headers when data is present, or use a non-table element for the empty state.",
      "framework_notes": {
        "react": "In React, render a fallback when the data array is empty: if (!rows.length) return <p>No results found.</p>. Do not render the <table> with headers and an empty <tbody>.",
        "vue": "In Vue, use v-if='rows.length' on the <table> element. Provide an empty-state <p> or <div> with v-else outside the table.",
        "angular": "In Angular, use *ngIf='rows.length' on the <table> element and provide an alternative empty-state template with *ngIf='!rows.length'."
      },
      "related_rules": [
        {
          "id": "td-headers-attr",
          "reason": "Fix table structure rules together — td-headers-attr and th-has-data-cells are complementary."
        }
      ],
      "manual_test": {
        "description": "Verify every column and row header has corresponding data cells in the rendered table.",
        "steps": [
          "Inspect the table in DevTools — count <th> elements in the header row and confirm the same number of columns exist in each data row.",
          "Navigate into each cell with a screen reader — the AT must announce the associated header for every data cell.",
          "Check tables rendered in an empty state — if <th> headers exist but <tbody> is empty, the violation is present."
        ]
      }
    },
    "valid-lang": {
      "fix": {
        "description": "Use a valid BCP 47 language code on any element with a lang attribute.",
        "code": "<p lang=\"es\">Hola mundo</p>\n<blockquote lang=\"fr\">Citation en français</blockquote>"
      },
      "effort": "low",
      "impacted_users": "Screen reader users (language detection for pronunciation)",
      "expected": "All lang attributes must use valid BCP 47 language codes.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "This rule checks inline lang attributes on child elements (e.g., <p lang='es'>), not the root <html>. The most common mistake is copying locale codes from i18n libraries (e.g., 'en_US' with underscore) — only hyphenated BCP 47 tags are valid (e.g., 'en-US', 'es', 'fr-CA'). Verify each value against https://www.iana.org/assignments/language-subtag-registry/.",
      "framework_notes": {
        "react": "Add the lang attribute to HTML elements in JSX: <p lang='es'>Hola</p>. Works identically to plain HTML — no special React syntax needed.",
        "vue": "Use lang='es' as a standard attribute in Vue templates. For dynamic language content, bind it: <p :lang='contentLang'>{{ text }}</p>.",
        "angular": "Use [attr.lang]='locale' for dynamic language switching on inline content, or lang='es' as a static attribute for fixed foreign-language passages."
      },
      "manual_test": {
        "description": "Verify inline language switches are recognised by a screen reader.",
        "steps": [
          "Search source files for lang= attributes on elements other than <html>.",
          "Confirm each value is a valid BCP 47 tag (e.g. 'es', 'fr-CA', 'pt-BR').",
          "With a screen reader, navigate over the inline foreign-language text — the voice should switch languages."
        ]
      },
      "related_rules": [
        {
          "id": "html-has-lang",
          "reason": "The root <html> lang attribute must be set before child lang attributes are meaningful."
        },
        {
          "id": "html-lang-valid",
          "reason": "The same BCP 47 validity requirement applies to the root lang attribute."
        }
      ]
    },
    "video-caption": {
      "fix": {
        "description": "Add a <track kind='captions'> inside every <video> element. Captions must cover all speech and meaningful audio.",
        "code": "<video controls>\n  <source src=\"presentation.mp4\" type=\"video/mp4\">\n  <track kind=\"captions\" src=\"presentation.vtt\" srclang=\"en\" label=\"English\" default>\n  <track kind=\"captions\" src=\"presentation-es.vtt\" srclang=\"es\" label=\"Español\">\n</video>"
      },
      "effort": "high",
      "impacted_users": "Deaf users and users with hearing disabilities",
      "expected": "All <video> elements with audio content must have synchronized captions via a <track kind='captions'> element.",
      "false_positive_risk": "low",
      "fix_difficulty_notes": "axe cannot verify whether existing captions are accurate or synchronized — it only detects the presence of a <track kind='captions'> element. A <track> pointing to an empty or inaccurate VTT file technically passes axe but still violates WCAG 1.2.2. Always review caption content manually. For YouTube/Vimeo embeds inside <iframe>, this rule does not apply — the embedded player's caption controls are the platform's responsibility.",
      "framework_notes": {
        "react": "In React, include <track> as a child of <video>. React warns if <track> lacks a key prop when rendered in a list. Use the crossOrigin prop (camelCase) if serving captions from a different domain.",
        "vue": "In Vue, nest <track> inside <video> in the template. For dynamically loaded captions, use :src='captionUrl'. Note that Vue does not reload <track> on src change alone — recreate the video element when switching sources.",
        "angular": "In Angular, include static or dynamic <track> elements inside the <video> template. For dynamically switching caption languages, use [attr.src] binding and reload the video source programmatically."
      },
      "related_rules": [
        {
          "id": "audio-caption",
          "reason": "Both require media captions — fix all media accessibility violations together."
        }
      ],
      "manual_test": {
        "description": "Play the video with captions enabled and verify all spoken content is accurately captioned.",
        "steps": [
          "Enable captions in the player and play the full video — verify all dialogue, narration, and meaningful sound effects are captioned.",
          "Confirm captions are synchronized — they must appear when the corresponding audio plays.",
          "For third-party embeds (YouTube, Vimeo), verify the embed enables captions by default via URL parameters."
        ]
      }
    }
  }
}
